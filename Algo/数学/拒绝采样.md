[470. 用 Rand7() 实现 Rand10() - 力扣（LeetCode）](https://leetcode.cn/problems/implement-rand10-using-rand7/description/)
### 1. 核心矛盾: 如何从7个等概率事件生成10个等概率事件?
- `rand7()` 能给你 `1, 2, 3, 4, 5, 6, 7` 这7个数字, 每个数字出现的概率都是 `1/7`.
- 我们的目标是 `rand10()`, 需要等概率地生成 `1, 2, ..., 10` 这10个数字, 每个概率都应该是 `1/10`.
你不能简单地用 `rand7()` 的结果进行加减乘除或取模. 比如 `(rand7() + rand7()) % 10` 是不行的, 因为生成的数字概率不均匀 (例如生成 `7` 的概率会比生成 `1` 的概率高得多).
**核心思路:** 我们必须先构造一个**更大**的、所有结果**等概率**的样本空间, 然后从这个空间里选取一个我们能用的子集.
### 2. 第一步: 构造一个更大的均匀分布空间
==理解: 楼层 + 房间号==
```go
row := rand7() // 结果是 1~7
col := rand7() // 结果是 1~7
idx := (row-1)*7 + col
```
这两行 `rand7()` 给了我们什么? 我们可以把 `row` 和 `col` 的结果想象成一个 7x7 的表格的坐标:

|col=1|col=2|col=3|col=4|col=5|col=6|col=7|
|---|---|---|---|---|---|---|
|**row=1**|(1,1)|(1,2)|...|...|...|...|
|**row=2**|(2,1)|(2,2)|...|...|...|...|
|...|...|...|...|...|...|...|
|**row=7**|(7,1)|(7,2)|...|...|...|...|
因为 `row` 和 `col` 的取值都是独立的、等概率的, 所以这个 7x7 表格中的任意一个格子 `(row, col)` 被选中的概率都是 `1/7 * 1/7 = 1/49`. 我们成功创造出了 **49 个等概率的事件**.
`idx := (row-1)*7 + col` 这行代码的作用, 就是把 `(row, col)` 这个二维坐标映射成一个 **1 到 49** 之间的一维数字.
- 当 `row=1, col=1` 时, `idx = (1-1)*7 + 1 = 1`.
- 当 `row=1, col=7` 时, `idx = (1-1)*7 + 7 = 7`.
- 当 `row=7, col=7` 时, `idx = (7-1)*7 + 7 = 42 + 7 = 49`.
至此, 我们拥有了一个 `rand49()` 函数, 它可以等概率地生成 `1` 到 `49` 的整数.
### 3. 第二步: 拒绝不公平的样本 (Rejection)
Go
```
if idx <= 40 {
    // ...
}
```
现在我们有 `1` 到 `49` 这49个等概率的数字. 我们需要从中生成 `1` 到 `10` 的数字.
如果我们直接用 `idx % 10`, 会发生什么?
- `1, 11, 21, 31, 41` -> 模10余1
- `2, 12, 22, 32, 42` -> 模10余2
- ...
- `9, 19, 29, 39, 49` -> 模10余9
- `10, 20, 30, 40` -> 模10余0
你会发现, 得到余数 `1` 到 `9` 的各有5个 `idx` 对应, 而得到余数 `0` 的只有4个 `idx` 对应. 这样概率就不均匀了!
**拒绝采样的精髓来了:** 为了保证绝对的公平, 我们要舍弃掉那些会破坏公平性的"多余"样本.
我们需要找到 49 以内, 10 的最大整数倍, 那就是 40.
我们只使用 1 到 40 这个范围内的 idx 值. 因为在这个范围内, 每个余数 (0到9) 都恰好有 40 / 10 = 4 个数字与之对应, 概率是完全均匀的.
如果 idx 生成的数字在 41 到 49 之间怎么办?
丢弃它, 重新生成!
这就是 for {} 无限循环的意义. 只要生成的数字不理想, 就一直重复第一步, 直到生成一个 1 到 40 之间的数字为止. 就像抽奖, 抽到不想要的就扔掉重抽, 直到抽到想要的为止.
### 4. 第三步: 映射到目标区间 1~10
Go
```
return 1 + (idx-1)%10
```
经过第二步的筛选, 我们保证了 `idx` 是一个 `1` 到 `40` 之间的、等概率的随机数. 现在我们把它映射到 `1` 到 `10` 就很简单了.
1. `idx - 1`: 将 `1~40` 的范围变成 `0~39`. 为什么要这样做? 因为取模运算 `%` 对 `0` 开头的序列更友好.
2. `(idx - 1) % 10`: 将 `0~39` 的范围映射到 `0~9`. 因为我们保证了 `1~40` 是均匀的, 所以这里的 `0~9` 也是均匀的, 每个数字出现的概率都是 `1/10`.
3. `1 + ...`: 最后, 将 `0~9` 的范围整体加1, 变成我们最终想要的 `1~10`.
### 总结
这个解法可以概括为三部曲:
1. **升维构造:** 用两个 `rand7()` 构造出一个 `rand49()`, 获得一个更大的、均匀的样本空间.
2. **拒绝采样:** 从 `1~49` 中只取 `1~40` 这部分, 因为 `40` 是 `10` 的整数倍, 可以保证后续映射的公平性. 对于超出范围的 (`41~49`), 则拒绝并重试.
3. **取模映射:** 将公平的 `1~40` 范围通过取模运算, 等概率地映射到 `1~10` 的目标范围.
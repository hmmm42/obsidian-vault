[LCR 187. 破冰游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/)
有`0 1 2 3 4 5 6 7 8 9`十个数字，假设m为3,最后结果可以先记成f(10,3)，即使我们不知道它是多少。

当进行第一次时候，找到元素2 删除，此时还剩9个元素，但起始位置已经变成元素3。等价成
`3 4 5 6 7 8 9 0 1`这9个数字重新开始找。

此时这个序列最终剩下的一个值即为f(10,3)，这个序列的值和f(9,3)不同，但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。所以我们需要做的事情是找找这个序列上和f(9,3)值上有没有什么联系。

寻找过程中别忘记两点，首先可通过 **%符号**对数字有效扩充，即我们可以将`3 4 5 6 7 8 9 0 1`这个序列看成`(3,4,5,6,7,8,9,10,11)%10`.这里的10即为此时的n数值。

另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定值)。所以我们可以就找到f(10,3)和f(9,3)值之间结果的关系，
$$f(n, k)=(f(n-1, k)+k)\%n$$
```go
func iceBreakingGame(num int, target int) int {
  res := 0
  for i := range num {
    res = (res + target) % (i+1)
  }
  return res
}
```
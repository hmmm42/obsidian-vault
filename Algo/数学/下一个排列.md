[31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/)
```go
func nextPermutation(nums []int) {
	n := len(nums)
	i := n-1
	
	for ; i > 0 && nums[i] <= nums[i-1]; i-- {}
	if i == 0 {
		slices.Reverse(nums)
		return
	}
	j := n - 1
	for ; j >= i && nums[j] <= nums[i-1]; j-- {}
	nums[i-1], nums[j] = nums[j], nums[i-1]
	//sort.Ints(nums[i:])
	slices.Reverse(nums[i:])
}
```
==代码是找升序的下一个排列, 下面解法是找降序的下一个排列==
- **寻找转折点**：从右到左遍历数组，找到第一个索引 `i`，使得 `digits[i] > digits[i+1]`。
    - 这个 `i` 是我们需要改动的最高位。`i` 右边的部分已经是升序（`... < digits[i+1] < digits[i+2] < ...`），是最小的排列，无法变得更小。
    - 例如，对于 `[5, 1, 3]`，从右往左看，`3 > 1` (不满足)，`1 < 5` (满足 `5 > 1`)。所以 `i=0`，`digits[i]=5`。
    - 如果遍历完都没有找到这样的 `i`（例如 `[1, 2, 3]`），说明整个数组是升序的，已经是最小的排列，不存在更小的排列。直接返回 `-1`。
- **寻找交换点**：在 `i` 的右侧（即从 `i+1`到数组末尾），从右到左找到第一个索引 `j`，使得 `digits[j] < digits[i]`。
    - 因为 `i` 右侧的序列是升序的，所以我们找到的第一个满足条件的 `digits[j]` 一定是 `i` 右侧所有小于 `digits[i]` 的数中最大的一个。
    - 例如，对于 `[5, 1, 3]` 和 `i=0` (`digits[i]=5`)，在 `[1, 3]` 中从右往左找，第一个小于 `5` 的是 `3`。所以 `j=2`，`digits[j]=3`。
- **交换**：交换 `digits[i]` 和 `digits[j]`。
    - `[5, 1, 3]` -> 交换 `5` 和 `3` -> `[3, 1, 5]`。
- **重排右侧**：将 `i` 右侧的所有数字按 **降序** 排列。==反转==
    - 这样做是为了使 `i` 右侧的部分构成一个最大的排列，从而保证我们得到的总结果是“小于原数中的最大数”。
    - `[3, 1, 5]` -> 对 `i`（`0`）右侧的 `[1, 5]` 进行降序排列 -> `[5, 1]`。
    - 最终数组为 `[3, 5, 1]`。
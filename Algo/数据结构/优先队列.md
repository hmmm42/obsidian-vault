本质: [[二叉堆]]

`go`中应用: 实现`heap`接口
```go
type PQ []int

func (pq PQ) Len() int           { return len(pq) }
func (pq PQ) Less(i, j int) bool { return pq[i] < pq[j] } // 小根堆
func (pq PQ) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }
func (pq *PQ) Push(x any)        { *pq = append(*pq, x.(int)) }
func (pq *PQ) Pop() any {
	x := (*pq)[len(*pq)-1]
	*pq = (*pq)[:len(*pq)-1]
	return x
}

// 要使用 heap 包来操作
func main() {
	pq := &PQ{2, 1, 5}
	heap.Init(pq)
	heap.Push(pq, 3)
	fmt.Printf("minimum: %d\n", (*pq)[0])
	for pq.Len() > 0 {
		fmt.Printf("%d ", heap.Pop(pq))
	}
}
```

图结构优先队列
```go
type e struct{x, y, h int}
type pq []e
func (p pq) Len() int {return len(p)}
func (p pq) Less(i, j int) bool {return p[i].h < p[j].h}
func (p pq) Swap(i, j int) {p[i], p[j] = p[j], p[i]}
func (p *pq) Push(x any) {*p = append(*p, x.(e))}
func (p *pq) Pop() (x any) {a:=*p;x = a[len(a)-1];*p = a[:len(a)-1];return}
```

[295. 数据流的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked)
分清什么时候加入小根还是大根
每次都先加入大的那一边, 然后`pop`, 再加入小的一边 ==其实就相当于加入小的一边==
- @ 取中位数时三种情况都比较, 可以大大简化判断
```go
type MedianFinder struct {
  minq pq
  maxq pq2
}


func Constructor() MedianFinder {
  return MedianFinder{}
}

func (this *MedianFinder) AddNum(num int)  {
  if this.maxq.Len() >= this.minq.Len() {
    heap.Push(&this.maxq, num)
    mid := heap.Pop(&this.maxq)
    heap.Push(&this.minq, mid)
  } else {
    heap.Push(&this.minq, num)
    mid := heap.Pop(&this.minq)
    heap.Push(&this.maxq, mid)
  }
}


func (this *MedianFinder) FindMedian() float64 {
  // fmt.Println(this.maxq, this.minq)
  if this.maxq.Len() == this.minq.Len() {
    return float64(this.maxq[0]+this.minq[0])/2
  } else if this.maxq.Len() > this.minq.Len(){
    return float64(this.maxq[0])
  } else {
    return float64(this.minq[0])
  }
}
// 小根堆
type pq []int
func (p pq) Len() int {return len(p)}
func (p pq) Less(i, j int) bool {return p[i] < p[j]}
func (p pq) Swap(i, j int) {p[i], p[j] = p[j], p[i]}
func (p *pq) Push(x any) {*p = append(*p, x.(int))}
func (p *pq) Pop() (x any) {x = (*p)[len(*p)-1]; *p=(*p)[:len(*p)-1]; return}

type pq2 []int
func (p pq2) Len() int {return len(p)}
func (p pq2) Less(i, j int) bool {return p[i] > p[j]}
func (p pq2) Swap(i, j int) {p[i], p[j] = p[j], p[i]}
func (p *pq2) Push(x any) {*p = append(*p, x.(int))}
func (p *pq2) Pop() (x any) {x = (*p)[len(*p)-1]; *p=(*p)[:len(*p)-1]; return}
```
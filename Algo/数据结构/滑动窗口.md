框架:
```go
func slideWindow(s string) {
	// 用合适的数据结构记录窗口中的数据，根据具体场景变通
	// 比如说，我想记录窗口中元素出现的次数，就用 map
	// 如果我想记录窗口中的元素和，就可以只用一个 int
	var window = ...

	l, r := 0, 0
	for r < len(s) {
		c := s[r]
		window[c]++
		// 增大窗口
		right++
		// 进行窗口内数据的一系列更新
		...	

		// 判断左侧窗口是否要收缩
		for l < r && window needs shrink {
			d := s[l]
			window[d]--
			// 收缩窗口
			l++
			// 进行窗口内数据的一系列更新
			...
		}
	}
}
```
窗口 `[l, r)` 左闭右开: *保证初始化时没有元素*
[lc.3 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
#hot100 
==最长== 满足条件时一直扩张, 不满足后尝试收缩
```go
func lengthOfLongestSubstring(s string) int {	
	window := make(map[byte]int)
	left, right := 0, 0
	ans := 0
	for right < len(s) {
		c := s[right]
		window[c]++
		right++
		for left < right && window[c] > 1 {
			d := s[left]
			window[d]--
			left++
		}
    ans = max(ans, right-left)
	}
	return ans
}
```
[lc.76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-100-liked)
#hot100 
==最小== 不满足条件时一直扩张, 满足后尝试收缩
```go
func minWindow(s string, t string) (res string) {
  win, need := make(map[byte]int), make(map[byte]int)
  for _, c := range t {
    need[byte(c)]++
  }
  res = strings.Repeat(" ", 1e5+5)
  total := len(need)
  l, r := 0, 0
  ok := 0
  for r < len(s) {
    c := s[r]
    r++
    win[c]++
    if win[c] == need[c] {
      ok++
    }
    for ok == total && l < r {
      if r-l < len(res) {
        res = s[l:r]
      }
      d := s[l]
      if win[d] == need[d] {
        ok--
      }
      win[d]--
      l++
    }
  }
  if len(res) == 1e5+5 {
    return ""
  }
  return
}
```
[395. 至少有 K 个重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/)
==较难的middle==
需要手动添加限制, 以达到窗口的收缩
`uni, valid`两个变量, 窗口扩张和收缩时都要进行判断维护
```go
func longestSubstring(s string, k int) (res int) {
	n := len(s)
	for cnt := 1; cnt <= 26; cnt++ { //恰好有cnt个字符满足: 至少有k个重复字符
		win := make([]int, 26)
		l, r := 0, 0
		uni, valid := 0, 0
		for r < n {
			c := s[r]
			if win[c-'a'] == 0 {
				uni++
			}
			win[c-'a']++
			if win[c-'a'] == k {
				valid++
			}
			r++
			for l < r && uni > cnt { // 不满足, 开始收缩
				d := s[l]
				if win[d-'a'] == k {
					valid--
				}
				win[d-'a']--
				l++
				if win[d-'a'] == 0 {
					uni--
				}
			}
			if valid == cnt {
				res = max(res, r-l)
			}
		}

	}
	return
}
```
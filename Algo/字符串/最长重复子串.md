[1044. 最长重复子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-duplicate-substring/)
暴力思路: 枚举所有子串, 存入哈希集合中, 因为子串可能达到N, 复杂度$O(N^3)$
暴力优化: 暴力枚举改成二分, 复杂度$O(N^{2} \cdot \log N)$
动态规划: 最长公共子串, 自己和自己比较, 但是要避免同一个开始的, 复杂度$O(N^2)$
[[二分查找]]+[[Rabin-Karp]]
因为子串是可能重复的, 所以需要往字符串方向考虑
复杂度$O(N \cdot \log N)$
==不能简单地`check[hash] = true`, 还要检测哈希碰撞==
```go
func longestDupSubstring(s string) (res string) {
	mod := int(1e9 + 7)
	n := len(s)
	lo, hi := 1, n-1
loop:
	for lo <= hi {
		mid := (lo + hi) / 2
		check := make(map[int][]int)
		l, r := 0, 0
		hash := 0
		RL := 1
		for range mid - 1 {
			RL = (RL * 256) % mod
		}
		for r < n {
			hash = (hash*256 + int(s[r])) % mod
			r++
			if r-l == mid {
				if starts, ok := check[hash]; ok {
					for _, start := range starts {
						if s[l:r] == s[start:start+mid] {
							res = s[l:r]
							lo = mid + 1
							continue loop
						}
					}
				}
				check[hash] = append(check[hash], l)
				hash = (hash - int(s[l])*RL%mod + mod) % mod
				l++
			}
		}
		hi = mid - 1
	}
	return
}

```
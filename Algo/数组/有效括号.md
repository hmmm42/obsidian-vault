[最长的括号子串_牛客题霸_牛客网](https://www.nowcoder.com/practice/45fd68024a4c4e97a8d6c45fc61dc6ad?tpId=196&tqId=37079&rp=1&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page&difficulty=undefined&judgeStatus=undefined&tags=&title=%E6%8B%AC%E5%8F%B7)
[32. 最长有效括号 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)
#hot100
```go
func longestValidParentheses( s string ) (res int) {
  stk := []int{-1}
  for i, c := range s {
    if c == '(' {
      stk = append(stk, i)
    } else {
      stk = stk[:len(stk)-1]
      if len(stk) == 0 {
        stk = append(stk, i)
      } else {
        res = int(math.Max(float64(res), float64(i-stk[len(stk)-1])))
      }
    }
  }
  return res
}
```

[最长有效的括号字符子序列_牛客题霸_牛客网](https://www.nowcoder.com/practice/c6760389751e425c8da6243f8f3c4741?tpId=196&tqId=39706&rp=1&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page&difficulty=undefined&judgeStatus=undefined&tags=&title=%E6%8B%AC%E5%8F%B7)
先求出目标长度, 再使用==回溯==算出每一种可能, 验证
```go
func maxValidParenthesesStr(s string) (res []string) {
	n := len(s)
	letter, pairs := 0, 0
	l := 0
	for _, c := range s {
		if c == '(' {
			l++
		} else if c == ')' {
			if l > 0 {
        l--
        pairs++
      }
		} else {
			letter++
		}
	}
	tar := letter + pairs*2
	set := make(map[string]bool)

	var track []byte
	var backtrack func(i int)
	backtrack = func(i int) {
		if len(track) == tar {
			l := 0
			for _, c := range track {
				if c == '(' {
					l++
				} else if c == ')' {
					l--
				}
				if l < 0 {
					return
				}
			}
      if l == 0 {
        set[string(track)] = true
      }
			return
		}
		if i == n {
			return
		}

		// 不选
		backtrack(i + 1)
		// 选
		track = append(track, s[i])
		backtrack(i + 1)
		track = track[:len(track)-1]
	}
	backtrack(0)
	for key := range set {
		res = append(res, key)
	}
	return
}
```
[括号区间匹配_牛客题霸_牛客网](https://www.nowcoder.com/practice/15a63d150f69449886ea3822d64a1121?tpId=196&tqId=40387&rp=1&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page&difficulty=undefined&judgeStatus=undefined&tags=&title=%E6%8B%AC%E5%8F%B7)
栈是一种**贪心**的数据结构, 它在每一步都做出局部最优决策 (比如匹配最近的括号). 但这个问题需要一个全局最优解.
==区间dp==
`dp[i][j]` 表示: 使子字符串 `s[i...j]` (包含`i`和`j`) 成为一个合法括号序列, 所需要插入的最少括号数量
- **Case 1: `s[i]` 和 `s[j]` 本身就能配对**
    - 如果 `s[i] == '('` 且 `s[j] == ')'`, 或者 `s[i] == '['` 且 `s[j] == ']`.
    - 那么 `s[i]` 和 `s[j]` 不需要额外插入括号了. 我们只需要解决它们中间的子串 `s[i+1...j-1]` 即可.
    - 此时 `dp[i][j] = dp[i+1][j-1]`.
- **Case 2: `s[i]` 和 `s[j]` 不能配对**
    - 这种情况下, 我们有两种基本策略:
        1. **给 `s[i]` 配对:** 我们可以认为 `s[i]` 是一个独立的括号, 我们需要为它插入一个配对的括号. 那么问题就变成了 "解决`s[i]` (代价是1) + 解决`s[i+1...j]` (代价是 `dp[i+1][j]`)". 总代价是 `1 + dp[i+1][j]`.
        2. **给 `s[j]` 配对:** 同理, 我们可以认为 `s[j]` 是独立的, 为它配对. 问题就变成了 "解决`s[i...j-1]` + 解决`s[j]`". 总代价是 `1 + dp[i...j-1]`.
    - 我们总是可以把 `s[i...j]` **拆分**成两段 `s[i...k]` 和 `s[k+1...j]`. 我们独立地让这两段合法, 然后拼接起来. 总代价就是 `dp[i][k] + dp[k+1][j]`. 我们需要遍历所有可能的分割点 `k` (从 `i`到 `j-1`), 找到其中的最小值.
```go
func match( s string ) int {
  n := len(s)
  dp := make([][]int, n)
  for i := range dp {
    dp[i] = make([]int, n)
  }

	min := func(x, y int) int { return int(math.Min(float64(x), float64(y))) }

  for i := n-1; i >= 0; i-- {
    dp[i][i] = 1
    for j := i+1; j < n; j++ {
      dp[i][j] = math.MaxInt32
      if s[i] == '(' && s[j] == ')' || s[i] == '[' && s[j] == ']' {
        dp[i][j] = min(dp[i][j], dp[i+1][j-1])
      }
      for k := i; k < j; k++ {
        dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j])
      }
    }
  }
  return dp[0][n-1]
}
```
[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/description/)
这题对叶子节点有严格要求, 要特别判断
```go
func hasPathSum(root *TreeNode, targetSum int) bool {
  if root == nil {
    return false
  }
  if root.Left == nil && root.Right == nil {
    if root.Val == targetSum {
      return true
    }
    return false
  }
  return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)
}
```
[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/description/)
```go
func pathSum(root *TreeNode, targetSum int) (res [][]int) {
  if root == nil {
    return 
  }
  var track []int
  var trav func(node *TreeNode, cur int)
  trav = func(node *TreeNode, cur int) {
    if node == nil {
      return
    }
    track = append(track, node.Val)
    defer func(){
      track = track[:len(track)-1]
    }()
    cur += node.Val
    if node.Left == nil && node.Right == nil {
      if cur == targetSum {
        res = append(res, append([]int(nil), track...))
      }
      return
    }
    trav(node.Left, cur)
    trav(node.Right, cur)
  }
  trav(root, 0)
  return
}
```
[437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/description/)
要求路径向下, 哈希表统计前缀和出现的次数(因为有负数, 所以一条路径上某个部分和可能出现多次)
在前序位置, 检查从根节点到当前节点有多少路径满足`targetSum`, 同时维护`preSumCnt`
- **前缀和 (Prefix Sum):**`sum`记录 **从根节点到当前节点的路径和**. 这就是前缀和.
- **哈希表 (Hash Map):**
    - **记忆:** 在我们从根节点走到当前节点的路上, 每一个前缀和 (`sum`) 都出现过多少次.
    - **查询:** 在当前节点, 我们可以瞬间查出 `当前前缀和 - 目标和` 这个 "历史前缀和" 出现过几次. 出现过几次, 就意味着有几条符合条件的路径.
```go
func pathSum(root *TreeNode, targetSum int) int {
	preSumCnt := make(map[int]int)
	preSumCnt[0] = 1
	res, sum := 0, 0
	var trav func(node *TreeNode)
	trav = func(node *TreeNode) {
		if node == nil {
			return
		}
		sum += node.Val
		res += preSumCnt[sum-targetSum]
		preSumCnt[sum]++
		trav(node.Left)
		trav(node.Right)
		preSumCnt[sum]--
		sum -= node.Val
	}
	trav(root)
	return res
}
```

[124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)
#hot100 **hard**
后序位置, 维护最大值
注意如果返回结果是负数, 则选择不取
```go
func maxPathSum(root *TreeNode) int {
	res := math.MinInt
	var trav func(node *TreeNode) int
	trav = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		l := max(0, trav(node.Left))
		r := max(0, trav(node.Right))
		res = max(res, node.Val+l+r)
		return max(l, r) + node.Val
	}
    trav(root)
    return res
}


```
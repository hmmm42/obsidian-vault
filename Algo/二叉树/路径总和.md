[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/description/)
这题对叶子节点有严格要求, 要特别判断
```go
func hasPathSum(root *TreeNode, targetSum int) bool {
  if root == nil {
    return false
  }
  if root.Left == nil && root.Right == nil {
    if root.Val == targetSum {
      return true
    }
    return false
  }
  return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)
}
```
[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/description/)
```go
func pathSum(root *TreeNode, targetSum int) (res [][]int) {
  if root == nil {
    return 
  }
  var track []int
  var trav func(node *TreeNode, cur int)
  trav = func(node *TreeNode, cur int) {
    if node == nil {
      return
    }
    track = append(track, node.Val)
    defer func(){
      track = track[:len(track)-1]
    }()
    cur += node.Val
    if node.Left == nil && node.Right == nil {
      if cur == targetSum {
        res = append(res, append([]int(nil), track...))
      }
      return
    }
    trav(node.Left, cur)
    trav(node.Right, cur)
  }
  trav(root, 0)
  return
}
```
[437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/description/)
要求路径向下, 哈希表统计前缀和出现的次数(因为有负数, 所以一条路径上某个部分和可能出现多次)
- **深度优先搜索 (DFS):** 这是算法的 "腿脚", 负责遍历树中的每一个节点, 确保没有遗漏. `trav` 函数就是这个角色.
- **前缀和 (Prefix Sum):** 这是算法的 "大脑". 在遍历时, `sum` 变量并不记录当前路径的和, 而是记录 **从根节点到当前节点的路径和**. 这就是前缀和.
- **哈希表 (Hash Map):** 这是算法的 "超级记忆". 它 `preSumCnt` 的作用是:
    - **记忆:** 在我们从根节点走到当前节点的路上, 每一个前缀和 (`sum`) 都出现过多少次.
    - **查询:** 在当前节点, 我们可以瞬间查出 `当前前缀和 - 目标和` 这个 "历史前缀和" 出现过几次. 出现过几次, 就意味着有几条符合条件的路径.
```go
func pathSum(root *TreeNode, targetSum int) int {
	preSumCnt := make(map[int]int)
	preSumCnt[0] = 1
	res, sum := 0, 0
	var trav func(node *TreeNode)
	trav = func(node *TreeNode) {
		if node == nil {
			return
		}
		sum += node.Val
		if val, ok := preSumCnt[sum-targetSum]; ok {
			res += val
		}
		preSumCnt[sum]++
		trav(node.Left)
		trav(node.Right)
		preSumCnt[sum]--
		sum -= node.Val
	}
	trav(root)
	return res
}

```
[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)
[二叉树展开为单链表_牛客题霸_牛客网](https://www.nowcoder.com/practice/421a1099535149c0828ad7a6e1ce7b40?tpId=196&tqId=40396&rp=1&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D%25E4%25B8%25AD%25E4%25BD%258D%25E6%2595%25B0%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AC%2594%25E9%259D%25A2%25E8%25AF%2595%25E7%25AF%2587%26topicId%3D196&difficulty=undefined&judgeStatus=undefined&tags=&title=%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80)
#hot100
### 迭代
我们不再使用后序遍历, 而是采用一种**类似先序遍历**的顺序来处理节点. 对于当前遍历到的节点 `curr`, 我们要做的就是:
1. 找到它的**左子树中的最右侧的节点** (我们称之为 `predecessor`, 即前驱节点).
2. 将 `curr` 原本的**右子树**,嫁接到这个 `predecessor` 的右孩子上.
3. 将 `curr` 的**整个左子树**,移动到 `curr` 的右孩子位置.
4. 将 `curr` 的左孩子置为 `nil`.
5. 处理下一个节点 (移动后的 `curr.Right`).
通过不断重复这个过程, 我们就能自上而下地将树 "拉平".
```go
func expandTree( root *TreeNode ) *TreeNode {
  cur := root
  for cur != nil {
    if cur.Left != nil {
      pre := cur.Left
      for pre.Right != nil {
        pre = pre.Right
      }
      pre.Right = cur.Right
      cur.Right = cur.Left
      cur.Left = nil
    }
    cur = cur.Right
  }
  return root
}
```
### 递归
```go
func expandTree( root *TreeNode ) *TreeNode {
  var pre *TreeNode = nil
  var flatten func(node *TreeNode)
  flatten = func(node *TreeNode) {
    if node == nil {
      return
    }
    flatten(node.Right) // 先右后左的后序位置
    flatten(node.Left)
    node.Right = pre
    node.Left = nil
    pre = node
  }
  flatten(root)
  return root
}
```
#二分查找 
统一查找逻辑:闭区间, `l == r+1` 时返回
# 直接查找
```go
func binarySearch(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] < target {
			left = mid + 1
		} else if nums[mid] > target {
			right = mid - 1
		} else if nums[mid] == target {
			// 直接返回
			return mid
		}
	}
	// 直接返回
	return -1
}
```

# 左侧边界
最后一次查找时, `nums[mid] == target`, `right = mid - 1`
`left = right+1 = mid`
```go
func leftBound(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] < target {
			left = mid + 1
		} else if nums[mid] > target {
			right = mid - 1
		} else if nums[mid] == target {
			// 别返回，锁定左侧边界
			right = mid - 1
		}
	}
	// 判断 target 是否存在于 nums 中
	if left < 0 || left >= len(nums) {
		return -1
	}
	// 判断一下 nums[left] 是不是 target
	if nums[left] == target {
		return left
	}
	return -1
}
```
# 右侧边界
最后一次查找时, `nums[mid] == target`, `left = mid + 1`
`right = left-1 = mid`
```go
func rightBound(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] < target {
			left = mid + 1
		} else if nums[mid] > target {
			right = mid - 1
		} else if nums[mid] == target {
			// 别返回，锁定右侧边界
			left = mid + 1
		}
	}
	
	if right < 0 || right >= len(nums) {
		return -1
	}
	if nums[right] == target {
		return right
	}
	return -1
}
```

# 标准库二分查找
假设靠左为`false`, 靠右为`true`, 返回最靠左的满足`true`的下标
eg. 在一个已排序的数组中查找第一个大于等于某个值的元素的索引
```go
n := len(a)
index := sort.Search(n, func(i int) bool { 
	// f(i) 的条件是：a[i] >= x 是否成立
	return a[i] >= x 
})
等价于 sort.Search(a, x)
```
[658. 找到 K 个最接近的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/find-k-closest-elements/description/)
关键是会以外层目标数为循环计数
注意每次先排除边界情况
```go
func findClosestElements(arr []int, k int, x int) []int {
  n := len(arr)
  i := sort.SearchInts(arr, x)
  l, r := i-1, i
  for range k {
    if l < 0 {
      r++
      continue
    }
    if r == n {
      l--
      continue
    }
    if x-arr[l] <= arr[r]-x {
      l--
    } else {
      r++
    }
  }
  // 目标区间是[l+1, r-1]
  return arr[l+1:r]
}
```

**lc475. 取暖器**
```go
func findRadius(houses []int, heaters []int) int {
	//hs := redblacktree.New[int, bool]()
	//for _, h := range heaters {
	//	hs.Put(h, true)
	//}
	//res := 0
	//for _, h := range houses {
	//	l, lok := hs.Floor(h)
	//	r, rok := hs.Ceiling(h)
	//	canReach := 0
	//	if lok && rok {
	//		canReach = min(h-l.Key, r.Key-h)
	//	} else if lok {
	//		canReach = h - l.Key
	//	} else if rok {
	//		canReach = r.Key - h
	//	}
	//	res = max(res, canReach)
	//}
	//return res
	
	// 不需要动态维护, 将红黑树改为使用内置 sort, 结合二分查找
	sort.Ints(heaters)
	res := 0
	for _, h := range houses {
		nxt := sort.SearchInts(heaters, h) // heaters[nxt] >= h
		minDis := math.MaxInt
		if nxt < len(heaters) {
			minDis = heaters[nxt] - h
		}
		pre := nxt-1
		if pre >= 0 {
			minDis = min(minDis, h-heaters[pre])
		}
		res = max(res, minDis)
	}
	return res
}

```

**lc2141. 连接电池**
```go
func maxRunTime(n int, batteries []int) int64 {
	total := 0
	for _, b := range batteries {
		total += b
	}
	return int64(sort.Search(total/n, func(x int) bool {
		// sort.Search 找到的是第一个使条件为 true 的索引，
		// 而我们实际需要的是最后一个使条件为 false 的索引
		// 所以先 x+1
		x++
		sum := 0
		for _, b := range batteries {
			sum += min(x, b)
		}
		return n*x > sum
		// 如果 n*x > sum, 说明电量不能满足当前运行时间
		// 返回 true, x 往小调整
	}))
}

```
[875. 爱吃香蕉的珂珂 - 力扣（LeetCode）](https://leetcode.cn/problems/koko-eating-bananas/description/)
为防止除0, 要整体向右偏移
```go
	return sort.Search(1e9+1, func(x int) bool {
		x++
		cnt := 0
		for _, v := range piles {
			cnt += v / x
			if v%x > 0 {
				cnt++
			}
		}
		return cnt <= h
	}) + 1

```

[4. 寻找两个正序数组的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)
==hard题==
#hot100 
```go
func findMedianSortedArrays(a []int, b []int) float64 {
	if len(a) > len(b) {
		a, b = b, a
	}
	m, n := len(a), len(b)
	i := sort.Search(m, func(i int) bool {
		j := (m+n+1)/2 - i - 2
		return a[i] > b[j+1]
	}) - 1
	j := (m+n+1)/2 - i - 2
	
	ai := math.MinInt
	if i >= 0 {
		ai = a[i]
	}
	bj := math.MinInt
	if j >= 0 {
		bj = b[j]
	}
	ai1 := math.MaxInt
	if i+1 < m {
		ai1 = a[i+1]
	}
	bj1 := math.MaxInt
	if j+1 < n {
		bj1 = b[j+1]
	}
	max1, min2 := max(ai, bj), min(ai1, bj1)
	if (m+n)%2 > 0 {
		return float64(max1)
	}
	return float64(max1+min2) / 2
}


```
# 二分查找断崖
有序数组旋转后出现断崖
[162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/)
```go
func findPeakElement(nums []int) int {
  l, r := 0, len(nums)
  n := len(nums)
  for l <= r {
    mid := (l+r)/2
    pre := math.MinInt
    if mid > 0 {
      pre = nums[mid-1]
    }
    nxt := math.MinInt
    if mid < n-1 {
      nxt = nums[mid+1]
    }
    cur := nums[mid]
    if pre < cur && cur > nxt {
      return mid
    }
    if pre < cur && cur < nxt {
      l = mid+1
    } else {
      r = mid-1
    }
  }
  return -1
}
```

[33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)
#hot100
- ! 很难!!!
==`mid`的计算`l + (r-l)/2`在区间为偶数长度时会偏向左边，导致 `mid` 可能等于 `l`
所以`nums[mid] >= nums[l]`一定是大于等于, 才能处理只有单个元素的有序区间==
```go
func search(nums []int, target int) int {
	n := len(nums)
	l, r := 0, n-1
	for l <= r {
		mid := l + (r-l)/2
    if nums[mid] == target {
      return mid
    }
		if nums[mid] >= nums[l] { 
			if nums[mid] >= target && target >= nums[l] {
			  r = mid - 1
			} else {
			  l = mid + 1
			}
		} else { 
			if nums[mid] <= target && target <= nums[r] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```
[81. 搜索旋转排序数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)
相比上一题, 就多了对l, r去重 ==复杂度退化到O(N)==
```go
func search(nums []int, target int) bool {
	l, r := 0, len(nums)-1
	for l <= r {
		for l < r && nums[l] == nums[l+1] {
			l++
		}
		for l < r && nums[r] == nums[r-1] {
			r--
		}
		mid := l + (r-l)/2
		if nums[mid] == target {
			return true
		}
		
		if nums[mid] >= nums[l] {
			if nums[mid] > target && target >= nums[l] {
				r = mid - 1
			} else {
				l = mid + 1
			}
		} else {
			if nums[mid] < target && target <= nums[r] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return false
}

```
[153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)
#hot100 
这题又不一样了, 一定要将r作为锚点
==最好的方法一定是, 自己列举2个元素, 1个元素时的场景==
```go
// 开区间
func findMin(nums []int) int {
	l, r := 0, len(nums)-1
	for l < r { // 本质上是左闭右开的区间, 所以 r 需要保留检查
		mid := l + (r-l)/2
		if nums[mid] < nums[r] { // 这里<=也行, 因为只有l才可能会出现2个时, mid=l
			r = mid
		} else {
			l = mid + 1 // 如果是l=mid, 会无限循环
		}
	}
	return nums[l]
}

// 闭区间
func findMin(nums []int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)/2
		if nums[mid] < nums[r] {
			r = mid // 不设置成 mid-1, 是为了防止跳过最小值
		} else {
			l = mid + 1
		}
	}
	// 最后一次查找时, mid == l == r, nums[mid] 满足条件
	// 退出时 l 设置为 mid+1, 所以结果为 nums[l-1]
	return nums[l-1]
}
```
计算计算机科学中用于描述算法复杂度的五种渐近记号及其示例如下：

1. **大 O 记号（Big O）**  
定义：表示函数的渐进上界，即算法的最坏时间复杂度。存在常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$，有 $0 \leq f(n) \leq c \cdot g(n)$。  
示例：  
• $3n + 5 = O(n)$，因为存在 $c=4$ 时，$3n + 5 \leq 4n$ 对所有 $n \geq 5$ 成立。  

• 快速排序的平均时间复杂度为 $O(n \log n)$。  


2. **大 Ω 记号（Big Omega）**  
定义：表示函数的渐进下界，即算法的最好时间复杂度。存在常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$，有 $0 \leq c \cdot g(n) \leq f(n)$。  
示例：  
• $n^2 + 2n = \Omega(n)$，因为当 $c=1$ 时，$n^2 + 2n \geq n$ 对所有 $n \geq 1$ 成立。  

• 插入排序的最好情况（已有序数组）时间复杂度为 $\Omega(n)$。  


3. **大 Θ 记号（Big Theta）**  
定义：表示函数的精确渐进界，即同时满足 $O(g(n))$ 和 $\Omega(g(n))$。存在常数 $c_1, c_2, n_0$，使得对所有 $n \geq n_0$，有 $0 \leq c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n)$。  
示例：  
• $2n^2 + 3n + 1 = \Theta(n^2)$，因为存在 $c_1=2$ 和 $c_2=3$ 满足 $2n^2 \leq 2n^2 + 3n +1 \leq 3n^2$ 对足够大的 $n$ 成立。  


4. **小 o 记号（Little o）**  
定义：表示非紧确的渐进上界，即 $f(n)$ 的增长速率严格慢于 $g(n)$。对任意常数 $c > 0$，存在 $n_0$ 使得对所有 $n \geq n_0$，有 $0 \leq f(n) < c \cdot g(n)$。  
示例：  
• $2n = o(n^2)$，因为无论 $c$ 多小（如 $c=0.1$），当 $n$ 足够大时，$2n < 0.1n^2$。  


5. **小 ω 记号（Little Omega）**  
定义：表示非紧确的渐进下界，即 $f(n)$ 的增长速率严格快于 $g(n)$。对任意常数 $c > 0$，存在 $n_0$ 使得对所有 $n \geq n_0$，有 $0 \leq c \cdot g(n) < f(n)$。  
示例：  
• $n^2 = \omega(n)$，因为无论 $c$ 多大（如 $c=100$），当 $n$ 足够大时，$n^2 > 100n$。  


**对比总结**  

| 符号       | 关系      | 示例                   |
| -------- | ------- | -------------------- |
| $O$      | 上界（含等于） | $3n = O(n)$          |
| $\Omega$ | 下界（含等于） | $3n = O(n)$          |
| $\Theta$ | 明确界     | $2n^2 = \Theta(n^2)$ |
| $o$      | 严格上界    | $2n = o(n^2)$        |
| $\omega$ | 严格下界    | $n^2 = \omega(n)$    |

# 递归复杂度
以下是求解递归式时间复杂度的三种核心方法及示例：

---

1. **代换法（Substitution Method）**
原理：通过猜测解的形式（如 $O(n \log n)$），再用数学归纳法验证猜测的正确性。
步骤：
- 假设递归式的解为某个渐近复杂度（如 $T(n) = O(n \log n)$）。
- 用归纳法证明该假设对递归式的所有情况成立。

示例：
递归式：$T(n) = 2T(n/2) + n$
• 猜测：$T(n) = O(n \log n)$

• 验证：

  假设对 $k < n$，有 $T(k) \leq ck \log k$。代入递归式：
  $$
  T(n) \leq 2c(n/2) \log(n/2) + n = cn (\log n - 1) + n = cn \log n - cn + n \leq cn \log n \quad (\text{当 } c \geq 1)
  $$
  因此，$T(n) = O(n \log n)$ 成立。

---

2. **递归树法（Recursion Tree Method）**
原理：将递归式展开为树状结构，逐层累加各节点的计算成本，最后求和得到总复杂度。
步骤：
3. 绘制递归调用的树形结构，每层表示一次递归调用。
4. 计算每层的总成本，最后求和所有层的成本。

示例：
递归式：$T(n) = 3T(n/4) + cn^2$
• 递归树分析：

  • 根节点：$cn^2$

  • 第二层：3个子节点，每个成本为 $c(n/4)^2$，总成本 $3c(n^2/16) = 3cn^2/16$

  • 第三层：9个子节点，总成本 $9c(n^2/256) = 9cn^2/256$

  • 总成本为等比数列求和：$cn^2 \left(1 + 3/16 + 9/256 + \cdots \right) \leq cn^2 \cdot 1/(1-3/16) = O(n^2)$
  最终复杂度为 $O(n^2)$d
	
- @ 无穷收敛等比数列求和: $\frac{a}{1-q}$ a为首项, q为公比

---

3. **主定理（Master Theorem）**
原理：针对形如 $T(n) = aT(n/b) + f(n)$ 的递归式，通过比较 $f(n)$ 与 $n^{\log_b a}$ 的阶来快速求解复杂度。
三种情况：
- Case 1：若 $f(n) = O(n^{\log_b a - \epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$。*树枝*
- Case 2：若 $f(n) = \Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \log n)$。 *平均*
- Case 3：若 $f(n) = \Omega(n^{\log_b a + \epsilon})$ 且 $af(n/b) \leq cf(n)$，则 $T(n) = \Theta(f(n))$。 *树根*

示例：
递归式：$T(n) = 2T(n/2) + n$
• 参数：$a=2, b=2, f(n)=n$

• 比较：$n^{\log_2 2} = n$，且 $f(n) = \Theta(n)$，属于 Case 2，因此 $T(n) = \Theta(n \log n)$。


---

**对比与适用场景**
| 方法       | 适用场景                           | 优势与局限                          |
|------------|-----------------------------------|-------------------------------------|
| 代换法     | 解的形式容易猜测时（如常见递归模式） | 依赖猜测能力，需数学归纳法验证 |
| 递归树法   | 递归结构复杂但分层规律性强时        | 可视化分析，但求和计算可能繁琐 |
| 主定理     | 符合标准形式 $T(n) = aT(n/b) + f(n)$ | 快速求解，但仅适用于特定形式  |

综合示例：
• 斐波那契数列：$T(n) = T(n-1) + T(n-2) + 1$

  递归树法显示指数级分支，复杂度为 $O(2^n)$。
• Strassen矩阵乘法：$T(n) = 7T(n/2) + O(n^2)$

  主定理得 $T(n) = O(n^{\log_2 7}) \approx O(n^{2.81})$。

通过这些方法，可以系统化地分析递归算法的复杂度，选择合适策略优化性能。

# 复杂度分析
$\log(n!)=\Theta(n\log n)$
证明: #TODO
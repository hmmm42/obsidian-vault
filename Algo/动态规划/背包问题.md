# 0-1背包
==每个物品只能选一次==
- 状态: 背包容量, 选择的物品
- 选择: 装进背包, 不装进背包
`dp[i][j]`表示: 对前`i`个物品, 背包容量为`j`时可以装的最大价值 
状态转移方程: `dp[i][j] = max(dp[i-1][j], dp[i-1][pre]+w[i-1])` 
- @ 如果是`dp[i][pre]+w[i-1]`, 就是不限制选用同一个物品, 转化为完全背包问题
复杂度$O(n * m)$, 需要嵌套循环
> 如果要状态压缩, 内层循环必须倒序: 每一次外层循环中, 所有数据都被更新

[【模板】01背包_牛客题霸_牛客网](https://www.nowcoder.com/practice/fd55637d3f24484e96dad9e992d3f62e?tpId=308&tqId=2032484&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
```go
func main() {
	var n, V int
	fmt.Scan(&n, &V)
	v, w := make([]int, n), make([]int, n)
	for i := range v {
		fmt.Scan(&v[i], &w[i])
	}
	max := func(x, y int) int { return int(math.Max(float64(x), float64(y))) }

	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, V+1)
    
	}
	for i := 1; i <= n; i++ {
		for j := 0; j <= V; j++ { // 注意从0开始
			dp[i][j] = dp[i-1][j]
			pre := j - v[i-1]
			if pre >= 0 {
				dp[i][j] = max(dp[i][j], dp[i-1][pre]+w[i-1])
			}
		}
	}
	fmt.Println(dp[n][V])
	
	// 必须恰好装满
	dp = make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, V+1)
    for j := range dp[i] {
      dp[i][j] = -1
    }
	}
	// 保证可达
  dp[0][0] = 0
	for i := 1; i <= n; i++ {
		for j := 0; j <= V; j++ {
      dp[i][j] = dp[i-1][j]
			pre := j - v[i-1]
			if pre >= 0 && dp[i-1][pre] != -1 {
				dp[i][j] = max(dp[i][j], dp[i-1][pre]+w[i-1])
			}
		}
	}
  if dp[n][V] == -1 {
    fmt.Println(0)
  } else{
	fmt.Println(dp[n][V])}
}
```
[2915. 和为目标值的最长子序列的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/description/)
0-1背包, 目标和恰好为`target`
`dp[i][j]`表示: 对前`i`个物体, 选得总价值为`j`时, 物体的容量和
```go
func lengthOfLongestSubsequence(nums []int, target int) int {
	n := len(nums)
	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, target+1)
		for j := 1; j <= target; j++ {
			dp[i][j] = math.MinInt
		}
	}
	for i := 1; i <= n; i++ {
		for j := range target + 1 {
			dp[i][j] = dp[i-1][j] // 不选, 注意先赋值, 不能因为没有pre而跳过
			pre := j - nums[i-1]
			if pre < 0 {
				continue
			}
			dp[i][j] = max(dp[i][j], dp[i-1][pre]+1) // 选
		}
	}
	
	if dp[n][target] <= 0 {
		return -1
	}
	return dp[n][target]
}
```

## 物品价值只有两种
问题的核心思想是：我们应该优先考虑价值为2的物品，因为它们的“性价比”可能更高。我们可以遍历所有可能拿取的价值为2的物品的组合，然后用剩余的背包容量去尽可能多地装价值为1的物品。

为了让这个过程更高效，我们可以：
1.  将物品按价值分为两组：价值为1的和价值为2的。
2.  对两组物品分别按重量从小到大排序。这样，当我们决定拿 `k` 个物品时，我们总是选择最轻的 `k` 个。
3.  计算价值为1物品的重量前缀和，这样可以用二分查找快速确定在给定容量下最多能装多少个价值为1的物品。
4.  遍历我们可能选择的价值为2的物品数量（从0个到最多能装下的个数），对于每一种情况，计算剩余容量，并用二分查找确定可以装入多少个价值为1的物品，最后更新最大总价值。
```go
package main

import (
	"fmt"
	"sort"
)

// Item 定义物品结构
type Item struct {
	Weight int
	Value  int
}

// max 返回两个整数中的较大值
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// maxTotalValue 计算能装入背包的最大价值
// W: 背包的总容量
// items: 物品列表
func maxTotalValue(W int, items []Item) int {
	var ones, twos []int

	// 1. 将物品按价值分为两组
	for _, item := range items {
		if item.Value == 1 {
			ones = append(ones, item.Weight)
		} else {
			twos = append(twos, item.Weight)
		}
	}

	// 2. 对两组物品的重量进行升序排序
	sort.Ints(ones)
	sort.Ints(twos)

	// 3. 计算价值为1物品的重量前缀和
	// prefixOnes[i] 表示前 i 个（最轻的）价值为1物品的总重量
	prefixOnes := make([]int, len(ones)+1)
	for i := 0; i < len(ones); i++ {
		prefixOnes[i+1] = prefixOnes[i] + ones[i]
	}

	maxVal := 0
	currentTwosWeight := 0

	// 4. 遍历选择价值为2的物品数量 (i)
	// i = 0 表示一个价值为2的物品都不选
	for i := 0; i <= len(twos); i++ {
		if i > 0 {
			currentTwosWeight += twos[i-1]
		}

		// 如果当前价值为2的物品总重量已经超过背包容量，后续更多也装不下，退出循环
		if currentTwosWeight > W {
			break
		}

		// 计算剩余容量
		remainingW := W - currentTwosWeight

		// 使用二分查找 (sort.Search) 在前缀和数组中找到
		// 最多能装下多少个价值为1的物品
		// sort.Search 会找到第一个满足 prefixOnes[k] > remainingW 的索引 k
		// 所以 k-1 就是我们能装下的物品数量
		k := sort.Search(len(prefixOnes), func(j int) bool {
			return prefixOnes[j] > remainingW
		})
		
		// k-1 是能装下的价值为1物品的数量
		numOnes := max(k-1, 0)
		// 计算当前组合的总价值并更新最大值
		// 当前价值 = (i个价值为2的物品) + (numOnes个价值为1的物品)
		currentVal := i*2 + numOnes
		maxVal = max(maxVal, currentVal)
	}

	return maxVal
}
```

### 算法解析

1.  **分类和排序**: 首先将物品按价值1和2分开，并对它们的重量进行排序。这是贪心策略的基础，因为要达到最大价值，对于同价值的物品，我们肯定优先选择重量轻的。
2.  **前缀和**: `prefixOnes` 数组是优化的关键。`prefixOnes[i]` 存储了最轻的 `i` 个价值为1的物品的总重量。这使得我们可以在 $O(\\log N)$ 的时间内，通过二分查找快速知道“用 `X` 的容量最多能装几个价值为1的物品”。
3.  **主循环**: 循环变量 `i` 代表我们尝试放入 `i` 个最轻的、价值为2的物品。

      * 计算这 `i` 个物品的总重量 `currentTwosWeight`。
      * 如果 `currentTwosWeight` 已经超重，那么再增加价值为2的物品就没有意义了，循环可以提前终止。
      * 用背包总容量 `W` 减去 `currentTwosWeight`，得到 `remainingW`，这是留给价值为1物品的容量。
      * 利用 `sort.Search` 在前缀和数组 `prefixOnes` 上进行二分查找，迅速找到 `remainingW` 能装下的价值为1物品的最大数量 `numOnes`。
      * `i*2 + numOnes` 就是当前组合下的总价值。我们遍历所有可能的 `i`，并记录下最大的总价值。
### 复杂度分析
  * **时间复杂度**: $O(N\\log N)$。其中 $N$ 是物品总数。排序需要 $O(N\\log N)$，计算前缀和需要 $O(N)$。主循环最多执行 $N$ 次，每次循环内部的二分查找耗时 $O(\\log N)$。因此，总的时间复杂度由排序和主循环决定，即 $O(N\log N + N_{twos} \log N_{ones})$，最坏情况下为 $O(N\\log N)$。这比传统背包问题的 $O(N \cdot W)$ 复杂度要好得多，尤其是在背包容量 `W` 很大的情况下。
  * **空间复杂度**: $O(N)$。主要用于存储分组后的物品重量和前缀和数组。
# 子集背包
只判断能不能恰好凑出目标价值, 用`bool`数组
[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)
```go
func canPartition(nums []int) bool {
	n := len(nums)
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 != 0 {
		return false
	}
	target := sum / 2
	dp := make([][]bool, n+1)
	for i := range dp {
		dp[i] = make([]bool, target+1)
		dp[i][0] = true
	}
	for i := 1; i <= n; i++ {
		for j := 1; j <= target; j++ {
			dp[i][j] = dp[i-1][j]
			if j >= nums[i-1] {
				dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]]
			}
		}
	}
	return dp[n][target]
}

```
# 完全背包
[【模板】完全背包_牛客题霸_牛客网](https://www.nowcoder.com/practice/237ae40ea1e84d8980c1d5666d1c53bc?tpId=308&tqId=2032575&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
因为可以重复选物品, 所以`dp`状态转移时可以包含当前物品:
`dp[i][j] = max(dp[i-1][j], dp[i][pre] + w[i-1])`
其他都一样
```go
func main() {
  var n, V int
  fmt.Scan(&n, &V)
  v, w := make([]int, n), make([]int, n)
  for i := range v {
    fmt.Scan(&v[i], &w[i])
  }
  dp := make([][]int, n+1)
  for i := range dp {
    dp[i] = make([]int, V+1)
  }
  for i := 1; i <= n; i++ {
		for j := 0; j <= V; j++ { 
      dp[i][j] = dp[i-1][j]
      pre := j - v[i-1]
      if pre >= 0 {
        dp[i][j] = max(dp[i][j], dp[i][pre] + w[i-1])
      }
    }
  }
  fmt.Println(dp[n][V])
  
  for i := range dp {
    dp[i] = make([]int, V+1)
    for j := range dp[i] {
      dp[i][j] = -1
    }
  }
  dp[0][0] = 0
  for i := 1; i <= n; i++ {
    for j := 0; j <= V; j++ {
      dp[i][j] = dp[i-1][j]
      pre := j - v[i-1]
      if pre >= 0 && dp[i][pre] != -1 {
        dp[i][j] = max(dp[i][j], dp[i][pre] + w[i-1])
      }
    }
  }
  dp[n][V] = max(dp[n][V], 0)
  fmt.Println(dp[n][V])
}
```
物品的数量无限, 求出能凑出目标价值的 **组合数**:
转移方程不是取最大值, 而是相加
[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)
```go
func change(amount int, coins []int) int {
	n := len(coins)
	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, amount+1)
		dp[i][0] = 1
	}
	for i := 1; i <= n; i++ {
		for j := 1; j <= amount; j++ {
			dp[i][j] = dp[i-1][j]
			if j-coins[i-1] >= 0 {
				dp[i][j] += dp[i][j-coins[i-1]]
			}
		}
	}
	return dp[n][amount]
}


```
# 多重背包
- 问题描述:与0-1背包类似,但第i件物品有c[i]件可供选择.
- 核心思想:
	- **朴素解法**(转化为0-1背包): 将第i件物品看作c[i]件完全相同的0-1物品,然后用0-1背包的方法求解.如果c[i]很大,这种方法效率很低.
	- **二进制优化**: 这是核心优化.我们可以将c[i]件物品打包成log(c[i])组新的"0-1物品".例如,如果有13件物品,我们可以将其打包成数量为1,2,4,6(6是余数)的四组.这四组可以组合出1到13之间的任意数量.这样,多重背包问题就高效地转化为了0-1背包问题.
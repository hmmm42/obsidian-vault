#hot100 
# $O(N^2)$解法
[最长上升子序列(一)\_牛客题霸_牛客网](https://www.nowcoder.com/practice/5f65ccbb025240bd8458eb6479c2612e?tpId=308&tqId=2357994&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
```go
func main() {
  var n int
  fmt.Scan(&n)
  a, dp := make([]int, n), make([]int, n)
  for i := range a {
    fmt.Scan(&a[i])
    dp[i] = 1
  }
  max := func(x, y int) int {return int(math.Max(float64(x), (float64(y))))}
  res := 1
  for i, cur := range a {
    for j := 0; j < i; j++ {
      if a[j] < cur {
        dp[i] = max(dp[i], dp[j]+1)
      }
    }
    res = max(res, dp[i])
  }
  fmt.Print(res)
}
```
# $O(N\log N)$解法

只能把点数小的牌压到点数==大于等于==它的牌上
遇到多个可选择堆的时候要==放到最左边的堆==, 保证牌堆顶的牌有序
```go
func lengthOfLIS(nums []int) int {
    top := make([]int, len(nums))
    // 牌堆数初始化为 0
    var piles int
    for i := 0; i < len(nums); i++ {
        // 要处理的扑克牌
        poker := nums[i]

        // ***** 搜索左侧边界的二分查找 *****
        var left, right int = 0, piles
        for left < right {
            mid := (left + right) / 2
            if top[mid] > poker {
                right = mid
            } else if top[mid] < poker {
                left = mid + 1
            } else {
                right = mid
            }
        }
        
        // 没找到合适的牌堆，新建一堆
        if left == piles {
            piles++
        }
        // 把这张牌放到牌堆顶
        top[left] = poker
    }
    // 牌堆数就是 LIS 长度
    return piles
}
```
库函数ver
```go
  top := []int{a[0]}
  for i := 1; i < n; i++ {
    num := a[i]
    idx := sort.Search(len(top), func(i int) bool{
      return top[i] >= num
    })
    if idx == len(top) {
      top = append(top, num)
    } else {
      top[idx] = num
    }
  }
  fmt.Print(len(top))
```
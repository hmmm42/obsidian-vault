[842. 将数组拆分成斐波那契序列 - 力扣（LeetCode）](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/description/)
回溯, 注意两个特殊判断:
- `math.MaxInt32`
- 对于0, 要么只能在前1, 2位, 要么前面的全部为0, 否则直接退出
```go
func splitIntoFibonacci(num string) (res []int) {
	n := len(num)
	var track []int
	var backtrack func(idx int)
	backtrack = func(idx int) {
		if res != nil {
			return
		}
		if idx == n {
			if len(track) >= 3 {
				res = slices.Clone(track)
			}
			return
		}
		if num[idx] == '0' {
			if len(track) <= 1 || track[len(track)-1] == 0 && track[len(track)-2] == 0 {
				track = append(track, 0)
				backtrack(idx + 1)
				track = track[:len(track)-1]
			}
			return
		}
		cur := 0
		for i := idx; i < n; i++ {
			cur = cur*10 + int(num[i]-'0')
			if cur > math.MaxInt32 {
				return
			}
			if len(track) >= 2 && cur != track[len(track)-1]+track[len(track)-2] {
				continue
			}
			track = append(track, cur)
			backtrack(i + 1)
			track = track[:len(track)-1]
		}
		
	}
	backtrack(0)
	return
}

```

## 简化版本
from: 字节面经
好的, 这是一个非常经典的 **回溯 (Backtracking)** 搜索问题. 问题的核心是我们要尝试对字符串进行所有"可能"的分割, 但"所有可能"的数量太多, 我们需要一边分割一边验证, 一旦发现当前的路走不通, 就立刻回头(回溯), 尝试别的路.

由于斐波那契数列的特性 (第三个数由前两个数唯一确定), 我们的搜索范围可以被大大减小.

### 核心思路

整个算法的关键在于: **只要确定了数列的前两个数 (`num1` 和 `num2`), 整个斐波那契数列的后续项就都是唯一确定的.**

所以, 我们的策略是:

1.  **尝试确定第一个数 `num1`:** 它可以是 `s[0]`, `s[0...1]`, `s[0...2]`...
2.  **尝试确定第二个数 `num2`:** 紧接着 `num1`, 它可以是 `s[len(num1)...]`...
3.  **验证后续数列:** 一旦 `num1` 和 `num2` 确定, 我们就计算 `num3 = num1 + num2`, 然后看字符串剩下的部分是否以 `num3` 的字符串形式开头. 如果是, 就继续验证 `num4 = num2 + num3`, 如此循环, 直到整个字符串被完美分割.
4.  如果验证失败, 就回溯, 尝试 `num1` 或 `num2` 的其他可能性.

### 算法实现: 深度优先搜索 (DFS) + 回溯

我们可以用一个递归函数来实现这个搜索过程, 这就是回溯.

我们设计一个函数 `dfs(index, sequence)`:

  * `index`: 表示我们当前要从字符串 `s` 的哪个索引开始, 来构建**下一个**数字.
  * `sequence`: 一个列表, 保存了我们目前已经成功找到的斐波那契数.

**递归逻辑如下:**

1.  **递归出口 (Base Case):**

      * 如果 `index` 已经到达了字符串的末尾 (`index == len(s)`), 说明我们成功地用完了整个字符串.
      * 此时, 只要我们找到的数字个数大于等于3 (`len(sequence) >= 3`), 就说明找到了一个合法的斐波那契分割. 函数返回 `true`.

2.  **递归“前进” (循环与剪枝):**

      * 我们从 `index` 位置开始, 尝试构建下一个数字. 这个数字可以由 `s[index...i]` 构成, 其中 `i` 从 `index` 遍历到 `len(s)-1`.
      * 在循环的每一步, 我们都要进行 **"剪枝" (Pruning)**, 提前淘汰掉不可能是正确答案的路径, 这是回溯算法效率的关键.

    **重要的剪枝条件:**
    a.  **处理前导零:** 如果当前截取的子串 `s[index...i]` 长度大于1, 且第一位是 `'0'` (例如 "01", "05"), 那么它是一个非法的数字, 我们应该立刻停止从 `index` 开始的这次尝试 (直接 `break` 循环).
    b.  **处理整数溢出:** 题目通常要求数字不能超过32位整数的最大值. 在解析出的数字大于 `math.MaxInt32` 时, 也应该停止.
    c.  **检查是否符合斐波那契规则:**
    \* 如果 `sequence` 里的数字少于2个, 说明我们还在找头两个数, 任何合法的数字都可以先加进去.
    \* 如果 `sequence` 里已经有两个或更多数字, 我们就要严格遵守斐波那契规则. 计算期望的下一个数 `expectedSum = sequence[n-2] + sequence[n-1]`.
    \* 如果当前我们构建的数 `currentNum` **大于** `expectedSum`, 说明再往后截取只会让数字更大, 不可能相等了. 这条路也走不通, 可以提前 `break` 循环.
    \* 如果 `currentNum` **小于** `expectedSum`, 说明数字还不够大, 我们需要继续循环, 让子串更长一点 (即 `i++`).
    \* 如果 `currentNum` **正好等于** `expectedSum`, 太好了\! 我们找到了一个匹配项.

3.  **递归调用:**

      * 当找到一个匹配的 `currentNum` (无论是头两个数之一, 还是后续的斐波那契数), 我们就把它加入 `sequence`, 然后从新的位置 `i+1` 继续向后搜索: `dfs(i + 1, newSequence)`.
      * 如果这个递归调用返回了 `true`, 说明它最终找到了一个完整的解, 我们也立刻返回 `true`, 将这个好消息层层传递上去.

4.  **回溯:**

      * 如果 `dfs` 调用返回了 `false`, 或者 `for` 循环正常结束都没有找到任何匹配, 说明从当前 `index` 和 `sequence` 状态出发的所有路径都是死路. 函数返回 `false`, 上一层递归就会去尝试其他的可能.

### Go 语言代码示例

```go
import "math"

func splitIntoFibonacci(s string) bool {
    n := len(s)
    var sequence []int
    
    // dfs 函数定义
    var dfs func(index int) bool
    dfs = func(index int) bool {
        // 递归出口: 成功分割完整个字符串
        if index == n {
            return len(sequence) >= 3
        }
        
        // 尝试从 index 开始构建下一个数
        var currentNum int64 = 0
        for i := index; i < n; i++ {
            // 处理前导零: 如果当前数字是 '0' 且不是第一位, 那么是非法的
            if s[index] == '0' && i > index {
                break
            }
            
            // 构建数字
            currentNum = currentNum*10 + int64(s[i]-'0')
            
            // 剪枝: 处理整数溢出
            if currentNum > math.MaxInt32 {
                break
            }
            
            m := len(sequence)
            // 如果是前两个数, 或者符合斐波那契规则
            if m < 2 || int64(sequence[m-2]+sequence[m-1]) == currentNum {
                // 将当前数字加入序列
                sequence = append(sequence, int(currentNum))
                
                // 继续向后搜索
                if dfs(i + 1) {
                    return true
                }
                
                // 回溯: 如果后续搜索失败, 将刚才加入的数字移除
                sequence = sequence[:len(sequence)-1]
            } else if m >= 2 && int64(sequence[m-2]+sequence[m-1]) < currentNum {
                // 剪枝: 如果当前数字已经比期望的大, 后续不可能了
                break
            }
        }
        
        return false
    }
    
    return dfs(0)
}
```
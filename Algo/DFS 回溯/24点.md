[679. 24 点游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/24-game/description/)
只有4个数, 任意选
用一个切片来存下一步需要运算的数(还未运算的), 顺序不重要
每一次从切片中任取两个数, 进行四则运算
注意浮点数, `1e-6`的误差
```go
func judgePoint24(cards []int) bool {
	var backtrack func(list []float64) bool
	backtrack = func(list []float64) bool {
		n := len(list)
		if n == 0 {
			return false
		}
		if n == 1 {
			return math.Abs(list[0]-24) <= 1e-6
		}
		for i := range n - 1 {
			for j := i + 1; j < n; j++ {
				var newList []float64
				for k := range list {
					if k != i && k != j {
						newList = append(newList, list[k])
					}
				}
				
				res := list[i] + list[j]
				newList = append(newList, res)
				if backtrack(newList) {
					return true
				}
				newList = newList[:len(newList)-1]
				
				res = list[i] * list[j]
				newList = append(newList, res)
				if backtrack(newList) {
					return true
				}
				newList = newList[:len(newList)-1]
				
				res = list[i] - list[j]
				newList = append(newList, res)
				if backtrack(newList) {
					return true
				}
				newList = newList[:len(newList)-1]
				res = list[j] - list[i]
				newList = append(newList, res)
				if backtrack(newList) {
					return true
				}
				newList = newList[:len(newList)-1]
				
				if math.Abs(list[j]) > 1e-6 {
					res = list[i] / list[j]
					newList = append(newList, res)
					if backtrack(newList) {
						return true
					}
					newList = newList[:len(newList)-1]
				}
				if math.Abs(list[i]) > 1e-6 {
					res = list[j] / list[i]
					newList = append(newList, res)
					if backtrack(newList) {
						return true
					}
					newList = newList[:len(newList)-1]
				}
				
			}
		}
		return false
	}
	var f []float64
	for _, c := range cards {
		f = append(f, float64(c))
	}
	return backtrack(f)
}
```
[282. 给表达式添加运算符 - 力扣（LeetCode）](https://leetcode.cn/problems/expression-add-operators/solutions/1048321/gei-biao-da-shi-tian-jia-yun-suan-fu-by-2o1s7/)
相比于24点, 需要注意顺序
需要注意乘法, 要保留上一步的连乘的运算结果
`backtrack(nxt, sum-pre+pre*cur, cur*pre)`
```go
func addOperators(num string, target int) (res []string) {
	n := len(num)
	var track []string
	var backtrack func(i, sum, pre int)
	backtrack = func(i, sum, pre int) {
		if i == n {
			if sum == target {
				res = append(res, strings.Join(track, ""))
			}
			return
		}
		for nxt := i + 1; nxt <= n; nxt++ {
			if num[i] == '0' && nxt > i+1 {
				return
			}
			str := num[i:nxt]
			cur, _ := strconv.Atoi(str)
			if i == 0 {
				track = append(track, str)
				backtrack(nxt, cur, cur)
				track = track[:len(track)-1]
				continue
			}
			// +
			track = append(track, "+", str)
			backtrack(nxt, sum+cur, cur)
			track = track[:len(track)-2]
			// *
			track = append(track, "*", str)
			backtrack(nxt, sum-pre+pre*cur, cur*pre)
			track = track[:len(track)-2]
			// -
			track = append(track, "-", str)
			backtrack(nxt, sum-cur, -cur)
			track = track[:len(track)-2]
		}
	}
	backtrack(0, 0, 0)
	return
}

```
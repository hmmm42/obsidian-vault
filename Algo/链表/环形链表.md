[141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/description/)
```go
func hasCycle(head *ListNode) bool {
	if head == nil {
		return false
	}
	fast, slow := head, head
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
		if fast == slow {
			return true
		}
	}
	return false
}
```

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)
快慢指针. 第一次相遇后, 将其中一个指针 (如 `slow`) 指向链表头 `head`, 另一个指针 `fast` 保持在相遇点. 然后两个指针都以每次一步的速度前进, 它们再次相遇的地方就是环的入口.
```go
func detectCycle(head *ListNode) *ListNode {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
        }
    }
    // 上面的代码类似 hasCycle 函数
    if fast == nil || fast.Next == nil {
        // fast 遇到空指针说明没有环
        return nil
    }
    // 重新指向头结点
    slow = head
    // 快慢指针同步前进，相交点就是环起点
    for slow != fast {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```
[287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/?envType=study-plan-v2&envId=top-100-liked)
形式是数组, 但是环形链表的算法
==注意初始化要到位==
```go
func findDuplicate(nums []int) int {
  slow, fast := nums[0], nums[nums[0]]
  for fast != slow {
    slow = nums[slow]
    fast = nums[nums[fast]]
  }
  p := 0
  for slow != p {
    p = nums[p]
    slow = nums[slow]
  }
  return p
}
```
### 数组与哈希表 (Arrays & Hash Tables)
-  **两数之和 (Two Sum)**
    * **思路提要:** 利用哈希表存储已经遍历过的数字及其索引. 对于每个新数字, 检查 `target - current_number` 是否在哈希表中.
-  **字母异位词分组 (Group Anagrams)**
    * **思路提要:** 统计26个字母出现次数作为 key, 原始字符串列表作为 value, 存入哈希表.
-  **最长连续序列 (Longest Consecutive Sequence)**
    * **思路提要:** 使用哈希集合 (Set) 存储所有数字. 遍历数组, 如果一个数 `x` 的前一个数 `x-1` 不在集合中, 则以 `x` 为起点开始向后计数, 更新最长长度. ==只遍历开头==
-  **移动零 (Move Zeroes)**
    * **思路提要:** 使用双指针. 一个指针 `slow` 指向下一个非零元素应该放置的位置, 另一个指针 `fast` 遍历数组. 如果 `fast` 遇到非零元素, 就将其值赋给 `slow` 指针所在位置, 然后 `slow` 后移. 遍历结束后, `slow` 之后的位置全部补零.
-  **盛最多水的容器 (Container With Most Water)**
    * **思路提要:** 使用双指针, 分别指向数组的头部和尾部. 每次计算当前的面积, 然后将**指向较短木板的那个指针向中间移动**, 以寻找可能更大的面积.
-  **三数之和 (3Sum)**
    * **思路提要:** 先对数组排序. 遍历数组, 固定第一个数 `nums[i]`. 然后在 `i` 之后的部分使用双指针 (left, right) 寻找 `nums[left] + nums[right] == -nums[i]`. 注意处理重复解.
-  **除自身以外数组的乘积 (Product of Array Except Self)**
    * **思路提要:** 创建一个结果数组. 进行两次遍历: 第一次遍历计算每个位置左侧所有元素的乘积; 第二次遍历计算右侧所有元素的乘积, 并将其与第一次的结果相乘. 空间复杂度可优化到 O(1) (不包括结果数组).
-  **轮转数组 (Rotate Array)**
    * **思路提要:** 三次翻转法. 先整体翻转数组, 然后翻转前 `k % n` 个元素, 最后翻转剩下的元素.
-  **寻找两个正序数组的中位数 (Median of Two Sorted Arrays)**
    * **思路提要:** 这是一个经典的二分查找问题. 核心是在较短的数组上进行二分, 找到一个分割点, 使得分割点左侧的所有元素个数为总数的一半, 并且满足 `A[i-1] <= B[j]` 和 `B[j-1] <= A[i]`.
### 滑动窗口 (Sliding Window)
- **无重复字符的最长子串 (Longest Substring Without Repeating Characters)**
    * **思路提要:** 滑动窗口 + 哈希表. 用哈希表记录窗口内每个字符的最新位置. 右指针向右移动, 如果遇到重复字符, 将左指针更新到该重复字符上次出现位置的下一位.
- **找到字符串中所有字母异位词 (Find All Anagrams in a String)**
    * **思路提要:** 滑动窗口 + 数组/哈希表. 维护一个固定大小为 `p.length()` 的窗口. 用一个数组记录窗口内各字符的频率, 与 `p` 的字符频率进行比较.
- **最小覆盖子串 (Minimum Window Substring)**
    * **思路提要:** 滑动窗口 + 哈希表. 用一个哈希表 `need` 记录目标字符串 `t` 中各字符的数量. 另一个哈希表 `window` 记录窗口内字符的数量. 右指针扩张窗口, 当 `window` 中的字符满足 `need` 的要求时, 开始收缩左指针, 直到不满足为止, 此过程中更新最小子串.
- **最长重复子数组 (Maximum Length of Repeated Subarray)**
    * **思路提要:** 动态规划. `dp[i][j]` 表示以 `A[i-1]` 和 `B[j-1]` 结尾的最长公共后缀的长度. 状态转移方程: 如果 `A[i-1] == B[j-1]`, 则 `dp[i][j] = dp[i-1][j-1] + 1`.
    * 最长公共子串(LCS): 结尾 + 长度, 可以得到子串
### 动态规划 (Dynamic Programming)
- **爬楼梯 (Climbing Stairs)**
    * **思路提要:** 斐波那契数列. `dp[i]` 表示爬到第 `i` 阶的方法数, `dp[i] = dp[i-1] + dp[i-2]`.
- **[[打家劫舍]] (House Robber)**
    * **思路提要:** `dp[i]` 表示偷到第 `i` 家时能获得的最大金额. 状态转移方程: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`.
- **[[最长递增子序列]] (Longest Increasing Subsequence)**
    * **思路提要:** `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度. 遍历 `j` 从 `0` 到 `i-1`, 如果 `nums[i] > nums[j]`, 则 `dp[i] = max(dp[i], dp[j] + 1)`, 复杂度$O(N^2)$. (更优解法是贪心 + 二分查找, 时间复杂度 O(n log n)). 
- **零钱兑换 (Coin Change)**
    * **思路提要:** 完全背包问题. `dp[i]` 表示凑成金额 `i` 所需的最少硬币数. 状态转移方程: `dp[i] = min(dp[i], dp[i - coin] + 1)`.
- **单词拆分 (Word Break)**
    * **思路提要:** `dp[i]` 表示字符串 `s` 的前 `i` 个字符是否可以被拆分. 复杂度$O(N^2)$. 状态转移方程: `dp[i] = dp[j] && s[j:i] in wordDict`.
- [[最大子数组 子矩阵和|最大子数组和]] (Maximum Subarray)**
    * **思路提要 (DP):** `dp[i]` 表示以 `nums[i]` 结尾的连续子数组的最大和. 状态转移方程: `dp[i] = nums[i] + max(dp[i-1], 0)`. 如果前一个子数组的和是负数, 还不如从当前元素重新开始.
    * **思路提要 (贪心):** 维护一个 `current_sum`. 遍历数组, 不断累加. 如果 `current_sum` 变为负数, 就将其重置为0, 因为负数对后续的和只有负贡献. 在此过程中记录 `current_sum` 出现过的最大值. `cur = max(cur + num, num)`
- **不同路径 (Unique Paths)**
    * **思路提要:** `dp[i][j]` 表示从起点到 `(i, j)` 的路径数. 状态转移方程: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.
- **最小路径和 (Minimum Path Sum)**
    * **思路提要 (DP):** 与 "不同路径" 类似. `dp[i][j]` 表示从左上角到 `(i, j)` 的最小路径和. 状态转移方程: `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`. 可以用原地DP优化空间.
- **编辑距离 (Edit Distance)**
    * **思路提要 (DP):** 经典的二维DP. `dp[i][j]` 表示 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需的最少操作数.
    * **状态转移:**
        * 如果 `word1[i-1] == word2[j-1]`, 则 `dp[i][j] = dp[i-1][j-1]` (无需操作).
        * 否则, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`, 分别对应删除, 插入, 替换操作.
- **接雨水 (Trapping Rain Water)**
    * **思路提要 (双指针):** 用 `left` 和 `right` 两个指针从两端向中间移动. 维护 `left_max` 和 `right_max`. 如果 `left_max < right_max`, 说明瓶颈在左边, 结算 `left` 指针位置的雨水 (`left_max - height[left]`), 并将 `left` 右移. 反之亦然.
    * **思路提要 (单调栈):** 维护一个单调递减栈 (存下标). 当遇到一个比栈顶高的柱子时, 说明可以形成凹槽. 栈顶出栈作为凹槽底部, 新的栈顶是左墙, 当前柱子是右墙. 计算并累加雨水.	
- **最长[[有效括号]] (Longest Valid Parentheses)**
    * **思路提要 (DP):** `dp[i]` 表示以 `s[i]` 结尾的最长有效括号的长度. 如果 `s[i]` 是 `)`, 并且 `s[i-1]` 是 `(`, 则 `dp[i] = dp[i-2] + 2`. 如果 `s[i]` 是 `)` 且 `s[i-1]` 也是 `)`, 则看 `s[i - dp[i-1] - 1]` 是否为 `(`, 如果是, 则可以连接起来.
    * **思路提要 (栈):** 用栈来检查有效性. 栈底放==一个哨兵 `-1`==. 遇到 `(` 就压入下标, 遇到 `)` 就弹出栈顶. 弹出后, 用当前下标减去新的栈顶下标, 就是当前有效括号的长度. 
- **跳跃游戏 (Jump Game)**
    * **思路提要 (贪心):** 维护一个变量 `farthest`, 表示当前能到达的最远距离. 遍历除了最后一个元素, 在 `i <= farthest` 的前提下, 不断更新 `farthest = max(farthest, i + nums[i])`. 如果 `farthest` 能覆盖到数组最后一个位置, 就返回 `true`.
- **跳跃游戏 II (Jump Game II)**
    * **思路提要 (贪心):** 维护当前覆盖范围的右边界 `end` 和在当前范围内能跳到的最远距离 `farthest`. 遍历数组, 当 `i` 到达 `end` 时, 说明必须进行一次跳跃, 步数加一, 并将 `end` 更新为 `farthest`.	
- **[[打家劫舍]] II (House Robber II)**
    * **思路提要:** 环形数组的DP. "首尾不能相连" 意味着问题分解为两个子问题: 1. 在不偷最后一个房子的前提下 (`nums[0...n-2]`) 能偷到的最大金额. 2. 在不偷第一个房子的前提下 (`nums[1...n-1]`) 能偷到的最大金额. 两者取最大值.
- **[[正则表达式匹配]] (Regular Expression Matching)**
    * **思路提要 (DP):** `dp[i][j]` 表示 `s` 的前 `i` 个字符能否被 `p` 的前 `j` 个字符匹配. 核心是处理 `*`: 当 `p[j-1]` 是 `*` 时, 它可以匹配零次 (依赖 `dp[i][j-2]`) 或多次 (依赖 `dp[i-1][j]`, 且 `s[i-1]` 要能被 `p[j-2]` 匹配).	
### 链表 (Linked List)
- **[[反转链表]] (Reverse Linked List)**
    * **思路提要:** 迭代法: 用三个指针 `prev`, `curr`, `next` 来迭代反转. `prev` 初始为 null, `curr` 初始为 head. ==串成一条, 核心操作是`cur.Next = pre`==
    * **思路提要 (递归):** 递归到链表尾部, 然后逐层返回时改变指针方向.
- **[[合并k条有序链表|合并两个有序链表]] (Merge Two Sorted Lists)**
    * **思路提要:** 迭代法: 创建一个虚拟头节点 (dummy head), 用一个指针比较两个链表的当前节点, 将较小的节点链接到结果链表上.
    * **思路提要 (递归):** 比较两个头节点, 值较小的节点作为新头节点, 其 `next` 指向剩下两个链表的合并结果.
- **[[环形链表]] (Linked List Cycle)**
    * **思路提要:** 快慢指针. 快指针一次走两步, 慢指针一次走一步. 如果链表有环, 它们终将相遇.
- **[[相交链表]] (Intersection of Two Linked Lists)**
    * **思路提要:** 双指针法. 两个指针 `pA` 和 `pB` 分别从两个链表的头出发. 当一个指针到达链表末尾时, 让他从另一个链表的头部重新开始. 如果有交点, 它们会在交点处相遇; 如果没有, 它们会同时到达末尾 (都变为 null).
- **[[环形链表]] II (Linked List Cycle II)**
    * **思路提要:** 快慢指针. 第一次相遇后, 将其中一个指针 (如 `slow`) 指向链表头 `head`, 另一个指针 `fast` 保持在相遇点. 然后两个指针都以每次一步的速度前进, 它们再次相遇的地方就是环的入口.
- **排序链表 (Sort List)**
    * **思路提要:** 归并排序 (自顶向下). 使用==快慢指针==找到链表中点, 将链表断开. ==递归==地对左右两半排序, 然后合并两个有序链表.
- **[[LRU]] 缓存 (LRU Cache)**
    * **思路提要:** 哈希表 + 双向链表. 哈希表 `(key -> Node)` 实现 O(1) 查找. 双向链表维护节点的访问顺序, 最近访问的节点移动到链表头部, 当缓存满时, 移除链表尾部节点.
- **两数相加 (Add Two Numbers)**
    * **思路提要:** 模拟小学竖式加法. 同时遍历两个链表, 将对应节点的值和进位 `carry` 相加, 创建新节点. 注意处理链表长度不等和最后可能存在的进位.
- [[删除链表的倒数第N个结点]] (Remove Nth Node From End of List)**
    * **思路提要:** 快慢指针 + 虚拟头节点. `fast` 指针先向前移动 `n+1` 步, 然后 `fast` 和 `slow` 指针一起移动. 当 `fast` 到达末尾 `null` 时, `slow` 正好指向要删除节点的前一个节点.
- [[反转链表#K个一组反转链表|K个一组反转链表]] (Reverse Nodes in k-Group)**
    * **思路提要 (递归):** 这是反转链表的终极版本. 先检查剩余节点是否足够 `k` 个. 如果足够, 反转这 `k` 个节点, 然后将第 `k` 个节点的 `next` 指向对剩下链表进行递归调用的结果. ==整个题目的函数就是递归函数==
- **回文链表 (Palindrome Linked List)**
    * **思路提要:** 快慢指针找中点 + 反转后半部分 + 比较. 用快慢指针找到链表的中点, 将后半部分的链表反转, 然后从头和后半部分的头开始逐一比较. 最后记得恢复链表 (可选).
### 二叉树 (Binary Tree)
- **二叉树的中序遍历 (Binary Tree Inorder Traversal)**
    * **思路提要 (递归):** 按照 "左 -> 根 -> 右" 的顺序递归遍历.
    * **思路提要 (迭代):** 使用一个栈. 先一路将左子节点压入栈, 直到最左. 然后出栈访问, 再转向右子树.
- **二叉树的最大深度 (Maximum Depth of Binary Tree)**
    * **思路提要 (递归):** 树的最大深度等于 `max(左子树深度, 右子树深度) + 1`.
    * **思路提要 (层序遍历/BFS):** 使用队列进行层序遍历, 记录遍历的层数.
- **翻转二叉树 (Invert Binary Tree)**
    * **思路提要 (递归):** 递归地交换每个节点的左右子节点.
- **对称二叉树 (Symmetric Tree)**
    * **思路提要 (递归):** 设计一个辅助函数 `isMirror(t1, t2)`, 判断两棵树是否镜像对称. 递归的条件是 `t1.val == t2.val`, 并且 `t1.left` 与 `t2.right` 镜像对称, `t1.right` 与 `t2.left` 镜像对称.
- **二叉树的直径 (Diameter of Binary Tree)**
    * **思路提要 (后序遍历):** 对每个节点, 其直径等于 "左子树深度 + 右子树深度". 最终结果是所有节点直径的最大值. 在求深度的同时计算并更新全局的最大直径.
- **二叉树的层序遍历 (Binary Tree Level Order Traversal)**
    * **思路提要 (BFS):** 使用队列. 每一轮循环处理队列中当前层的所有节点, 将它们的值存入一个临时列表, 并将它们的子节点加入队列.
- **将有序数组转换为二叉搜索树 (Convert Sorted Array to Binary Search Tree)**
    * **思路提要 (递归):** 典型的分治法. 每次取数组的中间元素作为根节点, 数组的左半部分构建左子树, 右半部分构建右子树.
- **验证二叉搜索树 (Validate Binary Search Tree)**
    * **思路提要 (递归):** 递归函数需要维护一个上界和下界 (`min`, `max`). 对于每个节点, 它的值必须在 `(min, max)` 区间内. 递归到左子树时, 更新上界为当前节点值; 递归到右子树时, 更新下界为当前节点值.
    * **思路提要 (中序遍历):** 二叉搜索树的中序遍历结果是一个严格递增的序列.
- **二叉搜索树中第K小的元素 (Kth Smallest Element in a BST)**
    * **思路提要 (中序遍历):** 对二叉搜索树进行中序遍历, 得到的序列是递增的, 第 `k` 个元素就是答案.
- **二叉树的最近公共祖先 (Lowest Common Ancestor of a Binary Tree)**
    * **思路提要 (递归):** 后序遍历思想. 如果当前节点是 `p` 或 `q` 之一, 返回当前节点. 否则, 递归查找左右子树. 如果左右子树的返回结果都不为空, 说明 `p` 和 `q` 分居两侧, 当前节点就是LCA. 如果只有一个不为空, 返回那个不为空的结果. 一旦找到, 后面的结果都要剪枝.
- **从前序与中序遍历序列构造二叉树 (Construct Binary Tree from Preorder and Inorder Traversal)**
    * **思路提要 (递归/分治):** [[构造问题]], 前序遍历的第一个元素是根节点. 在中序遍历中找到这个根节点, 其左边的部分是左子树的中序遍历, 右边是右子树的中序遍历. 根据中序遍历中左子树的长度, 可以在前序遍历中确定左子树的前序遍历范围, 然后递归构建.
- **路径总和 III (Path Sum III)**
    * **思路提要 (DFS + 前缀和):** 使用一个哈希表记录从根到当前节点路径上, 各种前缀和出现的次数. 在DFS遍历到当前节点时, 计算根到当前节点的前缀和 `currSum`, 然后在哈希表中查找 `currSum - targetSum` 的数量, 这就是以当前节点为终点的满足条件的路径数.
- **二叉树的右视图 (Binary Tree Right Side View)**
    * **思路提要 (BFS):** 层序遍历. 在每一层遍历时, 将该层的最后一个节点的值加入结果列表即可.
    * **DFS**: 前序遍历, 附加层数参数, 先右后左, 第一次到某一层时记录
- **二叉树展开为链表 (Flatten Binary Tree to Linked List)**
    * **思路提要 (后序遍历/递归):** 递归地将左右子树拉平. 然后将根节点的右指针指向拉平后的左子树, 再找到拉平后左子树的末端, 将其右指针指向拉平后的右子树, 最后将根节点的左指针置空.
- **路径总和 (Path Sum)**
    * **思路提要 (DFS):** 深度优先搜索. 递归函数传入当前节点和 `targetSum`. 每次深入一层, `targetSum` 减去当前节点值. 当遇到叶子节点时, 判断 `targetSum` 是否为0.
- **合并二叉树 (Merge Two Binary Trees)**
    * **思路提要 (递归):** 同时遍历两棵树. 如果两个节点都存在, 新节点的值为两者之和. 如果只有一个存在, 新节点就等于那个存在的节点. 递归地合并左右子树.
* **二叉树的最大路径和**
	* **后序遍历**: 遍历求以当前节点为开始的单边路径最大值, 同时更新外层最终结果最大值, 返回当前节点值 + 左右路径中的最大值.
### 堆 (Heap / Priority Queue)
- **数据流的中位数 (Find Median from Data Stream)**
    * **思路提要:** 维护两个堆: 一个最大堆 (存储较小的一半数字) 和一个最小堆 (存储较大的一半数字). 始终保持两个堆的大小差距不超过1. 中位数可以直接从两个堆顶得到.
- **前 K 个高频元素 (Top K Frequent Elements)**
    * **思路提要:** 1. 用哈希表统计每个元素的频率. 2. 使用一个大小为 `k` 的最小堆, 遍历频率哈希表, 将元素按频率放入堆中. 如果堆的大小超过 `k`, 就弹出堆顶 (频率最小的元素).
- **合并K个升序链表 (Merge k Sorted Lists)**
    * **思路提要:** 使用最小堆. 将 `k` 个链表的头节点全部放入最小堆中. 每次从堆中取出最小的节点, 将其加入结果链表, 然后将其 `next` 节点 (如果存在) 再放入堆中.
### 回溯 (Backtracking)
- **全排列 (Permutations)**
    * **思路提要:** 经典回溯. 使用一个 `visited` 数组标记数字是否已被使用. 每一层递归选择一个未被使用的数字加入当前排列, 然后进入下一层.
- **子集 (Subsets)**
    * **思路提要:** 经典回溯. 每一层递归决定当前元素是 "选" 还是 "不选".
- **组合总和 (Combination Sum)**
    * **思路提要:** 回溯. 与子集问题类似, 但每个数字可以重复使用. 递归时, 下一层可以从当前数字开始选择 (而不是下一个), 以实现重复使用.
- **括号生成 (Generate Parentheses)**
    * **思路提要:** 回溯. 递归时维护当前已使用的左括号和右括号的数量. 放置左括号的条件是 `左括号数 < n`. 放置右括号的条件是 `右括号数 < 左括号数`.
- **电话号码的字母组合 (Letter Combinations of a Phone Number)**
    * **思路提要:** 回溯. 每一层递归处理一位数字, 遍历该数字对应的所有字母, 并将其拼接到当前结果上, 然后进入下一层.
### 图论
- **腐烂的橘子 (Rotting Oranges)**
    * **思路提要 (多源BFS):** 将所有初始的腐烂橘子看作第一层的源点, 全部入队. 然后进行BFS, 每一轮遍历代表一分钟, 直到队列为空. 最后检查是否还有新鲜橘子.
- **岛屿数量 (Number of Islands)**
    * **思路提要 (DFS/BFS):** 遍历整个矩阵. 当遇到一个 '1' 时, 岛屿数量加一, 然后以此为起点进行DFS或BFS, 将所有相连的 '1' 都标记为已访问==淹没== (比如变为 '0' 或其他字符), 以免重复计数.
- **单词搜索 (Word Search)**
    * **思路提要 (DFS + 回溯):** 遍历二维网格中的每个单元格作为起点. 从起点开始进行深度优先搜索, 尝试匹配单词的每个字符. 为了防止路径重复使用同一个单元格, 需要一个 `visited` 矩阵来记录访问状态, 并在回溯时恢复状态.
- **课程表 (Course Schedule)**
    * **思路提要 (拓扑排序):** 这是检测有向图是否有环的典型问题.
        * **BFS (Kahn算法):** 建立邻接表和入度数组. 将所有入度为0的节点入队. 然后不断出队, 每出一个节点, 就将其指向的节点的入度减一. 如果有节点的入度变为0, 就将其入队. 最后看是否所有节点都被访问过.
        * **DFS:** 维护三个状态 (未访问, 访问中, 已访问). DFS遍历时如果遇到 "访问中" 的节点, 说明存在环.
### **栈与队列 (Stack & Queue)**
- **最小栈 (Min Stack)**
    * **思路提要:** 使用两个栈. 一个是主栈, 正常进行 push/pop. 另一个是辅助栈 (或最小栈), 其栈顶始终保存着当前主栈中所有元素的最小值. 当一个新元素 push 时, 如果它小于等于辅助栈顶, 也将其压入辅助栈. pop 时同理.
- **每日温度 (Daily Temperatures)**
    * **思路提要:** 单调栈 (递减). 遍历温度数组, 如果当前温度比栈顶元素 (下标对应的温度) 高, 说明找到了栈顶元素的答案. 不断弹出栈顶并计算天数差, 直到栈顶温度不低于当前温度. 然后将当前温度的下标入栈.
- **滑动窗口最大值 (Sliding Window Maximum)**
    * **思路提要 (单调队列):** 维护一个双端队列, 队头是当前窗口的最大值的下标. 队列中的元素从头到尾严格单调递减. 当窗口滑动时: 1. 从队尾移除所有小于当前元素的下标. 2. 将当前元素下标加入队尾. 3. 从队头移除不在当前窗口范围内的下标. 4. 队头元素就是当前窗口的最大值.
### **字符串 & Trie**
- **最长回文子串 (Longest Palindromic Substring)**
    * **思路提要 (中心扩展法):** 遍历每个字符, 以它为中心 (奇数长度) 或以它和它右边的字符为中心 (偶数长度) 向两边扩展, 寻找最长的回文串.
    * **思路提要 (DP):** `dp[i][j]` 表示 `s[i...j]` 是否是回文串. `dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]`.
- **有效的括号 (Valid Parentheses)**
    * **思路提要 (栈):** 遍历字符串. 遇到左括号 (`(`, `{`, `[`) 就压入栈. 遇到右括号, 就检查栈顶是否是与之匹配的左括号, 如果是则弹出, 否则返回 `false`. 遍历结束后, 栈应为空.
- **解码字符串 (Decode String)**
    * **思路提要 (双栈法):** 一个栈存数字, 一个栈存 `[` 前的字符串. 遇到数字累加, 遇到 `[` 将当前数字和字符串分别压栈. 遇到字母直接拼接. 遇到 `]` 弹出数字 `k` 和字符串 `s`, 将 `s` 重复 `k` 次拼接到上一层字符串后面.
- **实现 Trie (前缀树) (Implement Trie (Prefix Tree))**
    * **思路提要:** 核心是节点设计. 每个Trie节点包含一个指向子节点的指针数组 (大小为26, 对应a-z) 和一个布尔标记 `isEnd`, 表示是否是一个单词的结尾. `insert`, `search`, `startsWith` 操作都是从根节点开始, 顺着字符路径向下遍历.
### **位运算 (Bit Manipulation)**
- **只出现一次的数字 (Single Number)**
    * **思路提要:** 异或 (XOR). 任何数与 0 异或都等于其本身, 任何数与自身异或都等于 0. 将所有数字进行异或操作, 成对的数字会抵消为 0, 最后剩下的就是那个只出现一次的数字.
- **汉明距离 (Hamming Distance)**
    * **思路提要:** 先将两个数进行异或操作, 结果中二进制位为 `1` 的位置就是它们不同的位. 然后统计这个结果中有多少个 `1` (可以使用 `n & (n-1)` 技巧).
### **综合 & 其他**
- **合并区间 (Merge Intervals)**
    * **思路提要:** 先将所有区间按照起始位置排序. 然后遍历排序后的区间, 维护一个 `merged` 列表. 如果当前区间与 `merged` 的最后一个区间有重叠, 就合并它们 (更新 `merged` 最后一个区间的结束位置); 否则, 直接将当前区间加入 `merged`.
- **多数元素 (Majority Element)**
    * **思路提要 (摩尔投票法):** 维护一个候选者 `candidate` 和一个计数器 `count`. 遍历数组, 如果 `count` 为0, 将当前元素设为 `candidate`. 如果当前元素等于 `candidate`, `count` 加一, 否则减一. 最终的 `candidate` 就是多数元素.
- **回文数 (Palindrome Number)**
    * **思路提要:** 反转数字的后半部分, 与前半部分进行比较. 注意处理边界情况, 如负数和末尾是0的数字.
### **二分查找 (Binary Search)**
- **搜索旋转排序数组 (Search in Rotated Sorted Array)**
    * **思路提要:** 变种二分查找. 核心在于判断 `mid` 落在哪个有序的子数组中. 比较 `nums[mid]` 和 `nums[left]` (或 `nums[right]`) 的大小, 确定左半边或右半边是有序的, 然后再判断 `target` 是否在该有序区间内, 以此决定收缩哪部分边界.
- **在排序数组中查找元素的第一个和最后一个位置 (Find First and Last Position of Element in Sorted Array)**
    * **思路提要:** 进行两次二分查找. 一次用来找 `target` 的左边界 (寻找第一个大于等于 `target` 的位置), 另一次用来找右边界 (寻找第一个大于 `target` 的位置, 然后减一).
### **[[买卖股票]] (Stock Problems)**
- **买卖股票的最佳时机 (Best Time to Buy and Sell Stock)**
    * **思路提要 (贪心):** 遍历一次数组. 记录下迄今为止的最低价格 `min_price`, 然后在每一天计算 `current_price - min_price` 作为当前利润, 并更新最大利润.
- **买卖股票的最佳时机 II (Best Time to Buy and Sell Stock II)**
    * **思路提要 (贪心):** 只要第二天的价格比第一天高, 就在第一天买入第二天卖出. 将所有这些正利润累加起来即可. 等价于 `sum(max(0, prices[i] - prices[i-1]))`.
- **买卖股票的最佳时机含冷冻期 (Best Time to Buy and Sell Stock with Cooldown)**
    * **思路提要 (状态机DP):** 第 i 天选择buy的时候，要从 i-2 的状态转移，而不是 i-1
    * `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])`
### **其他经典问题 (Other Classics)**
- **下一个排列 (Next Permutation)**
    * **思路提要:** 从右向左找到第一个 `nums[i] < nums[i+1]` 的数. 再从右向左找到第一个 `nums[j] > nums[i]` 的数. 交换 `nums[i]` 和 `nums[j]`. 最后, 将 `i+1` 到末尾的部分翻转.
- **用Rand7()实现Rand10() (Implement Rand10() Using Rand7())**
    * **思路提要 (拒绝采样):** 目标是构造一个均匀的更大范围的随机数生成器. `(Rand7() - 1) * 7 + Rand7()` 可以均匀生成 `1` 到 `49` 的数. 我们只取 `1` 到 `40` 的部分, 如果生成的数大于 `40`, 就拒绝并重新生成. 最后将结果模 `10` 加 `1` 即可.
- **颜色分类 (Sort Colors)**
    * **思路提要 (三指针):** 使用三个指针: `p0` 指向 `0` 区域的右边界, `p2` 指向 `2` 区域的左边界, `curr` 指向当前遍历的元素.
        * 如果 `nums[curr] == 0`, 与 `p0` 交换, `p0` 和 `curr` 都右移.
        * 如果 `nums[curr] == 2`, 与 `p2` 交换, `p2` 左移 (注意 `curr` 不动, 因为交换过来的数还需要检查).
        * 如果 `nums[curr] == 1`, `curr` 右移.
- **和为 K 的子数组 (Subarray Sum Equals K)**
    * **思路提要 (前缀和 + 哈希表):** 计算从 `0` 到 `i` 的前缀和 `pre_sum`. 如果 `pre_sum - k` 存在于哈希表中, 说明从某个位置到 `i` 的子数组和为 `k`. 哈希表 `(key: pre_sum, value: count)` 记录每个前缀和出现的次数.
### 数组
- **合并两个有序数组 (Merge Sorted Array)**
    * **思路提要:** 双指针 (从后往前). 设置三个指针, 分别指向 `nums1` 的末尾 (`m-1`), `nums2` 的末尾 (`n-1`), 以及 `nums1` 数组的最终末尾 (`m+n-1`). 比较两个数组指针指向的元素, 将较大的一个放入 `nums1` 的最终末尾, 并移动相应指针.
- **寻找重复数 (Find the Duplicate Number)**
    * **思路提要 (快慢指针/环检测):** 将数组看作一个链表 (`index -> nums[index]`). 因为存在重复数, 所以这个 "链表" 必然有环. 使用快慢指针找到相遇点, 然后再用一个指针从头出发, 与相遇点指针同步前进, 再次相遇点即为环的入口 (重复数).
    * **思路提要 (二分查找):** 对值域 `[1, n]` 进行二分. 每次猜一个数 `mid`, 统计数组中小于等于 `mid` 的数的个数 `count`. 如果 `count > mid`, 说明重复数在 `[1, mid]` 区间.
- **数组中的第K个最大元素 (Kth Largest Element in an Array)**
    * **思路提要 (快速选择):** 基于快速排序的 `partition` 思想. 每次 `partition` 后, 比较基准元素的索引和 `n-k`, 从而决定在哪个子数组中继续寻找. 平均时间复杂度 O(n).
    * **思路提要 (最小堆):** 维护一个大小为 `k` 的最小堆. 遍历数组, 如果元素大于堆顶, 则弹出堆顶并推入新元素. 遍历结束后, 堆顶即为第 `k` 大的元素.
### 矩阵
- **螺旋矩阵 (Spiral Matrix)**
    * **思路提要 (模拟法):** 设置四个边界: `top`, `bottom`, `left`, `right`. 按照 "从左到右 -> 从上到下 -> 从右到左 -> 从下到上" 的顺序循环遍历, 每遍历完一条边就收缩对应的边界, 直到边界交叉.
- **最大正方形 (Maximal Square)**
    * **思路提要 (DP):** `dp[i][j]` 表示以 `(i, j)` 为右下角的最大正方形的边长. 如果 `matrix[i-1][j-1] == '1'`, 那么它可以和左边, 上边, 左上方的正方形构成一个更大的正方形. 状态转移方程: `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`.
- **搜索二维矩阵 II (Search a 2D Matrix II)**
    * **思路提要:** 从矩阵的右上角 (或左下角) 开始查找. 如果当前值大于 `target`, 向左移动 (列减一); 如果当前值小于 `target`, 向下移动 (行加一).
- **矩阵置零 (Set Matrix Zeroes)**
    * **思路提要 (O(1) 空间):** 使用矩阵的第一行和第一列作为标记位. 先扫描第一行和第一列, 记录它们本身是否需要被置零. 然后扫描除第一行第一列外的其他部分, 如果 `matrix[i][j] == 0`, 则将 `matrix[i][0]` 和 `matrix[0][j]` 置为0. 再次扫描, 根据第一行和第一列的标记位将对应行列置零. 最后根据最初的记录处理第一行和第一列.
- **旋转图像 (Rotate Image)**
    * **思路提要:** 先沿主对角线 (左上到右下) 翻转矩阵, 然后再水平翻转 (沿垂直中线).
### **杂项高频题 (Misc. High Frequency)**
- **最长公共前缀 (Longest Common Prefix)**
    * **思路提要 (横向/纵向扫描):** 横向: 以第一个字符串为基准, 依次与后面的字符串比较, 不断缩短公共前缀. 纵向: 比较所有字符串的第 `i` 列字符是否相同, 直到不同或越界.
- **任务调度器 (Task Scheduler)**
    * **思路提要 (贪心):** 决定最短时间的关键在于出现次数最多的任务. 假设它出现了 `max_freq` 次, 那么至少需要 `(max_freq - 1)` 个冷却间隔. 每个间隔长度为 `n`. 总时间为 `(max_freq - 1) * (n + 1) + (与最频繁任务同频率的任务数)`. 结果需与任务总数取最大值.
- **寻找峰值 (Find Peak Element)**
    * **思路提要 (二分查找):** 如果 `nums[mid] < nums[mid+1]`, 说明上坡在右侧, 峰值一定在右侧. 否则, 峰值在左侧或 `mid` 本身就是峰值. 通过不断缩小范围找到一个峰值.
- **第一个缺失的正数 (First Missing Positive)**
    * **思路提要 (原地哈希):** 遍历数组, 目标是将数字 `x` 放到索引 `x-1` 的位置上 (通过交换). 遍历结束后, 再次扫描数组, 找到第一个 `nums[i] != i+1` 的位置, `i+1` 就是缺失的最小正数.



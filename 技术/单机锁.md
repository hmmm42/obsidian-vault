==单机锁就是并发锁==
# 悲观锁
悲观锁" 认为数据冲突的概率很高, 所以在访问资源前**总是先加锁**, 操作完再释放. "先锁定, 再操作". 我们常用的 `Mutex` 就是典型的悲观锁.
- **互斥锁 (Mutex - `sync.Mutex`)**
    - 最基础的锁, 实现"互斥"访问. 一个 `Mutex` 在同一时间只能被一个 Goroutine 锁定, 其他试图锁定的 Goroutine 会被阻塞, 直到锁被释放.
    - **场景:** 保护一段代码逻辑 (临界区), 确保其在同一时间只有一个 Goroutine 在执行.
- **读写锁 (RWMutex - `sync.RWMutex`)**
    - 互斥锁的升级版, 进行了读/写操作的区分.
    - **规则:** 读与读不互斥 (可以有多个 Goroutine 同时读), 读与写互斥, 写与写互斥.
    - **场景:** 适用于**读多写少**的高并发场景. 如果大量 Goroutine 只是读取数据, 用读写锁可以极大地提高并发性能.
- **自旋锁 (Spinlock)**
    - 一种特殊的互斥锁. 当线程获取锁失败时, 它**不会被操作系统挂起**, 而是会进入一个忙等待的循环 (自旋), 不断地尝试获取锁.
    - **优点:** 避免了线程上下文切换的巨大开销.
    - **缺点:** 如果锁被占用的时间很长, 自旋会持续消耗 CPU 资源.
    - **场景:** 适用于锁的持有时间**极短**、几乎可以确定在几次循环内就能拿到锁的场景. (我们之前用 CAS 实现的 `SpinLock` 就是一个例子).
# 乐观锁
"乐观锁" 认为数据冲突的概率很低, 所以它**不加锁就去操作数据**. 在最后**提交更新**的时候, 再去**验证**一下在此期间有没有其他线程修改过数据. 
#### 1\. 什么是 CAS? (What)
CAS 的全称是 **Compare-And-Swap**, 即 "比较并替换".
它不是一种 Go 语言特有的东西, 而是一种**思想**和一种**CPU 指令**的实现. 它是一种乐观的并发控制技术, 总是假设自己可以成功完成操作, 如果失败了再进行重试.
CAS 操作包含三个核心操作数:
1.  **内存地址 V (The memory location to operate on)**
2.  **期望的旧值 A (The expected old value)**
3.  **要替换的新值 B (The new value to swap in)**
**其执行逻辑是:**
"我认为地址 `V` 处的当前值应该是 `A`, 如果确实是 `A`, 那就把它更新为 `B`. 如果不是 `A` (说明在我准备更新的期间, 有其他线程已经修改了它), 那么什么也别做, 并告诉我操作失败了."
**一个绝佳的生活比喻: 协同编辑 Wiki 文档**
4.  **读取 (Read):** 你打开一个 Wiki 页面, 看到它的版本号是 `v5`, 然后你开始在本地编辑. (你读取了内存值 `A=v5`)
5.  **计算 (Compute):** 你花费了一些时间, 写好了新的内容. (你准备好了新值 `B=新内容`)
6.  **比较并替换 (CAS):** 当你点击 "保存" 时, 你对系统发起一个 CAS 请求:
      * "请检查一下, 如果当前服务器上这篇文章的版本号**仍然是 `v5`** (期望的旧值 `A`), 那么请把我的**新内容** (`B`) 保存上去, 并把版本号更新为 `v6`. "
      * **如果成功:** 说明在你编辑期间没人修改过, 操作完成.
      * **如果失败:** 服务器告诉你: "抱歉, 当前版本已经是 `v7` 了, 说明在你编辑的时候, 别人已经提交了新版本." 这时, 你就需要**放弃**你的操作, **重新读取** `v7` 版本的内容, 在此基础上修改, 然后再发起一次新的 CAS 保存请求. 这个 "放弃并重新尝试" 的过程, 就是所谓的 **"自旋 (Spinning)"**.
#### 2\. 如何保证无锁且原子化? (How)
这是问题的核心. CAS 的魔力在于, "比较" 和 "替换" 这两个动作**不是通过软件逻辑 (例如加锁) 来保证原子性的, 而是由 CPU 硬件层面的一条原子指令来保证的.**
  * **原子性 (Atomicity):**
      * 现代 CPU (如 x86, ARM) 提供了一系列特殊的**原子指令**, 例如 x86 架构下的 `CMPXCHG` (Compare and Exchange).
      * 当程序执行 CAS 操作时, 最终会调用到这条 CPU 指令. CPU 硬件会保证**该指令的执行是不可中断的**.
      * 在它执行期间, CPU 不会切换到其他线程, 其他 CPU 核心也不能访问这个内存地址. 从 "读取内存值V -\> 比较是否等于A -\> 写入新值B" 的整个过程, 对于其他线程来说, 要么就是完全没发生, 要么就是已经完成了, 不会看到中间状态.
      * **一句话总结: 原子性由 CPU 硬件指令直接保证, 而不是靠操作系统或软件锁.**
  * **无锁 (Lock-Free):**
      * 正因为它不使用传统意义上的**互斥锁 (Mutex)**, 所以它被称为 "无锁编程" 的一种.
      * 在使用 Mutex 时, 如果一个线程拿不到锁, 它会被操作系统挂起 (put to sleep), 进入等待状态, 这会涉及线程上下文切换, 开销较大.
      * 而在 CAS 中, 线程不会被挂起. 如果操作失败, 它会立即得到通知, 然后由程序员决定是立即重试 (自旋), 还是先做点别的事.
      * 这种 "永不阻塞, 乐观尝试" 的特性, 使其在某些高并发、低竞争的场景下, 性能远超基于锁的实现, 因为它避免了线程挂起和恢复的开销.
#### 3\. Go 中的 CAS 操作 (`sync/atomic` 包)
Go 在 `sync/atomic` 包中提供了一系列 CAS 函数, 例如:
  * `atomic.CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)`
  * `atomic.CompareAndSwapInt64(...)`
  * `atomic.CompareAndSwapPointer(...)`
  * ... 等等
**代码示例: 使用 CAS 实现一个简单的自旋锁 (Spinlock)**
自旋锁是一种简单的锁, 获取锁的线程会忙等待 (循环), 直到锁被释放.
```go
package main
import (
	"fmt"
	"sync"
	"sync/atomic"
)
// SpinLock 是一个使用 CAS 实现的自旋锁
type SpinLock struct {
	state int32 // 0: unlocked, 1: locked
}
// Lock 获取锁
func (sl *SpinLock) Lock() {
	// 持续尝试将 state 从 0 (unlocked) 替换为 1 (locked)
	// 如果 state 当前不是 0, 说明锁被其他 goroutine 持有,
	// CAS 操作会失败, for 循环会继续, 直到成功为止.
	for !atomic.CompareAndSwapInt32(&sl.state, 0, 1) {
		// Go 1.5 之后, 可以在这里加入 runtime.Gosched()
		// 主动让出 CPU, 让其他 goroutine 先跑, 避免纯粹的 CPU 空转
	}
}
// Unlock 释放锁
func (sl *SpinLock) Unlock() {
	// 将 state 原子地设置回 0 (unlocked)
	atomic.StoreInt32(&sl.state, 0)
}
func main() {
	var lock SpinLock
	var wg sync.WaitGroup
	var count int
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			lock.Lock()
			count++
			lock.Unlock()
		}()
	}
	wg.Wait()
	fmt.Println("Count:", count) // 输出: Count: 100
}
```
#### 4\. CAS vs 互斥锁 (Mutex): 何时使用?
| 特性 | CAS (无锁) | Mutex (有锁) |
| :--- | :--- | :--- |
| **核心思想** | 乐观, 假设没冲突, 失败后重试 | 悲观, 假设有冲突, 先拿锁再操作 |
| **实现层面** | CPU 原子指令 | 操作系统提供的同步原语 |
| **性能** | **竞争少**时性能高, 避免了线程切换开销 | **竞争激烈**时性能可能更高, 失败线程会休眠让出 CPU |
| **CPU 消耗**| **竞争激烈**时, 大量重试会造成 CPU 空转, 浪费资源 | 线程休眠, 不消耗 CPU |
| **问题** | 编码复杂, 需要手动处理重试循环; 可能有 **ABA 问题** | 可能会导致死锁, 活锁 |
| **适用场景** | 对**单个**简单值 (int, pointer) 的原子更新, 如计数器, 状态标志 | 保护一段**复杂**的代码逻辑 (临界区) |
**ABA 问题简介:**
这是一个著名的无锁编程问题. 线程1读取值 A, 准备将其更新为 C. 在此期间, 线程2将值从 A 改为 B, 又改回 A. 线程1回来执行 CAS 时, 发现值仍然是 A, 操作成功. 但实际上数据已经被 "动过" 了, 这可能会导致逻辑错误. 解决方案通常是使用版本号或标记指针.
### 总结 (面试回答要点)
1.  **CAS 是什么?** 全称 Compare-And-Swap (比较并替换), 是一种乐观并发操作, 包含内存地址V, 期望旧值A, 新值B三个操作数.
2.  **如何保证原子性?** **核心是 CPU 硬件\!** CAS 底层依赖于 CPU 提供的一条原子指令 (如 `CMPXCHG`), 保证了从"比较"到"替换"的整个过程不可中断.
3.  **为何是无锁?** 因为它不使用操作系统的互斥锁 (Mutex), 线程在操作失败时不会被挂起, 而是立即返回, 避免了线程上下文切换的开销.
4.  **Go 如何使用?** 通过 `sync/atomic` 包里的 `CompareAndSwap*` 系列函数.
5.  **应用模式?** 通常用在一个 `for` 循环中, 不断地读取-计算-CAS, 失败则重试, 也就是所谓的 "自旋".
6.  **与 Mutex 的区别?** CAS 适用于对单一变量的简单原子更新, 在低竞争下性能更好. Mutex 适用于保护复杂的代码块, 在高竞争下能避免 CPU 空转.
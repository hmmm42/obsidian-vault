> 桩文件 → 序列化 → TCP
- 定义 IDL 文件，编译工具生成 stub 桩文件，相当于生成了静态库，实现函数映射
- 网络里传输的数据都是二进制数据，需要把请求参数、返回结果进行 encode 和 decode
- 根据 RPC 协议 约定数据头、元数据、消息体等，保证有 ID 能使请求和返回结果做到一一映射。
- 基于成熟的网络库进行 TCP / UDP 传输
## 面试题：描述 RPC 的通信流程
- 函数映射：静态代理，生成 stub 文件
	- 对比建立 HTTP 请求连接，RPC 在编写代码时，降低了复杂度
	- stub 文件让远程调用看上去像是本地调用
- 序列化：为了生成二进制数据
	- HTTP/1 直接发送 JSON，明文传输
	- gRPC 以 protobuf 作为序列化协议
- 网络传输
	- 自定义 RPC 协议实现通信，大厂几乎都用自定义 RPC 框架去自定义 RPC 协议。
	- 使用成熟的网络库，实现多路复用、可靠传输。
## 比较 HTTP / RPC
- HTTP 是应用层协议。
- RPC 是远程过程调用，它是调用方式，对应的是本地调用。
- 所谓的 RPC 协议，实际上是基于 TCP、UDP、甚至 HTTP2 改造后的自定义协议。
### 编（解）码层
> 网络传输前，需要结构体转为二进制数据 → 序列化
- HTTP/1.1
	- 额外空间开销大，没有类型，开发时需要通过反射统一解决。
	- 序列化协议：JSON
![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/f606K72wESCsVr5dPGbBe3Xso7p2XGxK48cNoIDdwibd9XhJqYP6tlKibkRXyeooWYTcziaDIkApAM14nAkRTsF4g/640?wx_fmt=png&randomid=ole5f93f&tp=webp&wxfrom=5&wx_lazy=1)
- RPC
	- 序列化后的体积比 JSON 小 ⇒ 传输效率高
	- 序列化、反序列化速度快，开发时不需要通过反射 ⇒ 性能消耗低
	- IDL 描述语义比较清晰。
	- 序列化协议：以 gRPC 为代表的 Protobuf，其他也类似
### 通信协议约定
> 基于 TCP 传输，都会有消息头和消息体，区别在于消息头
- HTTP/1.1
	- 优点是灵活，可以自定义很多字段。
	- 缺点是包含许多为了适应浏览器的冗余字段，这些是内部服务用不到的。
- RPC
	- 可定制化，自定义必要字段即可。
	- 可摒弃很多 HTTP Header 中的字段，比如各种浏览器行为。
### 网络传输层
> 本质都是基于 Socket 通信
- HTTP/1.1
	- 建立一个 TCP 长连接，设置 keep-alive 长时间复用这个连接。
	- 框架中会引入成熟的网络库，给 HTTP 加连接池，保证不只有一个 TCP 连接可用。
- RPC
	- 建立 TCP 连接池，框架也会引入成熟网络库来提高传输性能。
	- gRPC 基于 HTTP/2，拥有多路复用、优先级控制、头部压缩等优势。
![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/f606K72wESCsVr5dPGbBe3Xso7p2XGxKVZichWGibxABzWAev2sicFl9fhaaSic1pE0cUoKzCAkSAsDUFrLicpNmU8A/640?wx_fmt=png&randomid=nre8ubv1&tp=webp&wxfrom=5&wx_lazy=1)
## RPC 的优势和不足
### 优势
- 相较于 HTTP/1.1，数据包更小、序列化更快，所以传输效率很高。
- 基于 TCP 或 HTTP/2 的自定义 RPC 协议，网络传输性能比 HTTP/1.1 更快。
- 适用于微服务架构，微服务集群下，每个微服务职责单一，有利于多团队的分工协作。
### 不足
- RPC 协议本身无法解决微服务集群的问题，例如：服务发现、服务治理等，需要工具来保障服务的稳定性。
- 调用方对服务端的 RPC 接口有强依赖关系，需要有自动化工具、版本管理工具来保证代码级别的强依赖关系。例如，stub 桩文件需要频繁更新，否则接口调用方式可能出错。
## RPC 框架
### 编解码层
#### 目标
- 生成代码：代码生成工具将 IDL 文件转换成不同语言可以依赖的 lib 代码（类似于库函数）
- 序列化 & 反序列化：对象 ↔ 二进制字节流
#### 选型
- 安全性
	- 通用性：跨语言、跨平台
	- 兼容性：序列化协议升级后，保证原服务的稳定性
- 性能
	- 时间：序列化反序列化的速度
	- 空间：序列化后的数据体积大小，体积越小，网络传输耗时越短
### 协议层
#### 目标
- 支持解析多种协议，包含 HTTP、HTTP2、自定义 RPC 协议、私有协议等。
#### RPC 通信协议的设计
> 大厂内部大部分用自定义的 RPC 协议，灵活 + 安全
- 作用：TCP 通道中的二进制数据包，会被拆分、合并，需要应用层协议确定消息的边界（说人话：得知道哪几个二进制包是这一条请求）
- 协议构成
	- 协议头 - 固定部分：整体长度、协议头长度、消息类型、序列化方式、消息 ID 等
	- 协议头 - 扩展部分：不固定的扩展字段，各种协议 DIY 的字段
	- 协议体：业务数据
![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/f606K72wESAo9XwMYUNFDFzQX2ibx1wyDnNos4rsp1n2ocFoguGTCcu9lkoXw2YBWeCN5slPhDytqtnRrDtV8nA/640?wx_fmt=png&randomid=is5xdkrk&tp=webp&wxfrom=5&wx_lazy=1)
### 网络传输层
> 一般使用成熟的网络通信框架（例如：Netty），会和 RPC 框架解耦
#### 目标
- IO 多路复用实现高并发，可靠传输
#### 选型指标
- 易用：封装原生 socket API
- 性能：零拷贝、建立连接池、减少 GC 等
## RPC 热门框架
### 跨语言调用型
- 典型代表：grpc，thrift
- 特点：
	- 提供最基础的 RPC 通信能力。
	- 专注于跨语言调用，适合不同语言提供服务的场景。
	- 没有服务治理等相关机制，需要借助其他开源工具去实现服务发现、负载均衡、熔断限流等功能。
### 服务治理型
- 典型代表：rpcx，kitex，dubbo
- 特点：
	- 服务定义（函数映射）
	- 多消息传输协议（序列化协议）
	- 多网络通信协议（TCP、UDP、HTTP/2、QUIC 等）
	- 提供最基础的 RPC 通信能力。
	- 提供服务治理能力：服务发现、负载均衡、熔断限流等。
### 框架功能简单介绍
#### 分层设计
- 调用层：封装服务，提供RPC调用接口
- 服务治理层：服务发现、负载均衡、熔断限流等
- 通信层：多网络通信协议、多消息传输协议（编解码、序列化、压缩）
![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/f606K72wESAo9XwMYUNFDFzQX2ibx1wyDALg6AlPLRvn3ceMDSuPBAvOcib8libCHHNGbZyvABu5icKIwhMPfC5Njw/640?wx_fmt=png&randomid=phit5j9s&tp=webp&wxfrom=5&wx_lazy=1)
#### 服务治理层
![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/f606K72wESAo9XwMYUNFDFzQX2ibx1wyDDG0o5KU2G3bDTI2DuRUIAg8AJibNa1Q7ru0eWqMxztMmT2Dq509H6Ug/640?wx_fmt=png&randomid=2h8ll6mr&tp=webp&wxfrom=5&wx_lazy=1)
- 服务端
	- 服务注册：上报服务名和服务的 IP、端口
	- 健康检测：第一时间让调用方知道服务出现问题
	- 限流：过载保护，访问量过大，抛出限流异常
- 客户端
	- 服务发现：根据服务名发现服务的 IP、端口
	- 路由策略：实现流量隔离，应用于灰度发布、隔离联调环境
	- 负载均衡：把请求分发到服务集群的每个服务节点
	- 重试机制：捕获异常，根据负载均衡再次选择节点重发请求
	- 故障熔断：确定下游异常，请求直接被截断，快速执行失败
#### 其他基础功能
- 日志 Log
- 监控 Metric
- 链路追踪 Tracing
- 丰富的插件机制
### 1. gRPC

gRPC 是 Google 开发并开源的一个高性能, 通用的 RPC 框架. 它是目前微服务领域最受欢迎的协议之一.

**特点:**

* **高性能:** gRPC 使用 HTTP/2 作为其传输协议. HTTP/2 提供了多路复用, 头部压缩和服务器推送等功能, 相比于 HTTP/1.1, 它可以显著减少延迟, 提高网络利用率.
* **跨语言:** gRPC 使用 Protocol Buffers (简称 Protobuf) 作为其接口定义语言 (IDL) 和数据序列化格式. 你可以使用 `.proto` 文件定义服务接口和消息结构, 然后 gRPC 的工具链可以为多种主流编程语言 (如 Go, Java, Python, C++, Node.js 等) 自动生成客户端和服务端代码. 这使得不同语言编写的微服务之间可以轻松通信.
* **强类型契约:** Protobuf 是一种二进制序列化协议, 相比于 JSON, 它更紧凑, 解析速度更快. 同时, `.proto` 文件提供了一个严格的服务契约, 使得服务端和客户端之间的接口定义清晰明确, 减少了集成时的错误.
* **支持多种通信模式:**
    * **Unary RPC (一元 RPC):** 传统的请求-响应模式.
    * **Server streaming RPC (服务端流):** 客户端发送一个请求, 服务端返回一个数据流.
    * **Client streaming RPC (客户端流):** 客户端发送一个数据流, 服务端返回一个响应.
    * **Bidirectional streaming RPC (双向流):** 客户端和服务器都可以双向发送数据流. 这对于实时通信, 如聊天应用或实时数据更新等场景非常有用.
* **生态系统和可插拔性:** gRPC 提供了丰富的生态支持, 包括认证, 负载均衡, 日志记录和健康检查等.

**适用场景:** 对性能要求极高的内部服务间通信, 需要跨语言支持的复杂系统, 以及需要利用流式通信的场景.

### 2. Apache Thrift

Thrift 最初由 Facebook 开发, 现在是 Apache 的顶级项目. 它是一个历史悠久且非常成熟的 RPC 框架.

**特点:**

* **成熟且稳定:** Thrift 经过了 Facebook 等大规模互联网公司多年的生产环境验证, 非常稳定可靠.
* **广泛的语言支持:** Thrift 可能是目前支持语言最多的 RPC 框架, 几乎涵盖了所有主流和一些小众的编程语言.
* **灵活的协议栈:** Thrift 的架构设计非常灵活, 允许你自由组合不同的传输层 (Transport), 协议层 (Protocol) 和处理层 (Processor).
    * **Transport:** 支持 `TSocket` (阻塞式 I/O), `TNonblockingSocket` (非阻塞式 I/O), `TFramedTransport` 等多种方式.
    * **Protocol:** 支持 `TBinaryProtocol` (二进制), `TCompactProtocol` (更高压缩率的二进制), `TJSONProtocol` (JSON格式) 等多种数据格式.
* **清晰的接口定义:** 和 gRPC 类似, Thrift 也有自己的接口定义语言 (IDL), 你需要在 `.thrift` 文件中定义服务, 然后通过代码生成器生成不同语言的代码.

**与 gRPC 的比较:**

* Thrift 不强制绑定特定的传输协议 (不限于 HTTP/2).
* Thrift 的流式处理能力不如 gRPC 原生支持得好.
* 在社区活跃度和云原生生态集成方面, 近年来 gRPC 的势头更猛.

**适用场景:** 需要支持非常广泛的语言栈 (特别是 C++, Python 等), 或者需要对传输和协议层进行高度定制化的项目.

### 3. JSON-RPC

JSON-RPC 是一个非常轻量级的无状态 RPC 协议. 它的规范非常简单, 编码格式采用 JSON.

**特点:**

* **简单轻量:** 整个协议规范非常简短, 易于理解和实现. 请求和响应都使用简单的 JSON 结构来表示.
* **易于调试和可读性好:** 因为数据格式是人类可读的 JSON, 所以调试起来非常方便, 可以直接通过 `curl` 等工具进行测试.
* **广泛的实现:** 几乎所有的编程语言都有成熟的 JSON 库, 实现一个 JSON-RPC 的客户端或服务端相对容易.
* **通常基于 HTTP:** 虽然协议本身与传输层无关, 但绝大多数实现都基于 HTTP/1.1, 这使得它可以轻松穿越防火墙和被现有的 Web 基础设施支持.

**缺点:**

* **性能较低:** 相比于 gRPC 和 Thrift 的二进制协议, JSON 的序列化/反序列化开销更大, 数据体积也更大, 网络传输效率较低.
* **无正式的 IDL:** JSON-RPC 本身没有像 Protobuf 或 Thrift 那样的接口定义语言. 服务契约通常需要通过其他方式来定义和维护 (例如 OpenAPI/Swagger), 这可能导致契约不一致的问题.
* **功能相对简单:** 不像 gRPC 那样原生支持流式处理, 元数据传递等高级功能.

**适用场景:** 对性能要求不高, 但对开发效率, 可读性和调试便利性要求较高的场景. 特别适合作为开放 API 供外部第三方或前端 Web 应用调用.

### 总结对比

| 特性 | gRPC | Apache Thrift | JSON-RPC |
| :--- | :--- | :--- | :--- |
| **底层传输** | HTTP/2 | TCP (可定制) | 通常是 HTTP/1.1 |
| **数据格式** | Protocol Buffers (二进制) | 多种可选 (二进制, JSON 等) | JSON (文本) |
| **性能** | 非常高 | 高 | 一般 |
| **跨语言** | 优秀 | 极其广泛 | 优秀 (手动实现) |
| **服务契约 (IDL)** | `.proto` 文件 (强契约) | `.thrift` 文件 (强契约) | 无 (弱契约) |
| **流处理** | 原生支持双向流 | 支持有限 | 不支持 |
| **生态与工具链** | 非常丰富, 云原生集成好 | 成熟, 稳定 | 简单, 依赖通用库 |
| **开发调试** | 相对复杂, 需专门工具 | 相对复杂 | 非常简单, 可读性好 |

### 如何选择?

* **追求极致性能和内部通信:** 首选 **gRPC**. 它的高性能, 强契约和流处理能力非常适合现代云原生微服务架构.
* **需要兼容遗留系统或支持大量语言:** 可以考虑 **Apache Thrift**. 它的稳定性和广泛的语言支持是其最大优势.
* **提供对外开放 API 或对开发调试便利性要求高:** **JSON-RPC** (或更广义的 RESTful API) 是一个不错的选择, 它的简单和通用性使其易于集成和使用.
# 乐观锁 (Optimistic Locking)
## 版本号法
- **工作方式**：假设冲突很少发生。它通过一个版本号（`version`）字段来实现。更新数据时，会检查版本号是否匹配 (`WHERE version = ?`)。如果不匹配，说明数据被别人修改了，本次更新失败，需要应用层自己决定是否重试。
- **优点**：在**冲突概率低**、**读多写少**的场景下，它不会产生锁等待，并发性能更好。
- **缺点**：在**冲突概率高**（“高并发写”）的场景下，它会成为一场灾难。大量的请求会因为版本号不匹配而更新失败，然后应用层会不断==重试==，这造成了大量的 CPU 资源浪费在失败的尝试上，性能会急剧下降，这被称为“活锁 (Livelock)”。
## CAS自旋法
用库存替代版本号
- `update`时检查库存是否与之前`select`时的一致
- 直接`update where stock > 0` ==简单场景下最优==
## 比较
### 方案三: 原子性扣减 (`WHERE stock > 0`) - “简单计数器”场景的王者
这个方案的本质是**将业务逻辑的判断条件直接下推到SQL语句中**, 利用数据库的原子性来保证操作的正确.
- **最优场景**:
    - 所有 **“计数器”式** 的更新操作.
    - 例如: **扣减库存、扣减账户余额、增加点赞数、减少优惠券数量**等.
    - 这些操作的共同点是: 业务逻辑非常简单, 只关心一个条件 (大于0), 并且操作本身也是简单的加减.
- **为什么在此场景最优?**
    - **性能最高**: 将“读-改-写”三步合并为一步数据库操作, 极大减少了应用与数据库之间的网络往返.
    - **应用层最简单**: 无需实现复杂的重试逻辑. `UPDATE` 的返回值 (`affected_rows`) 直接告诉了你是成功还是失败(已售罄), 逻辑清晰.
- **局限性**:
    - 它能处理的业务逻辑非常有限. 如果你的更新决策需要依赖多个字段的复杂状态, 它就无能为力了.
### 方案一: 基于版本号 (`version`) 的乐观锁 - “复杂业务更新”场景的标配
这是最经典、最通用的乐观锁实现.
- **最优场景**:
    - **更新操作依赖于你读取到的对象的多个状态(多个字段).** 这是它和方案三最本质的区别.
    - 例如: 你要处理一个订单, 业务逻辑是“**如果**订单状态是‘待支付’ **并且** 订单金额小于100元, **那么** 就给这个订单应用一个新人折扣, 并将其状态改为‘待发货’”.
    - 在这个过程中, 你需要保证从你读到这个订单, 到你写回这个订单的这段时间里, 它的`status`和`amount`字段都没有被其他任何事务所改变.
- **为什么在此场景最优?**
    - **保证了“读-改-写”的原子性**: `version`字段就像是整个数据行的一个“快照指纹”. `UPDATE ... WHERE version = old_version` 确保了你是在一个你预期的、完整的、未被修改过的业务对象上进行操作.
    - **保护了复杂的业务不变量**: 它可以防止“丢失更新”(Lost Update)问题. 如果没有`version`保护, 另一个并发操作可能在你计算折扣的同时, 将订单状态改为了“已取消”, 你的更新最终会覆盖掉“已取消”的状态, 导致数据错乱.
- **代价**:
    - 需要在数据库表中**增加一个`version`字段**.
    - 应用层需要处理更新失败后的**重试逻辑**.
### 方案二: 检查库存一致 (`WHERE stock = old_stock`) - “无法改表”时的务实之选
这个方案可以看作是方案一的一种“降级”或“模拟”.
- **最优场景**:
    - 业务逻辑**同样很复杂**, 依赖于对象的多个状态.
    - **但是**, 由于某些原因(比如历史系统、权限问题), 你**无法修改数据库表结构**, 不能增加一个`version`字段.
- **为什么是务实之选?**
    - 在这种限制下, 你只能选择一个你认为**最能代表数据版本变化的字段**来充当“代理版本号”. 对于商品来说, `stock`字段变化频繁, 是一个不错的选择. `updated_at`时间戳也是一个常见的选择.
    - 它提供了一种在无法使用真正版本号时, “尽力而为”的并发控制.
- **风险与局限**:
    - **保护不全面**: 它只能防止`stock`字段被修改的并发冲突. 如果另一个事务只修改了商品描述(`description`)而没有修改库存, 你的`UPDATE ... WHERE stock = old_stock`依然会成功, 但你实际上是在一个已经“过时”的业务对象上进行操作.
    - **可能存在ABA问题**. A -> B -> A
### 总结与权衡
|乐观锁方案|核心思想|最佳应用场景|优点|缺点|
|---|---|---|---|---|
|**原子性扣减** (`stock > 0`)|将判断下推到SQL|**简单的计数器式更新 (扣库存/余额)**|**性能最高, 应用层最简单**|无法处理复杂业务逻辑|
|**版本号** (`version = old_version`)|保护整个数据行的状态|**复杂的业务更新 (依赖多个字段状态)**|**通用性强, 数据保护最完整**|需要修改表结构, 应用层需重试|
|**检查一致** (`stock = old_stock`)|用现有字段模拟版本号|**复杂业务更新, 且无法修改表结构**|无需改表, 提供了一定程度的保护|保护不全面, 有潜在风险|
**结论**:
您的判断是正确的. 在“扣减库存”这个简单场景下, **原子性扣减 (`WHERE stock > 0`)** 方案因为其极致的简洁和高性能而成为不二之选.
但是, **前两种方案绝非无用**. 当业务逻辑变得复杂, 需要依赖对象的多个状态进行决策时, **基于`version`号的传统乐观锁**才是保证业务逻辑正确性的标准做法. 而**检查库存一致的方案**, 则是当您戴着“不能改表”的镣铐跳舞时, 一个务实而巧妙的折中选择.
# 悲观锁 (Pessimistic Locking)
- **工作方式**：假设冲突一定会发生。在读取数据时就直接上锁 (`FOR UPDATE`)，阻止其他事务对这条数据进行修改，直到当前事务结束。
- **优点**：在高并发、高冲突的场景下，它的处理方式非常“诚实”和高效。没抢到锁的事务会直接进入等待，而不是去进行无效的尝试。它能保证只有一个事务在处理，逻辑简单且数据绝对安全。
- **缺点**：如果锁定的事务执行时间过长，会阻塞其他事务，导致吞吐量下降。
# Cookie
只适用于浏览器, 以键值对存储
- **大小限制**：单个cookie通常不能超过4KB。
- **安全性**：如果直接在cookie中存储敏感信息，很容易被篡改。
- **跨域问题**：默认情况下，cookie是不能跨域共享的。
==Cookie只是浏览器的存储介质, 可以用来存储任何东西，包括Session ID，也可以存储一个完整的JWT==
# Session
- **Session-based Authentication:** 用户登录成功后，服务器会创建一个Session，并生成一个Session ID存储在用户的Cookie中。后续请求会携带该Session ID，服务器通过Session ID识别用户。==一般将`<SessionID, UserInfo>`键值对存入 redis==
    - **优点:** 实现简单，服务器端可以维护用户状态。
    - **缺点:** 在分布式或微服务架构下，Session共享和管理变得复杂。
# Token
**Token** 是一种基于**客户端存储**的鉴权方式，它解决了Session的分布式问题。
- **是什么**：一个不包含敏感信息的、由服务器生成的字符串，用于标识用户身份。
- **作用**：用户登录后，服务器生成一个Token并将其返回给客户端。客户端（如浏览器、移动App）将这个Token存储在本地（如`localStorage`或`sessionStorage`）。之后的每一次请求，客户端都将Token放在HTTP请求头中发送给服务器。服务器收到请求后，会验证这个Token的有效性。
- **特点**：
    - **无状态**：服务器不再需要存储用户的Session信息，完全依赖客户端发送的Token来判断身份。这大大减轻了服务器的负担。
    - **可扩展性**：非常适合分布式系统，因为任何一台服务器都可以验证同一个Token。
    - **跨域**：Token不受同源策略限制，可以在不同域名之间传递。
    - **安全性**：Token本身不加密，但通常包含一个签名，防止被篡改。
**总结**：Token就像是服务器发给用户的**“入场券”**。用户登录后拿到这张券，每次访问时都出示这张券，服务器检查券的真伪，而不需要记住每个人的身份。
- **Token Authentication (例如 JWT - JSON Web Tokens):** 用户登录成功后，服务器会生成一个包含用户信息的Token返回给客户端。客户端将Token存储在本地（例如 Local Storage 或 Cookie），并在后续请求的Header中携带。服务器通过验证Token的签名和内容来识别用户。
		- **优点:** ==无状态==，易于在==分布式系统==中使用，可包含用户信息。
    - **缺点:** 需要在客户端存储Token，存在被窃取的风险，Token过期处理需要考虑。
## JWT
分为`Header`,`Payload`,`Signature`, JSON格式, base64编码存储
- Header: 算法(用于生成`Signature`), 类型(`JWT`)
- Payload: 通用信息 发布者, 发布时间戳, 过期时间戳, 自定义信息
- Signature: header + "." + payload, 用密钥加密后的结果
流程: 用户登录, 服务端验证通过后, 生成 header, payload, 进行加密生成 signature
返回给用户 ==加密密钥不能泄露==
再次访问时, 取出 header + "." + payload 再加密一次, 与 Signature 比对

问题 3: "JWT 最大的特点之一是'无状态(Stateless)'. 这带来了什么好处, 又引入了哪些棘手的问题? 特别是, 如果一个用户的账号被盗, 管理员需要立刻让这个用户的所有 Token 失效, 你会如何设计一个支持 JWT '吊销'的方案?"
- **问题剖析**: 考察对 JWT 认证机制的深刻理解, 包括其核心优缺点和在真实场景下的安全补充设计. "JWT 如何主动失效"是该领域的经典面试题.
- **回答思路**:
    1. **好处**: "JWT 的无状态特性最大的好处是**可扩展性**. 服务端不需要存储 session, 只需要用密钥验证 Token 的签名即可. 这使得后端服务可以轻松地水平扩展, 任何一台服务器都能验证任何一个合法的 Token, 非常适合微服务和分布式架构."
    2. **棘手的问题 (双刃剑)**: "它的问题也源于无状态. 一旦一个 Token 被签发出去, 在它的**有效期(`exp`)** 内, 它就是合法的. 服务端无法像控制 session 一样从中心化的地方主动让它失效. 这就带来了几个问题:"
        - **无法主动登出**: 用户点击'登出'后, 服务端无法销毁这个 Token, 它在有效期内依然可用.
        - **无法强制下线**: 如果发现用户 Token 泄露或账号被盗, 无法立即将此 Token 踢下线.
        - **权限变更延迟**: 如果管理员修改了用户的权限, 已经签发的旧 Token 无法感知到这个变化, 用户依然持有旧的权限直到 Token 过期.
    3. **设计'吊销'方案**: "要解决这个问题, 就必须**牺牲一部分'无状态'的纯粹性, 引入一个中心化的状态存储**来记录失效的 Token. 有几种常见的方案:"
        - **方案一: 黑名单机制 (Blacklist)**:
            - "我会使用一个高速缓存, 比如 **Redis**, 来维护一个 Token 黑名单."
            - "当用户登出或被强制下线时, 我们将这个 Token 的唯一标识(比如 `jti` 声明)或者整个 Token 存入 Redis, 并设置一个等于该 Token 剩余有效期的 TTL."
            - "在网关的鉴权逻辑中, 除了验证 Token 的签名和有效期, **还需要查询 Redis, 检查该 Token 是否存在于黑名单中**. 如果存在, 则拒绝请求."
            - "**权衡**: 这个方案很灵活, 但它让每次请求都增加了一次对 Redis 的网络调用, 违背了 JWT 最初的'无状态'设计, 增加了系统的复杂度和延迟."
        - **方案二: 版本号/密钥轮换机制**:
            - "在用户的数据库记录中增加一个'Token 版本号'字段."
            - "签发 JWT 时, 将这个版本号作为 payload 的一部分. 鉴权时, 除了验证签名, 还需要从数据库或缓存中读取用户当前的 Token 版本号, 与 Token 中的版本号进行比对. 如果不一致, 则说明有更晚签发的 Token, 当前 Token 失效."
            - "当需要让用户所有设备都下线时, 只需要**在数据库中将该用户的 Token 版本号加一**即可."
            - "**权衡**: 这个方案比黑名单机制更优雅, 不需要存储大量的失效 Token. 但同样需要一次额外的查询(可以加缓存优化)."
    4. **总结**: "最终方案的选择取决于业务需求. 对于安全性要求极高的系统, 引入黑名单或版本号是必要的妥协. 对于普通系统, 也可以采用**缩短 Token 有效期(比如 15 分钟), 并配合 Refresh Token 机制**的策略. 这样即使 Token 泄露, 风险窗口也比较小, 是一种工程上的平衡."
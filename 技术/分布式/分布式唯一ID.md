# 背景
如果订单采用数据库自增ID:
1. **id的规律性太明显**，容易出现信息的泄露，数据可能容易被猜测到，被不怀好意的人伪造请求
2. **受单表数据量的限制**，MySQL中表能够存储的数据有限，会出现分库分表的情况，id不能够一直自增
# 解决: 分布式ID
全局唯一ID, 满足: **唯一性、安全性、递增性、高性能、高可用**
实现:
- UUID
- Redis 自增
- 数据库自增
- 雪花算法
---
## 1. UUID (Universally Unique Identifier)

- **是什么**：UUID是一个128位的数字，通常表示为32个十六进制数字，以连字符分隔，例如 `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`。它通过结合当前时间戳、机器的MAC地址、随机数等信息来保证全球范围内的唯一性。
- **Go语言实现**：可以直接使用 `github.com/google/uuid` 这个库来生成。
    ```go
    import "github.com/google/uuid"
    id := uuid.New().String() // 生成一个新的UUID并转换为字符串
    ```
  
- **优点**：
    - **实现简单**：几乎所有语言都有现成的库，可以本地生成，不依赖任何外部服务。
    - **全局唯一**：在正确实现下，冲突的概率极低，可以忽略不计。
    - **高性能**：本地生成，速度非常快。
- **缺点**：
    - **无序且太长**：UUID是无序的字符串，不具备递增性。这会导致在MySQL等使用B+Tree索引的数据库中，**插入性能差**（因为每次插入都可能导致索引页分裂和重排），并且**占用存储空间大**。
    - **可读性差**：一长串无意义的字符，不方便人类阅读和记忆。
    - **不适合做主键**：由于其无序性，不推荐直接作为数据库表的主键。
==UUID v7 可以做到按时间有序, 是最优选择==
---

## 2. Redis自增

- **是什么**：利用Redis的原子操作 `INCR` 或 `INCRBY` 命令来生成一个全局递增的序列号。
- **实现方式**：
    1. 程序向Redis发送 `INCR unique_id_key` 命令。
    2. Redis会原子地将`unique_id_key`这个键的值加1，并返回增加后的值。
- **优点**：
    - **递增性**：生成的ID是严格单调递增的，对数据库索引友好。
    - **高性能**：Redis基于内存，`INCR` 操作的性能非常高，可以达到每秒十万级别。
    - **实现相对简单**：只需要引入Redis客户端即可。
- **缺点**：
    - **强依赖Redis**：如果Redis实例发生故障或网络抖动，整个ID生成服务就会中断，导致业务不可用（高可用性差）。
    - **需要考虑持久化**：需要配置Redis的持久化策略（RDB或AOF），否则Redis重启后ID会丢失或回退，导致生成重复ID。
    - **扩展性问题**：性能受限于单个Redis实例的处理能力。

**项目中的应用**：可以结合日期和Redis自增来生成订单号，例如 `20250625` + `Redis自增的8位序列号`，这样既有时间信息，又能按日重置序列号。
[[city-picks]]中: `db.RedisClient.Incr(key).Result()` 

---

## 3. 数据库自增

- **是什么**：利用数据库（如MySQL）的`AUTO_INCREMENT`主键特性。
- **实现方式**：
    - **单库单表**：这是最简单的情况，直接使用表的自增ID。
    - **分库分表**：为了解决单表性能瓶颈，可以设置一个专门用来生成ID的表。每次需要ID时，就向这个表`INSERT`一条记录，并获取其自增ID。为了提高性能，可以给不同的业务或不同的ID生成实例设置不同的`step`（步长），例如A实例生成 1, 3, 5...，B实例生成 2, 4, 6...。
- **优点**：
    - **实现简单**：依赖数据库，易于理解。
    - **绝对唯一且递增**：ID由数据库保证，不会重复且严格递增。
- **缺点**：
    - **强依赖数据库**：性能瓶颈在数据库，每次获取ID都需要一次数据库写入和读取，并发能力有限。
    - **扩展性差**：如您提到的，在分库分表后，无法保证全局唯一和递增，需要额外的复杂设计（如上面的步长方案）来解决。
    - **可用性问题**：数据库故障会导致ID服务不可用。

---

## 4. Snowflake算法（雪花算法）

这是目前工业界最流行、最综合的分布式ID生成方案，由Twitter开源。

- **是什么**：Snowflake算法生成的是一个64位的长整型数字（`int64`），其结构被划分为几个部分：
    
    0 - 0000000000 0000000000 0000000000 0000000000 - 00000 - 00000 - 000000000000
    
    符号位 - 41位时间戳（毫秒级） - 5位数据中心ID - 5位机器ID - 12位序列号
    
    1. **1位符号位**：最高位总是0，保证生成的ID是正数。
    2. **41位时间戳**：记录了从一个指定时间点（Epoch）到当前时间的毫秒数。可以使用约69年。
    3. **10位机器位**：可以分为`5位数据中心ID`和`5位机器ID`，总共可以部署 210=1024 个节点。
    4. **12位序列号**：表示在同一毫秒内，同一台机器上可以生成的ID序列号，总共有 212=4096 个。
- **实现方式**：
    
    - 在应用启动时，为每个实例分配一个唯一的机器ID（和数据中心ID）。
    - 当需要ID时，算法会组合当前的时间戳、实例的机器ID，以及一个在当前毫秒内自增的序列号来生成最终的ID。
- **优点**：
    
    - **全局唯一**：通过时间戳和机器ID保证。
    - **高性能**：ID在本地生成，不依赖任何外部服务。
    - **趋势递增**：因为ID的主要部分是时间戳，所以生成的ID整体上是按时间趋势递增的，对数据库索引友好。
    - **高可用**：每个服务实例都能独立生成ID，不依赖中心节点。
- **缺点**：
    - **依赖机器时钟**：如果服务器时钟发生回拨，可能会导致生成重复的ID。需要有相应的处理机制来应对时钟回拨问题。
    - **需要分配和管理机器ID**：需要一套机制来确保每个实例的`workerId`是唯一的，通常可以借助ZooKeeper、Etcd或配置中心来管理。
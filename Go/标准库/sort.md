# sort.Ints()
`go1.24`中`sort.Ints`（以及其他泛型排序函数）使用的排序算法是**pdqsort (Pattern-defeating Quicksort) 的简化版**。这是一个混合排序算法，旨在结合快速排序、堆排序和插入排序的优点，同时通过一些策略来避免快速排序在某些特殊数据模式下的性能退化。
### 1. 核心思想：自适应混合排序
`pdqsort`的核心思想是**自适应**，它会根据当前待排序子数组的特征来动态选择最优的排序策略。其主要目标是：
* **大多数情况下使用快速排序**：因为快速排序在平均情况下性能最佳，时间复杂度为$O(n \log n)$。
* **避免快速排序的最坏情况**：当数据呈现某些特定模式（如已排序、反向排序）时，快速排序的性能会退化到$O(n^2)$。`pdqsort`通过特定的机制来检测并避免这种情况。
* **利用其他算法的优势**：对于小规模数据，插入排序比快速排序更快；当快速排序出现问题时，使用堆排序作为保底。
---
### 2. 算法流程分解
该`pdqsortOrdered`函数通过一个`for`循环来处理待排序的子数组。每次循环都会对当前子数组进行处理，直到它被排序完成。
#### 2.1. 插入排序（`maxInsertion`）
当待排序子数组的长度**小于等于12**时（`length <= maxInsertion`），算法会直接调用**插入排序**（`insertionSortOrdered`）。
* **原因**：对于小规模数据，插入排序的常数因子更小，执行效率比快速排序更高。
#### 2.2. 堆排序（`limit`）
`limit`变量是算法的关键，它代表了允许快速排序出现“不良”分区的最大次数。当`limit`减到**0**时，意味着快速排序已经连续多次选择了不好的主元（pivot），导致分区不平衡。
* **策略**：为了防止性能进一步恶化，算法会**退化到堆排序**（`heapSortOrdered`）。堆排序的时间复杂度稳定在$O(n \log n)$，可以保证排序在最坏情况下也不会太慢。
#### 2.3. 模式破坏（`breakPatterns`）
当上一次分区**不平衡**时（`!wasBalanced`），算法认为数据可能存在某种特定的模式（例如，数据大部分有序）。
* **策略**：它会调用`breakPatternsOrdered`函数来**随机打乱**子数组中的一些元素。这种做法有效地“破坏”了数据的模式，使得下一次主元选择更有可能获得一个平衡的分区，从而避免了快速排序的性能退化。
#### 2.4. 主元选择（`choosePivot`）
`choosePivotOrdered`函数用于选择一个主元（pivot），它是分区操作的基准。这个函数不仅仅是简单地选择一个随机元素。
* **策略**：它会通过**三数取中法**来选择主元，即在子数组的开始、中间和结束三个位置中，选择中间大小的元素作为主元。这种方法比随机选择主元更稳定，能更好地避免极端情况。
* **反向数据检测**：如果`choosePivotOrdered`检测到数据是反向排序的（`hint == decreasingHint`），它会先**反转**这个子数组，然后再进行排序。这是一种非常有效的优化，可以将反向有序数据的排序成本降到最低。
#### 2.5. 快速排序分区（`partition`）
主元选定后，算法会调用`partitionOrdered`函数对子数组进行分区。
* **策略**：所有小于主元的元素被移到主元左边，所有大于主元的元素被移到主元右边。这个函数返回主元最终的位置`mid`。
* **重复元素优化**：如果检测到子数组中可能存在大量重复元素（`partitionEqualOrdered`），算法会采用一种特殊的双向分区策略，将所有等于主元的元素聚集在一起，从而减少递归的次数。
#### 2.6. 递归处理
分区完成后，算法会得到两个子数组（主元左边和右边）。它会选择**较小的那个子数组**进行**递归**（通过`pdqsortOrdered`函数调用自身）处理。
* **尾递归优化**：对于**较大的子数组**，算法会通过调整`a`或`b`指针，让`for`循环在下一次迭代中处理它。这种方法本质上是一种**尾递归优化**，避免了过多的函数调用栈，提高了效率。
* **平衡性判断**：`wasBalanced`变量用于判断本次分区是否平衡。如果分区后的两个子数组长度差距过大（例如，其中一个长度小于总长度的八分之一），那么`wasBalanced`会被设置为`false`，为下一次循环触发模式破坏策略做准备。
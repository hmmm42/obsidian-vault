## 可靠性
### 1. 序列号 (Sequence Number) 与 确认号 (Acknowledgement Number)
* **解决什么问题?** 解决两个问题: **1. 保证数据包的有序性.** 网络传输中, 后发的数据包可能先到, TCP需要能将它们重新排成正确的顺序. **2. 确认数据是否被接收.** 发送方需要知道哪些数据已经被对方成功接收.
* **工作原理:**
    * **序列号 (Seq):** TCP是面向字节流的, 发送方在建立连接时会初始化一个随机的序列号. 之后, 发送的每一个字节都会被编上一个连续的序列号. 在发送数据包时, TCP会在包头中带上这个包里第一个字节的序列号.
    * **确认号 (Ack):** 接收方收到数据后, 会回复一个ACK报文. 报文头里的确认号`ack`的含义是: **'我已经成功收到了所有序号在 `ack-1` 之前的数据, 我现在期望收到的是序号为 `ack` 的数据.'**
    * **举个例子:** 客户端发送了一个 `seq=100`, 长度为50字节的数据包. 服务器收到后, 会回复一个 `ack=150` 的确认包, 意思就是"100到149号字节我都收到了, 下次请从150号开始发". 这种方式被称为**累积确认**.
---
### 2. 重传机制 (Retransmission)
* **解决什么问题?** 解决**数据包丢失**的问题. 数据包在网络中可能因为各种原因丢失, TCP必须有办法发现并重传这些丢失的包.
* **工作原理:** 重传主要有两种机制:
    * **超时重传 (Timeout Retransmission):** 这是最基础的重传方式. 发送方每发送一个数据包, 就会启动一个计时器. 如果在计时器超时之前, 还没有收到对这个包的确认, 发送方就认为这个包丢失了, 并会重新发送它. 这个超时时间(RTO)是TCP动态计算的, 会根据网络的往返时间(RTT)自适应调整.
    * **快速重传 (Fast Retransmit):** 超时重传可能需要等待较长的时间. 快速重传是一个更高效的优化. 当接收方收到一个乱序的数据包时(比如收到了1, 2, 4, 5, 唯独没收到3), 它不会沉默. 它会立即发送一个对序号2的**重复ACK**. 当发送方连续收到**三个或以上**的对同一个数据包的重复ACK时(比如收到了三次`ack=3`), 它不等计时器超时, 就会立刻意识到序号为3的那个包很可能丢失了, 于是立即重传它.
---
### 3. 滑动窗口 (Sliding Window)
* **解决什么问题?** 解决**流量控制 (Flow Control)** 的问题. 它能防止一个发送速度过快的发送方, 把一个接收能力有限的接收方给“撑爆”.
* **工作原理:**
    * 接收方在它的TCP头部里有一个 **"接收窗口 (`rwnd`)"** 字段. 这个字段用来告诉发送方: "我的接收缓冲区现在还剩下多少空间, 你最多只能再发这么多数据给我".
    * 发送方会根据接收方在ACK包里通告的`rwnd`大小, 动态地调整自己的发送速率. 发送方已经发送但还未收到确认的数据量, 必须小于等于接收方通告的窗口大小.
    * 这个窗口是"滑动"的: 随着接收方处理完数据, 缓冲区有了新的空间, 它就会在后续的ACK中通告一个更大的`rwnd`, 窗口的右边缘就向右移动; 随着发送方收到ACK, 窗口的左边缘也向右移动. 这样就实现了持续、动态的流量控制.
---
### 4. 校验和 (Checksum)
* **解决什么问题?** 解决**数据完整性**的问题. 确保数据在传输过程中没有发生比特翻转或损坏.
* **工作原理:**
    * 发送方在发送数据前, 会对TCP的头部和数据部分计算出一个16位的校验和.
    * 接收方收到数据后, 会用同样的算法再次计算校验和.
    * 如果计算出的结果和数据包中携带的校验和不一致, 就说明数据在传输中被损坏了. 接收方会**直接丢弃**这个损坏的数据包.
    * 发送方因为收不到对这个包的ACK, 最终会通过重传机制重新发送这个包.
### 拥塞控制
"TCP协议需要在保证可靠性的同时, 避免把网络搞瘫痪. 这就是拥塞控制. 你能简单讲讲TCP拥塞控制的几个核心阶段吗, 比如**慢启动(Slow Start)** 和**拥塞避免(Congestion Avoidance)**?"
**➡️ 示例回答思路:**
1. **先说目标:** "好的. TCP拥塞控制的目标是动态地调整发送数据的速率, 以适应当前网络的承载能力, 避免因发送过快而导致大量丢包."
2. **引入核心概念:** "TCP通过维护一个叫做**拥塞窗口(`cwnd`)** 的状态变量来实现这个目标. `cwnd`决定了在收到ACK之前, 发送方最多可以发送多少数据."
3. **解释核心阶段:**
    - **慢启动 (Slow Start):** 连接刚建立时, TCP并不知道网络的带宽是多少. 它会采用一种比较激进的策略来快速探测.
        - `cwnd`的初始值通常很小 (比如 1 MSS).
        - 每收到一个ACK, `cwnd`就会增加 1 MSS.
        - 这导致`cwnd`在每个RTT (往返时间)后**指数级增长** (1 -> 2 -> 4 -> 8 -> ...). 这个阶段虽然叫'慢'启动, 但其实增长速度非常快.
    - **拥塞避免 (Congestion Avoidance):** 指数增长不能无限持续, 否则很快会撑爆网络.
        - 当 `cwnd` 增长到一个预设的**慢启动阈值(`ssthresh`)** 时, TCP会认为网络快要到极限了, 于是进入拥塞避免阶段.
        - 在这个阶段, `cwnd`的增长方式变得非常温和, 从指数增长变为**线性增长**. 每经过一个RTT, `cwnd`只增加 1 MSS. 就像踩油门从'地板油'变成了'轻点油门'.
    - **拥塞发生 (Congestion Detection):** 当发生丢包时 (通过超时重传或快速重传检测到), TCP就认为发生了拥塞.
        - 它会立刻将`ssthresh`设置为当前`cwnd`的一半.
        - 然后将`cwnd`重置为一个很小的值 (通常是1 MSS), 并重新开始**慢启动**过程.
        - 这个过程被称为"乘法减小, 加法增大(AIMD)", 体现了TCP在遇到问题时迅速退让, 在网络恢复后又谨慎探测的特性."
4. **总结:** "所以, 整个过程就是'慢启动'快速探测 -> '拥塞避免'谨慎增长 -> 遇到拥塞就迅速'刹车'减速, 然后再重复这个循环. 这是一个非常智能的自适应算法."

==实际发送窗口 = min(cwnd, rwnd)==
> "窗口大小就是指无需等待确认应答, 而可以继续发送数据的最大值."

这句话是对TCP**滑动窗口(Sliding Window)这个概念最核心、最经典的定义**. 它的目的是为了解决"停止-等待"协议效率低下的问题, 从而提高网络吞吐率. 这是一个**宏观原则**.
`拥塞窗口(cwnd)` 和 `接收窗口(rwnd)` 是现代TCP协议为了实现上述宏观原则, 在实际运行中动态计算和使用的**两个具体的窗口变量**.

"所以, TCP的可靠性就是通过**序列号和确认号**来编排数据, 通过**重传机制**来应对丢包, 通过**滑动窗口**来进行流量控制, 再通过**校验和**来保证数据不错, 这一整套组合拳来达成的."

## 粘包
不知道应用层消息的边界在哪
解决:
- 固定长度消息
- 特殊字符作为边界
- 消息头包含数据长度
## 丢包
ack重传
## 大量timewait
- 任意一方没有开启长连接, 用了`Connection:close`
	- web实现中, 如果没用长连接, 一般由服务端关闭连接
- 长连接超时, 服务端主动关闭连接, 直接进入timewait
- 一次长连接内请求达到上限, 直接进入timewait
## 大量closewait
被动关闭方才会出现, 说明服务端没有调用`close`关闭连接, 无法从closewait进入lastack
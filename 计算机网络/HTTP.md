## 状态码
HTTP 状态码是服务器对 HTTP 请求的响应状态，通常由三位数字组成，分为五大类。以下是它们的整理：
### 1xx 信息状态码 (Informational)
这类状态码表示请求已被接收，正在处理。
* **100 Continue**：客户端应该继续发送请求的剩余部分。
* **101 Switching Protocols**：服务器正在切换协议。
---
### 2xx 成功状态码 (Success)
这类状态码表示请求已成功被服务器接收、理解和处理。
* **200 OK**：请求成功，这是最常见的状态码。
* **201 Created**：请求已成功，并在服务器上创建了新的资源。
* **204 No Content**：请求成功，但响应中不包含任何实体内容。常用于 `DELETE` 或 `PUT` 请求。
- **206 Partial Content**: HTTP 分块下载或断点续传
---
### 3xx 重定向状态码 (Redirection)
这类状态码表示需要采取进一步的操作来完成请求。
* **301 Moved Permanently**：请求的资源已被永久移动到新位置。
* **302 Found**：请求的资源临时位于另一个 URI。
* **304 Not Modified**：自上次请求后，资源未被修改。服务器通常会带上 `ETag` 或 `Last-Modified` 头部来响应此状态码。
---
### 4xx 客户端错误状态码 (Client Error)
这类状态码表示客户端发送的请求有错误。
* **400 Bad Request**：服务器无法理解请求，通常是由于请求语法错误。
* **401 Unauthorized**：请求需要用户身份验证。
* **403 Forbidden**：服务器已理解请求，但拒绝执行。通常是权限问题。
* **404 Not Found**：服务器找不到请求的资源。这是最常见的错误状态码。
* **408 Request Timeout**：客户端没有在服务器指定的时间内完成请求的发送。
---
### 5xx 服务器错误状态码 (Server Error)
这类状态码表示服务器在处理请求时发生了错误。
* **500 Internal Server Error**：服务器遇到了一个意外情况，无法完成请求。这是一个通用的错误。
* **502 Bad Gateway**：作为网关或代理的服务器从上游服务器收到了无效的响应。
* **503 Service Unavailable**：服务器目前无法处理请求，通常是因为过载或停机维护。
* **504 Gateway Timeout**：作为网关或代理的服务器未能及时从上游服务器获取响应。
## 优化
### 减少请求次数
- **将重定向需求交给代理服务器**: 
![图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png)
如果代理服务器知道转发规则, 可以直接请求/url2, 而不用先请求/url1
- **合并请求**: 将多个小请求合并成一个大请求
- **延迟发送请求**: 不必一加载就请求所有资源
### HTTP/1.0 → HTTP/1.1：从短连接到长连接

HTTP/1.0 是一个非常简单的协议，它的主要问题是每次请求都需要建立一个新的 TCP 连接。这导致了巨大的性能开销，尤其是在加载一个包含大量资源的网页时。

HTTP/1.1 协议的出现，主要解决了这些问题：

* **持久连接 (Persistent Connection)**：这是最大的改进。HTTP/1.1 默认启用持久连接（即 `Keep-Alive`），允许在同一个 TCP 连接上发送多个 HTTP 请求。这大大减少了 TCP 三次握手和四次挥手的开销，显著提升了页面加载速度。
* 管道化 (Pipelining)：允许客户端在发送一个请求后，不等待服务器响应，就直接发送下一个请求。虽然这是一个理论上的优化，但在实际应用中由于“队头阻塞”问题（如果一个请求的响应被延迟，后续所有请求都会被阻塞），其应用效果有限，并且==现代浏览器已普遍不再支持==。
* **缓存机制 (Caching)**：引入了更精细的缓存控制头（如 `Cache-Control`, `ETag`），使得客户端可以更有效地利用本地缓存，减少重复请求。
* **Host 头 (Host Header)**：新增了 `Host` 请求头，允许服务器通过一个 IP 地址托管多个域名，解决了虚拟主机的难题。

### HTTP/1.1 → HTTP/2：从文本到二进制，从串行到并行

尽管 HTTP/1.1 引入了持久连接，但由于其请求和响应是串行的（一个连接只能处理一个请求），在面对复杂的现代网页时依然存在性能瓶颈。HTTP/2 旨在解决这个问题，它基于 Google 的 SPDY 协议，进行了多项革命性优化：

* **多路复用 (Multiplexing)**：这是 HTTP/2 最核心的特性。它允许在**一个 TCP 连接上同时发送多个独立的请求和响应**，==stream== 并且可以乱序接收。这从根本上解决了 HTTP/1.1 的队头阻塞问题，显著提高了并发性能。
	- 1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；
	- 1 个 Stream 里包含 2个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
	- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；
多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成，一个 Frame 可以由多个 TCP 报文构成。

* **二进制分帧 (Binary Framing)**：HTTP/2 将所有传输信息（包括请求头和请求体）都封装成=二进制帧=，这使得解析更高效、更紧凑。**HEADERS帧 DATA帧**
* **头部压缩 (Header Compression)**：通过使用 HPACK 算法，HTTP/2 压缩了请求和响应头，移除了重复的头部字段，大大减少了数据传输量。==静态表+动态表+霍夫曼编码压缩高频字符==
* **服务器推送 (Server Push)**：服务器可以在客户端请求之前，主动向其推送所需资源。例如，当客户端请求 HTML 页面时，服务器可以同时推送 CSS 和 JavaScript 文件，减少了客户端的往返时间。客户端请求是奇数号stream, 服务器推送是偶数号stream

---

### HTTP/2 → HTTP/3：从 TCP 到 UDP，彻底解决队头阻塞

HTTP/2 解决了==应用层的队头阻塞问题==，但它依然基于 TCP 协议。TCP 本身在丢包时存在“队头阻塞”：即使只丢失一个数据包，整个 TCP 连接中的所有数据流都会被阻塞，直到该数据包被重传成功。这在网络状况不稳定的环境下（如移动网络）尤为明显。

HTTP/3 放弃了 TCP，转而使用全新的 **QUIC 协议**，其核心优化如下：

* **基于 UDP (User Datagram Protocol)**：QUIC 协议运行在 UDP 之上。UDP 是无连接的，这使得 QUIC 能够构建自己的可靠传输机制，彻底绕过 TCP 的队头阻塞问题。
* **独立数据流 (Independent Streams)**：在 QUIC 中，多路复用不再依赖于 TCP 的单一通道。每个数据流都是独立的，如果一个流中的数据包丢失，只会影响该流，而不会阻塞其他流。
* **更快的连接建立 (Faster Connection Establishment)**：QUIC 将 ==TLS 加密握手和TCP 传输握手合并==，通常只需一个往返时间（RTT）即可建立安全连接，甚至在再次连接时可以实现 0-RTT 握手，大大降低了延迟。
* **连接迁移 (Connection Migration)**：QUIC 允许客户端在更换网络时（例如从 Wi-Fi 切换到移动网络），不中断现有连接。客户端的 IP 地址和端口号改变后，依然可以保持连接，这在移动设备上提供了更好的无缝体验。==用连接id替代序列号==
* 编码层QPACK, 同样是静态表+动态表+霍夫曼编码压缩高频字符, 更新动态表时用特殊的单向流来优化

这些演化是协议为了适应不断增长的网络需求和更复杂的应用场景所做出的持续改进。
23.1-3
假设 T0 和 T1 是将边 (u,v) 从 MST 中移除后得到的两棵树。假设 V0 和 V1 分别是 T0 和 T1 的顶点。设在这个切割上有某条边的权重小于 (u,v) 的权重, 将该边添加到 T1∪T0 来构建整个图的最小生成树。这样得到的最小生成树的权重将小于包含 (u,v) 的原始最小生成树的权重, 矛盾

23.1-5
证明: 假设一棵最小生成树包含了$e$, 那么可以构造出另一棵MST, 但是不包含$e$. $e=(u, v)$
将$e$从MST$T$移除, 生成两棵不连通的子树, 对于原来包含$e$的环路, 必然存在一条边$f$连接这两棵子树, 且权重$\leq e$. 那么用$f$连接这两棵子树, 形成生成树, 且新树必然是最小生成树

23.1-7
假设不是树, 那么存在回路, 对回路中的一条边$e$, 移除, 其余部分仍然连通, 但是总权重降低, 与总权重最小矛盾.
假设3个顶点的完全图, 每条边权重-1. 如果包含所有边, 总权重-3, 只包含两条边, 总权重-2, 论断不成立.

23.2-2
使用辅助数组`A`
- `A[u].1`: 一个顶点 `v`，这个 `v` 是当前树中离 `u` 最近的顶点。
- `A[u].2`: 边 `(v, u)` 的权重`w`。这是连接 `u` 到当前树的所有边中权重最小的。
```
PRIM-ADJ(G, w, r)
    initialize A with every entry = (NIL, ∞)
    T = {r}
    for i = 1 to V
        if Adj[r, i] != 0
            A[i] = (r, w(r, i))
    while T != V
        min = ∞
        for each v in V - T
            if A[v].2 < min
                min = A[v].2
                k = v
        T = T ∪ {k}
        k.π = A[k].1
        for i = 1 to V
            if Adj[k, i] != 0 and i ∉ T and w(k, i) < A[i].2
                A[i] = (k, w(k, i))
```
23.2-4
整数: 用非比较排序来优化初始排序, 复杂度为$$O(|E| + |V|)$$
常数: 同样用非比较排序, 复杂度为$$O(|E| + W)=O(|E|)$$
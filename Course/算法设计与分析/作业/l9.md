8.1-3
都不存在
一半:
假设存在, $r$为叶子节点数, 可以通过$h$次到达,有 $n!/2\leq n!\leq r\leq2^h$
$$h\geq\lg(n!/2)=\lg(n!)-1=\Theta(n\lg n)-1=\Theta(n\lg n).$$


$1/n$ : $(1/n)n!\leq n!\leq r\leq2^h$ 
$$h\geq\lg(n!/n)=\lg(n!)-\lg n=\Theta(n\lg n)-\lg n=\Theta(n\lg n).$$
$1/2^n$ :  $(1/2^n)n!\leq n!\leq r\leq2^h$ 
$$h\geq\lg(n!/2^n)=\lg(n!)-n=\Theta(n\lg n)-n=\Theta(n\lg n).$$
8.2-3
是正确的:无论你从前向后遍历输入数组 `A` 还是从后向前遍历, 当遇到一个值为 `k` 的元素时, 都会把它放到 `C[k]` 指定的位置, 然后把 `C[k]` 减一. 下一个值为 `k` 的元素就会被放到它前面一个位置, 确保了所有值为 `k` 的元素最终都会被放置在相应区间.
不再稳定: 刚好将原始顺序反转了.
8.2-4
复用计数排序算法, 输出时返回$C[b]−C[a−1]$
8.3-2
稳定: 插入排序, 归并排序
方法: 额外记录每个元素在原数组的索引, 排序时如果遇到元素相等, 再比较原始索引
额外时间不变, 额外空间$\Theta(n)$
8.3-4
使用基数排序+计数排序, 用n进制来表示, 位数最多为$\log_{n}3$, 只要进行3轮
每一轮使用计数排序, 复杂度$O(n+n)=O(n)$
总时间复杂度$O(n)$
8.4-2
如果所有的键都落在同一个桶中，而且恰好顺序颠倒，那么必须用插入排序法对一个包含 n 个项目的桶进行颠倒顺序排序。这就是 $Θ(n^2)$ 。
修改: 使用合并排序或堆排序来进行桶内部排序。
8.4-3
$$\begin{aligned}
& \mathbf{E}[X] = 2 \cdot \frac{1}{4} + 1 \cdot \frac{1}{2} + 0 \cdot \frac{1}{4} = 1 \\
& \mathbf{E}[X^2] = 4 \cdot \frac{1}{4} + 1 \cdot \frac{1}{2} + 0 \cdot \frac{1}{4} = 1.5 \\
& \mathbf{E}^2[X] = \mathbf{E}[X] \cdot \mathbf{E}[X] = 1 \cdot 1 = 1.
\end{aligned}$$
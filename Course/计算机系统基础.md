# 计算机系统
## 硬件组成
### 总线
### I/O设备
### 主存
### CPU
### cache 高速缓存
为了解决CPU和内存之间速度不匹配的问题，引入了高速缓存.介于寄存器和内存之间,速度比内存快,容量比寄存器小.
- [*] L1, L2, L3 cache  
## 存储器层次结构

## 操作系统
- [n] 将底层的设备包装起来
- [n] 保护用户,硬件,隔离恶意软件 
提供抽象表示:**进程,虚拟内存,文件**
### 进程
操作系统将CPU的时间分成很小的片段,每个片段分给一个进程,进程之间进行上下文切换.

### 线程
进程内部的一个执行单元,共享进程的资源,但有自己的栈和寄存器.可在多处理器上并行执行.

#### 并发 Concurrency/并行 Parallelism
- [*] 并发: 多个任务交替执行
- [*] 并行: 多个任务同时执行
线程级并行: 一个进程内的多个线程并行执行
指令级并行: 一条指令的多个部分同时执行 =>乱序执行

### 虚拟内存
使每个进程都在独占地使用主存
*C语言视角:内存是超大的数组*
每个进程都有一个**虚拟地址空间**,操作系统负责将虚拟地址转换为物理地址.

## 网络

# 信息的表示和处理

## 信息表示
**Bit**: 二进制位, 0或1
在计算机中可以用电压的高低来表示0和1,容易表示和检测

int整型在二进制中的位数是固定的,能表示的范围也是固定的

### 三种编码方式
- **无符号数**
- **补码**
- **浮点数**
Overflow: 溢出
上溢:结果超出表示范围
下溢: 结果为0

### 十六进制
和二进制转换相对容易,将十六进制的每一位转换为四位二进制即可 *从后往前转换*

### 布尔运算
- 与: 1&1=1, 0&1=0, 0&0=0
- 或: 1|0=1, 0|0=0
- 非: ~1=0, ~0=1
- 异或: 1^0=1, 0^0=0, 1^1=0 *不进位加法*

掩码:0xFF, X & 0xFF=低8位,X ^ 0xFF=取反

### 逻辑运算
- 与: &&, 短路与
短路操作: 当第一个操作数能够决定结果时,不再计算第二个操作数
- 或: ||, 短路或
- 非: !

### 移位运算
- 左移: <<, 低位补0
- 右移: >>, 高位补0(逻辑右移)或符号位(算数右移)
左移一位相当于乘2,右移一位相当于除2,在计算机中开销少
## 信息存储
**字节**：8位二进制数
**虚拟内存**：将内存视为一个字节数组
**地址**：内存中的字节编号
**指针**: 存储地址的数据

### 字数据
**字长**：指针数据的标称大小
字长为$w$位的计算机，虚拟地址空间有$2^w$个字节,虚拟地址范围为$0\sim2^w-1$

### 寻址
*大端存储和小端存储*: 大端存储将最高有效字节存储在最低地址,小端存储则相反

### 数据类型
有符号数: 以补码形式存储
无符号数: 以原码形式存储

如果将有符号数与无符号数进行比较,会强制将有符号数转为无符号数

**零扩展**:无符号数
**符号扩展**:补码数

截断:
- 无符号数:直接截断
- 有符号数:最高位$\Rightarrow$符号位

```cpp
size_t strlen() {}
return strlen(s1) - strlen(s2);
// error:只返回unsigned int
```

对于补码
正溢出: 结果大于$2^w$,转为负数
负溢出: 结果小于$-2^{w-1}$,转为正数

# 程序的机器级表示
## 机器级代码
操作码+操作数(立即数+寄存器+内存引用)
### 寄存器
以`%r`开头,存放整数数组,指针
- 调用者保存寄存器: %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15
- 被调用者保存寄存器: %rax, %rcx, %rdx, %rsi, %rdi, %r8, %r9, %r10, %r11
区别: 调用者保存寄存器在调用函数前需要保存,调用后需要恢复

$ 代表立即数
访问内存: movq $8(%rsp), %rax

### 数据传送指令
MOV src, dst
- src:源操作数:立即数,寄存器,内存
- dst:目的操作数:寄存器,内存
*x86的限制: 不能直接将内存到内存*
MOV类: movb, movw, movl, movq
分别表示传送字节,字,双字,四字
movsbq:Sign-extend byte to quadword
movzbq:Zero-extend byte to quadword

### 内存引用
将内存抽象为字节数组,得到数据需要同时知道地址和大小
标准形式:$Imm(r_{b},r_{i},s)\rightarrow Imm+R[r_{b}]+R[r_{i}]*s$
- Imm:立即数
- $r_{b}$:基址寄存器
- $r_{i}$:变址寄存器
- s:比例因子$[1,2,4,8]$,与`sizeof(type)`对应

另外注意:
$\$Imm\rightarrow Imm$
$Imm\rightarrow M[Imm]$
$(r_{b})\rightarrow M[R[r_{b}]]$


## 栈
LIFO,栈顶指针%rsp,由低地址往高地址
- pushq:将数据压入栈 
- popq:将数据弹出栈
eg.`pushq %rax` 等效于:
```c
subq $8, %rsp // 栈顶指针:0x100->0x108
movq %rax, (%rsp)
```
`popq %rbx`等效于:
```c
movq (%rsp), %rbx
addq $8, %rsp
```

## 算术和逻辑操作
- leaq: 计算有效地址,不访问内存,地址长度都是64位
### 一元操作
==op D -> D==
- incq, decq: 自增,自减
- negq: 取负
- notq: 取反
### 二元操作
格式:==S, D -> D op S -> D, 操作数不能是立即数==
- addq, subq: 加减
- imulq: 乘法
- xorq, orq, andq: 异或,或,与
## 控制
### 条件码
描述最近的算术/逻辑操作
- CF: 进位标志
- ZF: 零标志,结果为0时置1
- SF: 符号标志,结果为负时置1
- OF: 溢出标志
cmpq S, D: 比较S和D(减法),不保存结果,只设置条件码
testq S, D: 与操作,不保存结果,只设置条件码
**读取条件码用set指令**
- sete, setne: ZF
- sets, setns: SF
- setg, setge, setl, setle: SF, OF, ZF *有符号比较*
- seta, setae, setb, setbe: CF, ZF *无符号比较*

### 跳转
- jmp: 无条件跳转
- jxx: 条件跳转
eg. je, jne, jg, jge, jl, jle, ja, jae, jb, jbe

### 条件传送
cmovXX: 条件传送

## 过程
### 运行时栈
main -> f -> g
%rsp栈顶指针,%rbp帧指针,指明g结束时要从f的哪个位置继续
原来的%rbp |> old %rbp
之间的区域为栈帧
### 转移控制
调用一个函数要先保存返回地址,压入栈中
%rax保存返回值
call = push + jmp
ret = pop + jmp

### 数据传送
1~6个整型参数:用寄存器传递,其余用栈传递

## 数组

### 嵌套数组
`T D[R][C]`: R行C列的数组
$D[i][j] = x_{D}+L(C\cdot i+j)$
### 定长数组
针对定长,可以进行优化
```c
do {
	result += *Aptr * *Bptr;
	Aptr ++;
	Bptr += N;
} while (Bptr != Bend);
```
### 变长数组
```c 
for (j = 0; j < n; j++) 
	result += A[i][j] * B[j][k]; 
``` 

## 异质数据结构
### 结构体
内存中连续存储:后声明的紧挨在先声明的后面
起始位置偏移量为0,

### 联合
如果知道两个域是互斥的,可以使用联合

### 对齐
某种类型对象的地址必须是(2,4,8)的倍数 *软限制*
eg:char大小为1,加入3个字节的gap,使得int的地址为4的倍数



# 处理器体系结构
## Y86-64
### 指令编码
代码+功能:0~B

## 处理器设计

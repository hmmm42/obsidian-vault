- [Go语言实现黑马点评项目_黑马点评go-CSDN博客](https://blog.csdn.net/m0_57408211/article/details/137934662)
- [lhpqaq/xzdp-go: golang 版本小众点评（黑马点评） 后端](https://github.com/lhpqaq/xzdp-go/tree/master)

# 踩坑
## viper 读取环境变量
好像无法直接将环境变量Unmarshal到结构体中, 需要手动viper.Get(...)
## 日志无法输出
问题的根本原因是 [.envrc](vscode-file://vscode-app/c:/Users/qiuji/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 文件使用了 Windows 风格的行结束符（CRLF，即 `\r\n`），导致环境变量 `LOCAL_ENV` 的值变成了 `"true\r"` 而不是 `"true"`。当 Go 代码中的 [strconv.ParseBool()](vscode-file://vscode-app/c:/Users/qiuji/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 尝试解析这个值时失败了，所以 [isLocal](vscode-file://vscode-app/c:/Users/qiuji/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 变量被设置为 `false`，导致日志器使用了文件输出而不是控制台输出。

**解决方法：** 使用 `sed -i 's/\r$//' .envrc` 命令移除了回车符，然后运行 `direnv allow` 重新加载环境变量。

但是文件中同样找不到输出, 结果是修改文件结果时, 忘记在配置中调整了, 输出到了目录的上一级

**Shell脚本**：
- 如果您的项目中有 `.sh` 脚本，并且是在Windows环境下编辑保存为`\r\n`格式，那么当您尝试在Linux或macOS环境下执行它时，会因为多余的`\r`字符而报错，常见的错误是 `^M: command not found`。
## 测试文件读取统计变量
**测试代码和实际服务运行在不同的进程中**。
当你运行测试时：
1. 测试代码通过 HTTP 请求访问运行在 `localhost:14530` 的服务
2. 服务代码在一个独立的进程中运行，有自己的 [requestCount](vscode-file://vscode-app/c:/Users/qiuji/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 变量
3. 测试代码在另一个进程中运行，有自己的 [requestCount](vscode-file://vscode-app/c:/Users/qiuji/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 变量
4. 两个进程之间的内存是隔离的，所以测试无法访问到服务进程中的


# 架构演进
扁平化架构 -> 三层架构
引入 wire 依赖注入

是的，您的判断完全正确。

从`v0.7`版本的代码演进来看，原来在`v0.6`版本中使用的、基于`redsync`的**分布式锁机制，在核心的秒杀下单流程中，已经被新的、基于“Lua脚本+消息队列”的方案所取代，可以认为是“弃用”了**。

您贴出的这段被注释掉的代码，正是`v0.6`版本秒杀逻辑的完整体现，它清晰地展示了“分布式锁”方案的工作流程：

1. 查询数据库，判断秒杀资格（时间、库存）。
    
2. 查询数据库，判断是否一人一单。
    
3. **获取分布式锁** (`mutex.LockContext`)，锁住当前用户，防止该用户并发下单。
    
4. 在锁内执行数据库事务，创建订单、扣减库存。
    
5. **释放锁** (`defer mutex.Unlock`)。
    

### 为什么`v0.7`要弃用分布式锁方案？

`v0.6`的分布式锁方案虽然解决了**并发安全**问题（不会超卖，能保证一人一单），但它引入了新的**性能瓶颈**。

1. **性能瓶颈在于数据库**：
    
    - 尽管有了锁，但每个成功获取到锁的请求，依然需要执行**多次数据库查询和一次数据库事务写入**。
        
    - 在秒杀场景下，成千上万的请求会竞争同一个热门商品的库存。即使大部分请求被挡在锁外，但成功获取锁的那些请求会变成**串行执行**，一个接一个地访问数据库。
        
    - 数据库的写入性能远远低于Redis的内存操作性能，这使得整个系统的吞吐量受限于数据库的处理能力，无法应对真正海量的并发请求。
        

### `v0.7`的终极优化方案

`v0.7`版本采用了一套更高级的、业界主流的秒杀系统架构，来彻底解决性能问题：

1. **资格预校验（Lua脚本）**：
    
    - 将“判断库存”和“判断一人一单”这两个最关键的、需要原子性保证的操作，封装到一个**Lua脚本**中。
        
    - 利用Redis执行Lua脚本的**原子性**，一次网络IO就在Redis内存中完成了所有资格校验和库存预扣减。这个过程**完全不涉及数据库**，速度极快。
        
    - 脚本执行成功，只代表用户“获得了抢购资格”，并不代表订单创建成功。
        
2. **异步下单（消息队列）**：
    
    - Lua脚本执行成功后，**不再直接操作数据库**。
        
    - 而是将订单信息（`voucherId`, `userId`, `orderId`）作为一个消息，发送到**Redis Stream（扮演了消息队列的角色）**中。
        
    - API接口在发送完消息后，就可以**立即返回**，告诉用户“抢购请求已提交，请稍后查看结果”。这使得API的响应时间变得极短。
        
3. **独立消费者（服务解耦）**：
    
    - 项目中有一个或多个独立的后台协程（`internal/mq/stream.go`），作为消息队列的**消费者**。
        
    - 它们不断地从Redis Stream中拉取订单消息，然后**异步地、平稳地**将订单信息写入到数据库中。
        
    - 这将秒杀时的高并发流量削峰填谷，把对数据库的集中冲击，分散成了一段时间内的平滑写入。
        

### 总结

是的，`v0.7`之后，`redsync`分布式锁机制在秒杀场景下被弃用了。这是一个经典的架构演进过程：

- **v0.5 (纯数据库)**：解决了基本功能，但有并发安全和性能问题。
    
- **v0.6 (分布式锁)**：解决了**并发安全**问题，但暴露了**性能**瓶颈。
    
- **v0.7 (Lua+消息队列)**：通过异步化和内存计算，同时解决了**并发安全**和**性能**问题，达到了生产级秒杀系统的架构水平。
    

分布式锁本身是一种非常有用的技术，但在秒杀这种读多写少的极致性能场景下，将压力从数据库前置到Redis内存中，并采用异步处理，是更优的解决方案。

# 介绍
好的，这个问题问得非常好，是每个认真准备面试的同学都会思考的关键点。你的项目 `city-picks` 基础非常扎实，技术栈也很现代，这已经成功了一半。另一半就是如何从“完成了功能”升级到“展现了工程深度”，从而在千篇一律的“点评类项目”中脱颖而出。

你的风险判断是正确的：很多同学都会做类似的项目。面试官想看到的不是你又实现了一遍“附近商铺”或“优惠券领取”，而是你在这个过程中展现出的**思考深度、技术选型能力、以及对软件工程最佳实践的理解**。

下面，我将结合你现有的代码库，为你提供一套可以落地的“包装”和“发掘亮点”的方案。

### 核心思路：从“功能实现”到“工程化深度”

你需要把项目的介绍重点从 **“我做了什么功能”** 转移到 **“我为了解决什么问题，用了什么技术，对比了哪些方案，最终带来了什么效果”**。

---

### 一、 现有项目亮点的深度包装

你目前项目中最大的亮点就是**“基于Redis实现的秒杀优惠券功能”**。当面试官问到这里时，千万不要只说“我用了Redis的Lua脚本和消息队列做了秒杀”。你需要把它包装成一个完整的技术方案，展现你的思考过程：

**1. 痛点分析（面试时这样说）：**

> “在设计秒杀功能时，我首先分析了它的核心挑战：瞬时高并发下的“读请求”（查库存）和“写请求”（下订单）。如果直接操作MySQL，数据库会瞬间被打垮。同时，必须保证库存不能超卖，并且一个用户只能抢购一次，这涉及到数据一致性的问题。”

**2. 技术选型与方案设计（结合你的代码）：**

> 第一层：流量削峰与资格预校验
> 
> “为了解决这个问题，我没有让流量直接穿透到数据库，而是在前面加了一层Redis。我利用Redis的单线程特性和Lua脚本的原子性，将‘检查库存’和‘检查用户是否重复下单’这两个操作合并成一个原子操作。这确保了在高并发下资格预校验的正确性，并且性能极高，因为所有操作都在内存中完成。” （此时你可以展示 internal/service/seckill_lua.go 的脚本内容）
> 
> 第二层：订单异步化处理
> 
> “通过Lua脚本校验的用户，只是获得了下单资格，我并没有立即在主流程中创建MySQL订单。因为数据库写入依旧是瓶颈。我引入了基于Redis Streams的消息队列，将订单信息（如UserID, VoucherID）作为一个消息推送到队列中。这个过程非常快，可以立刻给用户返回‘抢购成功，订单处理中’的响应，极大地提升了用户体验和系统的吞吐量。”
> 
> 第三层：平滑消费与数据持久化
> 
> “最后，我有一个独立的消费者服务 (OrderConsumer) 去监听这个消息队列，以一个平稳的速率去消费消息，并最终将订单数据写入MySQL数据库。这样就实现了流量的‘削峰填谷’，保护了后端数据库。”
> 
> 第四层：可靠性设计（结合我们刚做的DLQ）
> 
> “我还考虑到了消息处理失败的情况。如果因为数据库抖动等原因导致订单创建失败，为了防止这条‘毒消息’阻塞整个队列，我设计了重试机制和死信队列（DLQ）。消息处理失败后会自动重新入队并记录重试次数，超过阈值后则被投入死信队列，并发送告警，等待后续人工处理，保证了系统的健壮性。”

通过这样层层递进的讲解，你展现的就不是一个简单的功能，而是一个完整的、经过深思熟虑的**高并发系统设计方案**。

---

### 二、 增加差异化的新亮点（具体建议）

除了包装现有功能，你还需要增加一些“人无我有”的亮点。下面是一些和现有项目结合紧密、且技术含量高的建议：

#### A. 性能与高并发方向

1. **实现附近商铺功能 (GEO)**
    
    - **现状**: 你的 `tb_shop` 表里有 `x` (经度) 和 `y` (维度) 字段，但很可能只是简单存储。
        
    - **亮点改造**: 使用 **Redis 的 GEO 数据结构** 来实现“附近商铺”功能。
        
        - 在创建或更新商铺时，使用 `GEOADD` 命令将商铺的ID和坐标加入到一个统一的GEO Key中。
            
        - 查询附近商铺时，使用 `GEORADIUS` 或 `GEOSEARCH` 命令，可以极快地（O(log(N))）查询出指定坐标点周围N公里内的所有商铺。
            
    - **面试价值**: 这展示了你对 Redis 多样化数据结构的应用能力，而不仅仅是把它当成一个简单的 Key-Value 缓存。这是非常亮眼的加分项。
        
2. **实现用户签到功能 (Bitmap)**
    
    - **现状**: `init.sql` 中有 `tb_sign` 表，但目前可能未使用。
        
    - **亮点改造**: 使用 **Redis 的 Bitmap** 来实现用户月度签到功能。
        
        - 一个用户的某个月的签到记录只占用一个 Redis Key，例如 `sign:userId:yyyyMM`。
            
        - 用户某天签到，就用 `SETBIT` 命令将该 Key 对应日期（0-30）的位设置为1。
            
        - 统计月度签到次数用 `BITCOUNT`。
            
        - 判断某天是否签到用 `GETBIT`。
            
    - **面试价值**: Bitmap 是处理海量用户状态（如签到、在线状态）的绝佳方案，能极大节省存储空间并提高性能。能主动使用并讲清原理，体现了你对性能优化的追求。
        

#### B. 系统可用性与稳定性方向

1. **引入分布式锁**
    
    - **现状**: 秒杀逻辑通过Lua脚本保证了原子性，但其他业务场景可能存在并发问题（例如，运营人员同时编辑同一个优惠券）。
        
    - **亮点改造**: 在一些关键的写操作上（如“创建/修改优惠券”、“修改商铺核心信息”），引入**基于Redis的分布式锁**（可以使用 `go-redsync` 等成熟的库）。
        
    - **面试价值**: 分布式锁是后端面试的高频考点。在项目中实际应用它，并能讲清楚其实现原理（如SETNX、过期时间、锁续期、Redlock算法等），能充分证明你的分布式系统基础。
        
2. **引入全面的可观测性 (Observability)**
    
    - **现状**: 项目有日志 (`slog`)，但缺少 Metrics 和 Tracing。
        
    - **亮点改造**:
        
        - **Metrics (监控指标)**: 集成 **Prometheus**。通过 `prometheus/client_golang` 库，在代码中埋点，暴露自定义的业务指标（如：接口QPS和延迟、秒杀成功率、消息队列堆积数等）到 `/metrics` 接口。
            
        - **Tracing (分布式追踪)**: 集成 **OpenTelemetry**。为你的 Gin 服务添加追踪中间件，让每个请求都带上唯一的 `TraceID`，并能串联起它在 Handler -> Service -> Repository -> DB/Redis 的完整调用链路。
            
    - **面试价值**: 这是从“学生项目”迈向“工业级项目”最重要的一步。展现了你对系统监控、问题排查、性能分析的理解，这是企业非常看重的工程能力。
        

#### C. 架构与代码质量方向

1. **完善单元测试与集成测试**
    
    - **现状**: 项目有 `tests` 目录但测试用例可能不全。
        
    - **亮点改造**:
        
        - **单元测试**: 为 `service` 层的核心业务逻辑编写单元测试。你需要学习如何使用 **Mock 技术**（如 `gomock`）来模拟 `repository` 层的依赖，从而可以独立测试业务逻辑。
            
        - **集成测试**: 为 `handler` 层的 API 编写集成测试，连接到测试用的数据库和Redis，验证端到端的流程正确性。
            
    - **面试价值**: 能写出良好测试的项目，说明你具备很强的代码质量意识和工程化素养，这是大厂的核心要求之一。
        

### 三、 如何在简历和面试中呈现

1. **简历写法**:
    
    - **避免**: “负责xx点评项目的开发，实现了登录、商铺展示、优惠券功能。”
        
    - **应该**:
        
        - “**主导设计并实现**了XX点评项目的秒杀系统，通过**Redis Lua脚本原子化预校验**与**Redis Streams消息队列异步下单**的架构，**将秒杀接口QPS从 xx 提升至 xx**，并成功支撑了10万用户同时在线的压测场景。”
            
        - “为项目引入了**分布式追踪(OpenTelemetry)**与**监控(Prometheus)**系统，实现了关键业务指标（如订单成功率、接口延迟）的可视化，**将线上问题排查效率提升了50%**。”
            
        - “利用**Redis GEO**数据结构优化“附近商铺”功能，**将查询延迟从800ms降低至50ms**，提升了用户体验。”
            
        - “主导了项目的**单元测试覆盖率从5%提升至70%**，引入Mock测试和集成测试，确保了核心模块的质量与稳定性。”
            
2. **面试准备**:
    
    - 准备好一张能清晰展示你项目**核心模块（特别是秒杀系统）的架构图**。
        
    - 对你使用的每一个技术点，都要能回答出 “**Why**”：你为什么用它？它解决了什么问题？有没有其他替代方案？优缺点是什么？
        
    - 准备好量化指标，即使是自己压测的数据，也比“感觉快了很多”更有说服力。
        

通过以上改造和包装，你的项目将不再是一个简单的 CURD 项目，而是一个有深度、有亮点、体现了你优秀工程素养的工业级项目雏形，这在实习面试中绝对会让你脱颖而出。

好的，我们来给这个项目起一个更具特色和专业性的名字，并围绕它进行包装，让它在众多“XX点评”中显得与众不同。

一个好的项目名应该简洁、有寓意，并能体现出项目的核心技术或业务特点。
 

**我们以 `Pulse` 为例，下面是如何围绕这个名字进行全方位包装。**

### 项目包装方案 (以 `Pulse` 为例)

**项目名称**: **Pulse - 高可用城市消费实时推荐系统**

**一句话介绍 (Elevator Pitch)**:

> ==一个基于Go语言构建的、具备高并发处理能力的城市生活服务平台。项目核心在于通过实时的商户推荐、优惠券秒杀和用户动态分享，打造一个能应对瞬时流量洪峰的现代化后端系统。==

**简历上的项目描述**:

不再是“仿写XX点评”，而是：

> **Pulse - 高可用城市消费实时推荐系统**
> 
> - **项目简介**: 该项目是一个为城市生活服务设计的、支持高并发场景的后端系统。它通过聚合精品商户、提供限时秒杀优惠、并构建用户分享社区，旨在为用户提供实时的消费决策支持。项目整体采用微服务友好（Service-Oriented）的架构，注重性能、稳定性和工程化质量。
>     
> - **核心职责**:
>     
>     - **设计并实现**了项目的整体分层架构（Handler/Service/Repository），通过 **Google Wire** 进行依赖注入，保证了代码的高内聚、低耦合。
>         
>     - **攻克秒杀场景下的高并发难题**：自主设计并实现了基于 **Redis Lua + 消息队列** 的分布式秒杀方案，通过压测验证，系统QPS（每秒查询率）达到10,000+，且保证了数据零超卖。
>         
>     - **优化核心查询性能**: 利用 **Redis GEO** 实现“附近商铺”功能，将地理位置查询延迟从秒级优化至毫秒级。利用 **Bitmap** 实现高效的用户签到统计，百万用户月签到数据仅占用数十KB空间。
>         
>     - **构建系统可观测性**: 引入 **Prometheus** 进行核心指标监控，并集成 **OpenTelemetry** 实现全链路追踪，显著提升了线上问题排查和性能分析的效率。
>         
>     - **保障系统可靠性**: 设计并实现了消息队列的**重试与死信队列（DLQ）机制**，确保了在下游服务（如数据库）临时故障时，核心业务消息不丢失，提升了系统的整体健壮性。
>         

**面试时的项目介绍**:

> “面试官您好，我想介绍一下我的项目`Pulse`。它是一个我独立设计和开发的高可用城市消费推荐系统。”
> 
> “做这个项目的初衷，是我想挑战并解决一个真实世界中常见的复杂场景——**高并发**。所以我没有把它当成一个简单的CURD（增删改查）项目，而是将**秒杀优惠券**作为了系统的核心功能进行攻坚。”
> 
> “为了实现这个目标，我设计了一套**多级流量处理架构**。首先，在流量入口，我通过Redis和Lua脚本构建了一个资格预校验层，原子化地处理库存和用户限购问题，将绝大部分无效流量挡在数据库之前。对于通过校验的流量，我没有直接操作数据库，而是利用Redis Streams作为**消息队列进行异步化削峰**，由后端消费者平稳地进行订单持久化。这套架构不仅支撑了很高的并发量，也解耦了核心业务流程。”
> 
> “在解决了核心的并发问题后，我进一步从**工程化**的角度对项目进行了完善。比如，我引入了**Prometheus和OpenTelemetry**来构建监控和链路追踪，因为我认为一个无法观测的系统是不可靠的。我还为消息队列设计了**死信队列**，来应对消费者可能出现的持续性失败。在性能方面，我也使用Redis的**GEO和Bitmap**等高级数据结构，对地图搜索和用户签到这类典型功能进行了针对性的优化。”
> 
> “总的来说，通过`Pulse`这个项目，我系统性地实践了高并发架构设计、性能优化、以及后端系统的可观测性和稳定性建设，希望能通过这些实践来展示我对后端工程师岗位所需技能的理解和掌握。”

### 总结

包装的核心在于：

1. **换一个视角**: 从“学生模仿者”转变为“小型系统架构师”。
    
2. **提炼关键词**: **高并发、高可用、性能优化、可观测性、工程化、领域建模**。
    
3. **用数据说话**: “QPS达到1万”、“延迟从800ms降至50ms”，这些量化指标远比“很快”更有冲击力。
    
4. **讲一个故事**: 把你的项目串成一个“发现问题 -> 分析问题 -> 技术选型 -> 解决问题 -> 总结复盘”的完整故事。
    

这样一套组合拳下来，你的项目就不再是“烂大街的XX点评”，而是一个有深度、有亮点、闪耀着你个人技术思考光芒的优秀作品。
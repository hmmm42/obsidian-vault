工厂模式（Factory Pattern）是一种创建型设计模式，它的核心思想是**将对象的创建与使用分离开来**。当你需要根据不同的条件创建不同的对象，但又不想在代码中直接使用 `new` 关键字来实例化它们时，工厂模式就显得非常有用。它让你的代码更灵活、可扩展，并且降低了耦合度。
# 概念
工厂模式的核心思想是：**将“是什么”（接口/抽象）与“怎么做”（具体实现）分离开来。**
### 1\. 抽象产品 (Abstract Product)

**概念：** 抽象产品是一个**接口 (interface)** 或者抽象类（在Go中通常是接口），它定义了所有**具体产品**所共有的行为或属性。它代表了一类产品的通用“蓝图”或“契约”，但它本身不能被实例化。

**通俗例子：** 想象你是一个汽车设计师，你的设计图纸上有一个名为 `Car` 的接口，它规定了所有汽车都必须有 `Drive()`（驾驶）和 `Brake()`（刹车）这两个方法。这张图纸本身不是一辆车，但它定义了所有“车”都必须具备的能力。这里的 `Car` 接口就是“抽象产品”。

**Go 语言代码示例：**

```go
// Shape 是抽象产品，一个接口，定义了所有图形都必须具备的 Draw() 方法。
// 它只定义了“是什么”（可以画），但没定义“怎么画”。
type Shape interface {
	Draw()
}
```

### 2\. 具体产品 (Concrete Product)

**概念：** 具体产品是**抽象产品**的**具体实现**。它是实际被创建出来的、有血有肉的对象。它实现了抽象产品接口中定义的所有方法。

**通俗例子：** 有了 `Car` 的设计图纸后，你可以根据它生产出具体的车型，比如 `ToyotaCamry` 和 `TeslaModelS`。这两款车都是具体的、可以驾驶和刹车的对象。这里的 `ToyotaCamry` 和 `TeslaModelS` 就是“具体产品”。

**Go 语言代码示例：**

```go
// Circle 和 Rectangle 是具体产品，它们都实现了 Shape 接口。
// 它们具体定义了 Draw() 方法“怎么画”。
type Circle struct{}
func (c *Circle) Draw() {
	fmt.Println("Drawing a Circle")
}

type Rectangle struct{}
func (r *Rectangle) Draw() {
	fmt.Println("Drawing a Rectangle")
}
```

### 3\. 抽象工厂 (Abstract Factory)

**概念：** 抽象工厂也是一个**接口 (interface)**。它定义了**创建一系列相关或相互依赖的产品**的方法。它代表了生产线的“总调度”蓝图，但它本身不负责具体的生产。

**通俗例子：** 假设你现在要生产一整套产品，包括汽车和发动机。你可以有一个 `VehicleFactory` 的接口，它规定了所有生产商都必须提供 `CreateCar()` 和 `CreateEngine()` 这两个方法。这个接口就是“抽象工厂”，它定义了可以生产哪一“族”的产品。

**Go 语言代码示例：**

```go
// AbstractFactory 是抽象工厂，一个接口，定义了创建“形状家族”和“颜色家族”产品的方法。
// 它只定义了“可以创建什么”，但没定义“具体创建谁”。
type AbstractFactory interface {
	CreateShape() Shape
	CreateColor() Color
}
```

### 4\. 具体工厂 (Concrete Factory)

**概念：** 具体工厂是**抽象工厂**的**具体实现**。它是实际负责生产产品家族的“车间”。它实现了抽象工厂接口中定义的所有创建方法，并返回具体的产品对象。

**通俗例子：** 有了 `VehicleFactory` 的接口后，你可以有具体的生产商，比如 `ToyotaFactory` 和 `TeslaFactory`。

  * `ToyotaFactory` 实现了 `VehicleFactory` 接口，并负责生产 `ToyotaCamry` 和 `ToyotaEngine`。
  * `TeslaFactory` 实现了 `VehicleFactory` 接口，并负责生产 `TeslaModelS` 和 `TeslaEngine`。
    这里的 `ToyotaFactory` 和 `TeslaFactory` 就是“具体工厂”。

**Go 语言代码示例：**

```go
// BlueFactory 和 RedFactory 是具体工厂，它们都实现了 AbstractFactory 接口。
// BlueFactory 负责生产蓝色的产品家族，RedFactory 负责生产红色的产品家族。
type BlueFactory struct{}
func (bf *BlueFactory) CreateShape() Shape {
	return &BlueCircle{} // 返回一个具体的蓝色产品
}
func (bf *BlueFactory) CreateColor() Color {
	return &BlueColor{} // 返回一个具体的蓝色产品
}

type RedFactory struct{}
func (rf *RedFactory) CreateShape() Shape {
	return &RedCircle{} // 返回一个具体的红色产品
}
func (rf *RedFactory) CreateColor() Color {
	return &RedColor{} // 返回一个具体的红色产品
}
```

通过这些拆解，你可以看到：

  * **抽象产品** 和 **具体产品** 构成了“产品”的体系。
  * **抽象工厂** 和 **具体工厂** 构成了“工厂”的体系。

这四个概念相互协作，共同完成了将对象创建与客户端使用解耦的目的，使得整个系统更加灵活和可扩展。
# 分类
## 1\. 简单工厂模式 (Simple Factory Pattern)

简单工厂模式也称为静态工厂模式，它不属于23种经典设计模式之一，但非常常见。它的特点是**由一个工厂类来负责所有产品的创建**。这个工厂类通常有一个静态方法（在 Go 中就是包级别的函数），根据传入的参数来返回不同类型的产品。

**优点：**

  * **封装性好**：客户端不需要知道具体的创建细节。
  * **使用简单**：只需要调用一个工厂方法即可。

**缺点：**

  * **违反开闭原则**：如果需要增加新产品，就需要修改工厂类中的代码，这会增加维护成本。
  * **工厂职责过重**：所有的创建逻辑都集中在一个工厂中，当产品种类增多时，工厂会变得非常庞大。

### Go 语言实现

假设我们有一个图形接口 `Shape` 和两个具体实现 `Circle` 和 `Rectangle`。

```go
// shape.go
package main

import "fmt"

// Shape 是一个接口，定义了图形的行为
type Shape interface {
	Draw()
}

// Circle 是一个具体的产品
type Circle struct{}

func (c *Circle) Draw() {
	fmt.Println("Drawing a Circle")
}

// Rectangle 是另一个具体的产品
type Rectangle struct{}

func (r *Rectangle) Draw() {
	fmt.Println("Drawing a Rectangle")
}

// SimpleFactory 是简单工厂，负责创建所有产品
func SimpleFactory(shapeType string) Shape {
	switch shapeType {
	case "circle":
		return &Circle{}
	case "rectangle":
		return &Rectangle{}
	default:
		return nil
	}
}

func main() {
	// 使用简单工厂来创建对象，客户端不知道具体是 Circle 还是 Rectangle
	circle := SimpleFactory("circle")
	if circle != nil {
		circle.Draw()
	}

	rectangle := SimpleFactory("rectangle")
	if rectangle != nil {
		rectangle.Draw()
	}

	// 尝试创建不存在的类型
	unknown := SimpleFactory("triangle")
	if unknown == nil {
		fmt.Println("Unknown shape type.")
	}
}
```

-----

## 2\. 工厂方法模式 (Factory Method Pattern)

工厂方法模式是**针对简单工厂模式缺点的改进**。它将对象的创建**抽象化**，让**每个具体产品都有一个对应的工厂**。每个工厂只负责创建一种类型的产品。

**优点：**

  * **符合开闭原则**：增加新产品时，只需要增加一个新的产品类和一个新的工厂类，无需修改现有代码。
  * **职责单一**：每个工厂只负责创建一种产品，代码更清晰、易于维护。

**缺点：**

  * **代码量增加**：每增加一个产品，就需要增加一个对应的工厂，这会导致类的数量膨胀。

### Go 语言实现

我们继续使用上面的例子，这次用工厂方法模式来重构。

```go
// product.go
package main

import "fmt"

// Shape 是产品接口
type Shape interface {
	Draw()
}

// Circle 是具体产品
type Circle struct{}

func (c *Circle) Draw() {
	fmt.Println("Drawing a Circle")
}

// Rectangle 是具体产品
type Rectangle struct{}

func (r *Rectangle) Draw() {
	fmt.Println("Drawing a Rectangle")
}

// Factory 是工厂接口，定义了创建产品的方法
type Factory interface {
	CreateShape() Shape
}

// CircleFactory 是具体工厂，负责创建 Circle
type CircleFactory struct{}

func (cf *CircleFactory) CreateShape() Shape {
	return &Circle{}
}

// RectangleFactory 是具体工厂，负责创建 Rectangle
type RectangleFactory struct{}

func (rf *RectangleFactory) CreateShape() Shape {
	return &Rectangle{}
}

func main() {
	// 创建 Circle 的工厂
	circleFactory := &CircleFactory{}
	circle := circleFactory.CreateShape()
	circle.Draw()

	// 创建 Rectangle 的工厂
	rectangleFactory := &RectangleFactory{}
	rectangle := rectangleFactory.CreateShape()
	rectangle.Draw()
}
```

-----

## 3\. 抽象工厂模式 (Abstract Factory Pattern)

抽象工厂模式是**工厂方法模式的进一步抽象**。它**提供一个接口来创建一系列相关或相互依赖的对象，而无需指定它们具体的类**。它通常用于创建\*\*“家族”**或**“套件”\*\*中的产品。

**优点：**

  * **封装性更好**：可以隔离客户端与具体产品的实现细节。
  * **易于切换产品系列**：当需要更换整个产品系列时，只需要更换一个抽象工厂的具体实现即可。

**缺点：**

  * **扩展困难**：如果要增加一个新的产品类型（比如增加一个新的图形属性，所有工厂都要修改），就必须修改所有抽象工厂和具体工厂的接口，这违反了开闭原则。

### Go 语言实现

假设我们不仅要创建图形，还要创建颜色。图形和颜色可以组成一个“家族”。我们有“蓝色图形家族”和“红色图形家族”。

```go
// product.go
package main

import "fmt"

// Shape 是产品A接口
type Shape interface {
	Draw()
}

// Color 是产品B接口
type Color interface {
	Fill()
}

// BlueCircle 和 RedCircle 是具体产品
type BlueCircle struct{}

func (c *BlueCircle) Draw() {
	fmt.Println("Drawing a Blue Circle")
}

type RedCircle struct{}

func (c *RedCircle) Draw() {
	fmt.Println("Drawing a Red Circle")
}

// BlueColor 和 RedColor 是具体产品
type BlueColor struct{}

func (c *BlueColor) Fill() {
	fmt.Println("Filling with Blue")
}

type RedColor struct{}

func (c *RedColor) Fill() {
	fmt.Println("Filling with Red")
}

// AbstractFactory 是抽象工厂接口
type AbstractFactory interface {
	CreateShape() Shape
	CreateColor() Color
}

// BlueFactory 是具体工厂，创建蓝色家族的产品
type BlueFactory struct{}

func (bf *BlueFactory) CreateShape() Shape {
	return &BlueCircle{}
}

func (bf *BlueFactory) CreateColor() Color {
	return &BlueColor{}
}

// RedFactory 是具体工厂，创建红色家族的产品
type RedFactory struct{}

func (rf *RedFactory) CreateShape() Shape {
	return &RedCircle{}
}

func (rf *RedFactory) CreateColor() Color {
	return &RedColor{}
}

func main() {
	// 创建蓝色工厂，获得蓝色家族的产品
	blueFactory := &BlueFactory{}
	blueShape := blueFactory.CreateShape()
	blueShape.Draw()
	blueColor := blueFactory.CreateColor()
	blueColor.Fill()

	// 创建红色工厂，获得红色家族的产品
	redFactory := &RedFactory{}
	redShape := redFactory.CreateShape()
	redShape.Draw()
	redColor := redFactory.CreateColor()
	redColor.Fill()
}
```

## 总结

| 特性 | 简单工厂模式 | 工厂方法模式 | 抽象工厂模式 |
| :--- | :--- | :--- | :--- |
| **创建方式** | 一个工厂，一个方法，通过参数区分 | 多个工厂，每个工厂负责一个产品 | 多个工厂，每个工厂负责一整个产品家族 |
| **开闭原则** | **违反**，新增产品需改动工厂 | **遵守**，新增产品只需新增工厂和产品 | **违反**，新增产品类型需改动所有接口 |
| **耦合度** | 低 | 极低 | 低 |
| **复杂度** | 最低 | 较高 | 最高 |
| **适用场景** | 产品种类少，且不常变更 | 产品种类多，且经常需要新增产品 | 需要创建一系列相互关联的产品对象 |

希望这个详细的讲解能帮助你更好地理解 Go 语言中的工厂模式。
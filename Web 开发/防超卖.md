![](https://i-blog.csdnimg.cn/direct/70a1f893064f4825bed6997c0143a836.png)
# 乐观锁
实现方式一：**版本号法**

![](https://i-blog.csdnimg.cn/direct/5cdb798cbd2444eb9c6787d53730c638.png)

- 首先我们要为 tb_seckill_voucher 表新增一个版本号字段 version 。线程1查询完库存，在进行库存扣减操作的**同时将版本号+1；**
- 线程2在查询库存时，同时查询出当前的版本号，发现库存充足，也准备执行库存扣减操作，但是需要**判断当前的版本号是否是之前查询时的版本号**，结果发现版本号发生了改变，这就说明数据库中的数据已经发生了修改，需要进行重试或者直接失败。

实现方式二：**CAS法**

![](https://i-blog.csdnimg.cn/direct/72ff21b0bde74f8b98a3091e11200a7a.png)

CAS法类似与版本号法，但是不需要另外在添加一个 version 字段，而是**直接使用库存替代版本号**。

线程1查询完库存后进行库存扣减操作，线程2在查询库存时，发现库存充足，也准备执行库存扣减操作，但是需要**判断当前的库存是否是之前查询时的库存**，结果发现库存数量发生了改变，这就说明数据库中的数据已经发生了修改，需要进行重试或直接失败。

**拓展：**

CAS（Compare and Swap）是一种并发编程中常用的原子操作，用于解决多线程环境下的数据竞争问题。它是乐观锁算法的一种实现方式。

CAS操作包含三个参数：**内存地址V**、**旧的预期值A**和**新的值B**。CAS的执行过程如下：

1. 比较（Compare）：将内存地址V中的值与预期值A进行比较。
2. 判断（Judgment）：如果相等，则说明当前值和预期值相等，表示没有发生其他线程的修改。
3. 交换（Swap）：使用新的值B来更新内存地址V中的值。

CAS操作是一个原子操作，意味着在执行过程中不会被其他线程中断，保证了线程安全性。如果CAS操作失败（即当前值与预期值不相等），通常会进行重试，直到CAS操作成功为止。

CAS操作适用于精细粒度的并发控制，可以避免使用传统的加锁机制带来的性能开销和线程阻塞。然而，CAS操作也存在一些限制和注意事项：

- ABA问题：CAS操作无法感知到对象值从A变为B又变回A的情况，可能会导致数据不一致。为了解决ABA问题，可以引入版本号或标记位等机制。
- 自旋开销：当CAS操作失败时，需要不断地进行重试，会占用CPU资源。如果重试次数过多或者线程争用激烈，可能会引起性能问题。
- 并发性限制：如果多个线程同时对同一内存地址进行CAS操作，只有一个线程的CAS操作会成功，其他线程需要重试或放弃操作。

综上所述，使用CAS法要更加好，能够避免额外的内存开销，而对于我们的需求，需要修改代码的地方也很少的。
做法
```Go
		info, err := tx.TbSeckillVoucher.Where(tx.TbSeckillVoucher.VoucherID.Eq(uint64(voucherId)), tx.TbSeckillVoucher.Stock.Eq(voucher.Stock)).UpdateSimple(tx.TbSeckillVoucher.Stock.Add(-1))
```
## 增加成功率修改
修改一下判断条件，即只要库存大于0就可以进行修改，而不是发现库存量已被修改就终止操作。
# 悲观锁
简单的，使用MySql的锁。我们在查库存的时候，锁住需要查看的该行，都不给其他用户查看。等到自己扣减完库存，创建了订单后才开放给别人。即是把查看库存的操作也加入事务，并且是使用select ... FOR UPDATE。这种是排它锁，不允许他人查看，也不允许修改。

或者使用go语言的 sync.Mutex。这两种都是悲观锁，这样就是串行运行，性能较差。
# redis Lua 脚本
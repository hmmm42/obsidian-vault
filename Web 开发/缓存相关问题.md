# 缓存雪崩
大量数据在 redis 中 **不存在**, 大量请求直接访问数据库
- 冷启动: 提前预热, 写入热数据 *但可能导致 大量数据同时过期*
- 大量数据同时过期: 
	- 设计随机过期时间
	- 互斥锁, 保证同一个时间只有一个请求构建缓存
	- 定时更新缓存 + 后台线程检测缓存是否有效 / 缓存失效后通知后台更新缓存
# 缓存崩溃
redis 宕机
- 服务熔断, 停止对 db 的访问, 为 redis 提供恢复时间
- 部署高可用集群, 主从节点
# 缓存击穿
**热点数据过期**, 大量请求直接访问数据库
*情况与缓存雪崩类似*
- 互斥锁: 获取不到锁的线程 退避重试 or 直接返回404 or 维护本地缓存
- 定时更新缓存
# 缓存穿透
请求数据在缓存和数据库中 **都不存在**, 直接访问数据库
原因: 业务误操作, 恶意攻击
- 提前限制非法请求
- 缓存空对象
- 布隆过滤器: 预先存储所有合法的 key, 请求时先判断 key 是否存在
# 缓存数据一致性
## 更新数据库+更新缓存
并发时数据不一致
*解决: 分布式锁+过期时间* 
## 删除缓存+更新数据库
可能导致数据不一致(删除后查询到为空, 访问数据库获得旧数据)
*解决: 延迟双删 更新数据库后, 睡眠一段时间再删一次*
## 更新数据库+删除缓存
最优 **缓存的写入通常要远远快于数据库的写入**
如果删除缓存时失败, 会出现短暂数据不一致(依靠过期时间兜底)
*解决: 消息队列重试 / 订阅 MySQL binlog*

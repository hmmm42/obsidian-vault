# 问题
并发带来3种问题:
- **脏读：** 一个事务读取了另一个**未提交**事务所做的修改。如果后一个事务回滚，那么前一个事务读取的数据就是无效的。
- **不可重复读：** 在同一个事务中，多次读取**同一行**数据，但得到的结果不同。这是因为在两次读取之间，另一个**已提交**的事务修改了这一行数据。
- **幻读：** 在同一个事务中，多次执行同一个**查询**（通常是范围查询），但得到的结果集不同。这是因为在两次查询之间，另一个**已提交**的事务**插入或删除了**符合查询条件的**行**。

锁带来3种问题:
- **活锁 (Livelock)**：一个事务因其他事务持续地抢先获得锁，而导致自己永远处于等待状态，无法继续执行。
- **饿死 (Starvation)**：一个事务的请求被无限期推迟，永远无法获得所需的资源。这通常发生在锁的授权策略不公平时
- **死锁 (Deadlock)**：两个或多个事务形成了一个循环等待链，每个事务都在等待另一个事务释放它所需要的锁。
# 事务
==ACID（Atomicity、Consistency、Isolation、Durability)
原子性、一致性、隔离性、持久性）==
*ACID 靠什么保证*
- A: undo log日志, 保证成功回滚, 一起成功一起失败
- C: 靠其他三大特性, 靠业务代码
- I: MVCC, 多版本并发控制
- D: 内存 + redo log, 修改时在buffer, 提交后redo log落盘, 异步刷脏数据
4种隔离级别 :
- **读未提交**: 一个事务还没提交时，它做的变更就能被别的事务看到。
- **读提交**: 一个事务提交之后，它做的变更才会被其他事务看到。
- **可重复读**: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- **串行化**: 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

| 隔离级别             | 脏读       | 不可重复读    | 幻读              |
| ---------------- | -------- | -------- | --------------- |
| Read Uncommitted | Yes (允许) | Yes (允许) | Yes (允许)        |
| Read Committed   | No (避免)  | Yes (允许) | Yes (允许)        |
| Repeatable Read  | No (避免)  | No (避免)  | No (避免) (MySQL) |
| Serializable     | No (避免)  | No (避免)  | No (避免)         |

# 事务隔离
整库的快照 **Read View**
- 读提交: 每个语句执行前生成
- 可重复读: 启动事务时生成
```sql
start transaction with consistent snapshot
```

每个事务有唯一的事务 ID, 按申请顺序递增
数据表中的一行记录包含隐藏列:
- trx_id, 一个事务对某条聚簇索引记录进行改动时, 就会**把该事务的事务 id 记录在 trx_id 隐藏列里**
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

Read View 的4个字段:
![readview结构.drawio.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/picturesreadview结构.drawio.webp)


![ReadView.drawio.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/picturesReadView.drawio.webp)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：
    - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
    - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。
    - *为什么还需要 m_ids 判断: min_trx_id 取决于最早未提交的事务, 可能有稍晚启动但是已经提交的*
==更新除外: 当前读永远只能读当前的值==
==但是 InnoDB 通过间隙锁的方式避免了可重复读的幻读: 两次当前读之间, 其他事务想更新会被锁住==
## 更新逻辑
**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）**
# 幻读
- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁 + 间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

不能避免幻读的场景:
第一个例子：对于快照读，MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。

第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。
==总结: 同一个事务里混合使用 快照读, 当前读==
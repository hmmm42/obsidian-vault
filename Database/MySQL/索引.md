InnoDB 使用 [[Database/存储结构/B+ 树|B+ 树]]
尽量使用主键查询 
**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
如果重建主键, 会重建整个表

# 最左前缀原则
建立联合索引后, 不需要对最左前缀再建立索引

# 索引下推
在索引查找的过程中, 先在**联合索引**中进行过滤, 再在数据表中进行过滤
![76e385f3df5a694cc4238c7b65acfe1b.jpg](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures76e385f3df5a694cc4238c7b65acfe1b.jpg)

# 类型
- 普通索引: 找到满足的记录后继续查找, 直到不满足
- 唯一索引: 找到满足的记录后停止查找
## change buffer
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还**不在内存**中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。
*change buffer 同时写入到内存和磁盘*

**change buffer**只对普通索引生效: *唯一索引要将数据页读入内存才能判断唯一性*
尽量选择**普通索引**
==写多读少的业务, change buffer 收益最高==
如果更新模式是 写入之后马上会做查询, change buffer 会起副作用

对比[[日志#redo log|redo log]]:
redo log 主要节省的是**随机写**磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是**随机读**磁盘的 IO 消耗。

# 选择
优化器通过索引上不同的值的个数(**基数**), 来判断索引的区分度
方法: 采样统计
默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。
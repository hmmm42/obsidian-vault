![0d2070e8f84c4801adbfa03bda1f98d9.png](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures0d2070e8f84c4801adbfa03bda1f98d9.png)
默认引擎为 **InnoDB**
不同引擎同用一个 **Server 层**

8.0 开始删除查询缓存
更新压力大时, 查询缓存命中率低
静态表适合 **查询缓存**
# 比较两种引擎
MySQL 中最常用的两个存储引擎是 **InnoDB** 和 **MyISAM**.

|特性|InnoDB|MyISAM|
|---|---|---|
|**事务 (Transaction)**|**支持**. 遵循 ACID 模型, 支持提交 (Commit), 回滚 (Rollback), 崩溃恢复.|**不支持**.|
|**锁级别 (Locking)**|**行级锁 (Row-level Lock)**. 也支持表锁. 行级锁在高并发写入时冲突更小, 性能更好.|**表级锁 (Table-level Lock)**. 对表进行写操作时, 会锁定整张表, 并发性能差.|
|**外键 (Foreign Key)**|**支持**.|**不支持**.|
|**崩溃恢复**|**支持**. 通过 redo log 和 undo log 实现.|**不支持**. 容易损坏.|
|**默认引擎**|**是** (从 MySQL 5.5 开始).|否 (早期版本的默认引擎).|
|**索引结构**|**聚簇索引**. 数据文件本身就是按 B+Tree 组织的索引文件, 叶子节点直接存储行数据.|**非聚簇索引**. 索引 (B+Tree) 和数据是分开的, 索引的叶子节点存储的是数据行的地址.|
|**`SELECT COUNT(*)`**|需要扫描全表或全索引, 速度较慢.|内部维护了一个行数计数器, 如果没有 `WHERE` 条件, 查询非常快.|
|**适用场景**|需要事务和高并发写入的场景, 如订单系统, 金融系统, 是绝大多数应用的首选.|读密集, 写较少, 对事务完整性要求不高的场景, 如日志表. 但现在已逐渐被 InnoDB 取代.|
# 存储方式
表结构: 「 表名字.frm 」
表数据: 「 表名字.ibd 」

==B+树的非叶子节点是索引页, 叶子节点是数据页, 页内用页表+链表存储==
表空间结构: 段 -> 区 -> 页 -> 行

## 段
- 索引段：存放 B + 树的**非叶子节点**的区的集合；
- 数据段：存放 B + 树的**叶子节点**的区的集合；
- 回滚段：存放的是回滚数据的区的集合
## 区
数据量大时, 连续的64个16KB页划分为一个区(1MB), 保证相邻的页的物理位置相邻
## 页
InnoDB 按页为单位读写, 每页大小为 16KB
读一条数据时, 将整个页读入内存
## 行
行格式: 默认使用 `Dynamic`, 基于 `Compact` 进行优化
- 如果没有变长字段, 不需要 变长字段长度列表
- 全部是 `NOT NULL`, 不需要 NULL 值列表
![COMPACT.drawio.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/picturesCOMPACT.drawio.webp)
### 变长字段长度列表
变长字段长度信息 **逆序存放**, 即 列n...列1
不存放 NULL 值长度
逆序存放原因: 记录头信息中指向下一个记录的指针, 指向「记录头信息」和「真实数据」之间的位置, 向左读是头信息, 向右读是真实数据, 提高 **CPU Cache 缓存命中率**
> 让 **第一个变长字段 (D_1) 的数据** 和其对应的**长度信息 (L_1)** 在内存中的物理位置上尽可能靠近。这样，当 CPU 访问 `D_1` 时，利用 CPU Cache 的空间局部性原理，更有可能同时将 `L_1` 也加载到 Cache 中，从而在后续需要 `L_1` 时实现 Cache Hit，提高数据解析的效率。这个原理同样适用于后续的 `D_i` 和 `L_i`。

### NULL 值列表
同样 **逆序存放**
类似`bitMap`形式, 二进制位值是1表示NULL, 0表示NOT NULL

### 头信息
- delete_mask：标识此条数据是否被删除。执行 detele 删除时将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录
### 真实数据
- row_id: 没有主键且没有唯一约束时, 添加`row_id`字段, 非必需
- trx_id: 事务 ID, 必须 [[事务#事务隔离]]
- roll_pointer: 回滚指针, 必须

# VARCHAR
一行数据最大长度为`65535`字节
`varchar(n)`类型, `n`表示最大字符数量, `n`的最大值需减去附加信息
eg. UTF-8, `n`最大值为 `(65535-2)/3 = 21844`
**所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 <= 65535**

# TEXT
相比 `VARCHAR`, 没有长度限制
无法对整个列创建索引
实际数据存储在 **溢出页** 

## 行溢出
真实数据处存储指向溢出页的地址
- Compact: 溢出页存储部分剩余数据
- Compressed/Dynamic: 溢出页存储**全部数据**

# COUNT
性能对比: `count(*)` = `count(1)` > `count(主键字段)` > `count(普通字段)`
*count()统计指定指定的参数不为 NULL 的有多少个*

统计过程:
server 层维护一个`count`变量, 每读取一条记录且符合条件, `count++`
遍历时会优先选择 **二级索引**: 占用空间小, I/O 次数少
`count(*)`会自动优化成`count(0)`
`count(普通字段)`需要全表扫描, 效率最低

## 优化`COUNT(*)`
- 近似值: `SHOW TABLE STATUS`/`EXPLAIN`
- 额外维护计数值
# 存储引擎
![0d2070e8f84c4801adbfa03bda1f98d9.png](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures0d2070e8f84c4801adbfa03bda1f98d9.png)
默认引擎为 **InnoDB**
不同引擎同用一个 **Server 层**

8.0 开始删除查询缓存
更新压力大时, 查询缓存命中率低
静态表适合 **查询缓存**
## 比较

|特性|InnoDB|MyISAM|
|---|---|---|
|**事务 (Transaction)**|**支持**. 遵循 ACID 模型, 支持提交 (Commit), 回滚 (Rollback), 崩溃恢复.|**不支持**.|
|**锁级别 (Locking)**|**行级锁 (Row-level Lock)**. 也支持表锁. 行级锁在高并发写入时冲突更小, 性能更好.|**表级锁 (Table-level Lock)**. 对表进行写操作时, 会锁定整张表, 并发性能差.|
|**外键 (Foreign Key)**|**支持**.|**不支持**.|
|**崩溃恢复**|**支持**. 通过 redo log 和 undo log 实现.|**不支持**. 容易损坏.|
|**默认引擎**|**是** (从 MySQL 5.5 开始).|否 (早期版本的默认引擎).|
|**索引结构**|**聚簇索引**. 数据文件本身就是按 B+Tree 组织的索引文件, 叶子节点直接存储行数据.|**非聚簇索引**. 索引 (B+Tree) 和数据是分开的, 索引的叶子节点存储的是数据行的地址.|
|**`SELECT COUNT(*)`**|需要扫描全表或全索引, 速度较慢.|内部维护了一个行数计数器, 如果没有 `WHERE` 条件, 查询非常快.|
|**适用场景**|需要事务和高并发写入的场景, 如订单系统, 金融系统, 是绝大多数应用的首选.|读密集, 写较少, 对事务完整性要求不高的场景, 如日志表. 但现在已逐渐被 InnoDB 取代.|
# 数据结构
### 1. 数值类型
数值类型是用来存储数字的，它们又可以细分为整数、浮点数和定点数。选择合适的数值类型能有效节省存储空间，提高查询效率。
- **整数类型（Integer Types）**
    - **TINYINT**: 占用 1 字节，存储范围很小，适合存一些状态标志（比如 `0`、`1`）。
    - **SMALLINT**: 占用 2 字节，比 `TINYINT` 大一些，适合存一些计数（比如用户的好友数）。
    - **MEDIUMINT**: 占用 3 字节。
    - **INT**: 占用 4 字节，这是最常用的整数类型。
    - **BIGINT**: 占用 8 字节，适合存那些可能超出 `INT` 范围的大数字，比如用户 ID（如果用户数量巨大）或时间戳。
- **浮点数类型（Floating-Point Types）**
    - **FLOAT**: 占用 4 字节，单精度浮点数，存储带有小数的数字。由于是浮点数，可能会有精度问题。
    - **DOUBLE**: 占用 8 字节，双精度浮点数，比 `FLOAT` 精度更高，同样可能存在精度问题。
- **定点数类型（Fixed-Point Types）**
    - **DECIMAL**: 存储精确的数字，常用于需要高精度的财务计算。你可以指定总位数和小数位数，比如 `DECIMAL(5, 2)` 表示总共 5 位，其中 2 位是小数。`DECIMAL` 类型的存储空间是动态的，根据你设定的位数来决定。
---
### 2. 字符串类型
字符串类型用来存储文本数据。选择的关键在于数据长度是否固定。
==字符转数字, 都转成0==
- **CHAR**
    - **固定长度**的字符串。当你定义 `CHAR(10)` 时，无论你存入的字符串是 5 个字符还是 10 个字符，它都会占用 10 个字节的存储空间。
    - 优点：存取速度快。
    - 缺点：浪费空间。适合存储姓名、电话号码、邮政编码等长度固定的数据。
- **VARCHAR**
    - **可变长度**的字符串。当你定义 `VARCHAR(10)`，如果只存入 5 个字符，它实际占用的空间是 5 个字符的长度加上 1 或 2 个字节来存储字符串的长度信息。
    - 优点：节省空间。
    - 缺点：存取速度相对 `CHAR` 略慢。这是最常用的字符串类型，适合存储地址、简介等长度不固定的数据。
- **TEXT 和 BLOB**
    - 用于存储**大文本或二进制数据**。
    - **TEXT**: 存储大文本数据，如文章内容、长篇评论等。根据长度有 `TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT` 等。
    - **BLOB**: 存储二进制数据，如图片、音频、视频等文件。同样有不同大小的类型。
    - **重要提醒**：一般不建议直接在数据库中存储大文件，更好的做法是存储文件的路径，把文件本身放在文件服务器上。
---
### 3. 日期/时间类型
日期/时间类型用来存储与时间相关的数据。
- **DATE**: 存储日期，格式为 'YYYY-MM-DD'。
- **TIME**: 存储时间，格式为 'HH:MM:SS'。
- **YEAR**: 存储年份，格式为 'YYYY'。
- **DATETIME**: 存储日期和时间，格式为 'YYYY-MM-DD HH:MM:SS'。存储范围比 `TIMESTAMP` 大。
- **TIMESTAMP**: 存储日期和时间，格式和 `DATETIME` 相同。但它的存储范围有限制，且在插入或更新时可以**自动更新**。此外，`TIMESTAMP` 还会受到时区影响，而 `DATETIME` 不会。
### 如何选择数据类型？
1. **越小越好**：在满足业务需求的前提下，尽量选择占用空间最小的数据类型。
2. **固定长度用 `CHAR`，可变长度用 `VARCHAR`**：如果字符串长度固定，`CHAR` 效率更高；否则，`VARCHAR` 更能节省空间。
3. **精确计算用 `DECIMAL`**：涉及到金钱等需要精确计算的场景，千万不要用 `FLOAT` 或 `DOUBLE`，应该用 `DECIMAL`。
4. **根据业务需求选择日期类型**：如果需要自动更新时间戳或存储近期的日期，`TIMESTAMP` 是个好选择；如果需要存储更久远或不受时区影响的日期，`DATETIME` 更合适。
# 存储方式
表结构: 「 表名字.frm 」
表数据: 「 表名字.ibd 」

==B+树的非叶子节点是索引页, 叶子节点是数据页, 页内用页表+链表存储==
表空间结构: 段 -> 区 -> 页 -> 行

## 段
- 索引段：存放 B + 树的**非叶子节点**的区的集合；
- 数据段：存放 B + 树的**叶子节点**的区的集合；
- 回滚段：存放的是回滚数据的区的集合
## 区
数据量大时, 连续的64个16KB页划分为一个区(1MB), 保证相邻的页的物理位置相邻
## 页
InnoDB 按页为单位读写, 每页大小为 16KB
读一条数据时, 将整个页读入内存
## 行
行格式: 默认使用 `Dynamic`, 基于 `Compact` 进行优化
- 如果没有变长字段, 不需要 变长字段长度列表
- 全部是 `NOT NULL`, 不需要 NULL 值列表
![COMPACT.drawio.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/picturesCOMPACT.drawio.webp)
### 变长字段长度列表
变长字段长度信息 **逆序存放**, 即 列n...列1
不存放 NULL 值长度
逆序存放原因: 记录头信息中指向下一个记录的指针, 指向「记录头信息」和「真实数据」之间的位置, 向左读是头信息, 向右读是真实数据, 提高 **CPU Cache 缓存命中率**
> 让 **第一个变长字段 (D_1) 的数据** 和其对应的**长度信息 (L_1)** 在内存中的物理位置上尽可能靠近。这样，当 CPU 访问 `D_1` 时，利用 CPU Cache 的空间局部性原理，更有可能同时将 `L_1` 也加载到 Cache 中，从而在后续需要 `L_1` 时实现 Cache Hit，提高数据解析的效率。这个原理同样适用于后续的 `D_i` 和 `L_i`。

### NULL 值列表
同样 **逆序存放**
类似`bitMap`形式, 二进制位值是1表示NULL, 0表示NOT NULL

### 头信息
- delete_mask：标识此条数据是否被删除。执行 detele 删除时将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录
### 真实数据
- row_id: 没有主键且没有唯一约束时, 添加`row_id`字段, 非必需
- trx_id: 事务 ID, 必须 [[事务#事务隔离]]
- roll_pointer: 回滚指针, 必须

# VARCHAR
一行数据最大长度为`65535`字节
`varchar(n)`类型, `n`表示最大字符数量, `n`的最大值需减去附加信息
eg. UTF-8, `n`最大值为 `(65535-2)/3 = 21844`
**所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 <= 65535**

# TEXT
相比 `VARCHAR`, 没有长度限制
无法对整个列创建索引
实际数据存储在 **溢出页** 

## 行溢出
真实数据处存储指向溢出页的地址
- Compact: 溢出页存储部分剩余数据
- Compressed/Dynamic: 溢出页存储**全部数据**

# COUNT
性能对比: `count(*)` = `count(1)` > `count(主键字段)` > `count(普通字段)`
*count()统计指定指定的参数不为 NULL 的有多少个*

统计过程:
server 层维护一个`count`变量, 每读取一条记录且符合条件, `count++`
遍历时会优先选择 **二级索引**: 占用空间小, I/O 次数少
`count(*)`会自动优化成`count(0)`
`count(普通字段)`需要全表扫描, 效率最低

## 优化`COUNT(*)`
- 近似值: `SHOW TABLE STATUS`/`EXPLAIN`
- 额外维护计数值
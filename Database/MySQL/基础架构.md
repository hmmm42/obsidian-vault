![0d2070e8f84c4801adbfa03bda1f98d9.png](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures0d2070e8f84c4801adbfa03bda1f98d9.png)
默认引擎为 **InnoDB**
不同引擎同用一个 **Server 层**

8.0 开始删除查询缓存
更新压力大时, 查询缓存命中率低
静态表适合 **查询缓存**

# 存储方式
表结构: 「 表名字.frm 」
表数据: 「 表名字.ibd 」

表空间结构: 段 -> 区 -> 页 -> 行

## 段
- 索引段：存放 B + 树的**非叶子节点**的区的集合；
- 数据段：存放 B + 树的**叶子节点**的区的集合；
- 回滚段：存放的是回滚数据的区的集合
## 区
数据量大时, 连续的64个16KB页划分为一个区(1MB), 保证相邻的页的物理位置相邻
## 页
InnoDB 按页为单位读写, 每页大小为 16KB
读一条数据时, 将整个页读入内存
## 行
行格式: 默认使用 `Dynamic`, 基于 `Compact` 进行优化
- 如果没有变长字段, 不需要 变长字段长度列表
- 全部是 `NOT NULL`, 不需要 NULL 值列表
![COMPACT.drawio.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/picturesCOMPACT.drawio.webp)
### 变长字段长度列表
变长字段长度信息 **逆序存放**, 即 列n...列1
不存放 NULL 值长度
逆序存放原因: 记录头信息中指向下一个记录的指针, 指向「记录头信息」和「真实数据」之间的位置, 向左读是头信息, 向右读是真实数据, 提高 **CPU Cache 缓存命中率**
> 让 **第一个变长字段 (D_1) 的数据** 和其对应的**长度信息 (L_1)** 在内存中的物理位置上尽可能靠近。这样，当 CPU 访问 `D_1` 时，利用 CPU Cache 的空间局部性原理，更有可能同时将 `L_1` 也加载到 Cache 中，从而在后续需要 `L_1` 时实现 Cache Hit，提高数据解析的效率。这个原理同样适用于后续的 `D_i` 和 `L_i`。

### NULL 值列表
同样 **逆序存放**
类似`bitMap`形式, 二进制位值是1表示NULL, 0表示NOT NULL

### 头信息
- delete_mask：标识此条数据是否被删除。执行 detele 删除时将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录
### 真实数据
- row_id: 没有主键且没有唯一约束时, 添加`row_id`字段, 非必需
- trx_id: 事务 ID, 必须 [[事务#事务隔离]]
- roll_pointer: 回滚指针, 必须

# VARCHAR
一行数据最大长度为`65535`字节
`varchar(n)`类型, `n`表示最大字符数量, `n`的最大值需减去附加信息
eg. UTF-8, `n`最大值为 `(65535-2)/3 = 21844`
**所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 <= 65535**

# TEXT
相比 `VARCHAR`, 没有长度限制
无法对整个列创建索引
实际数据存储在 **溢出页** 

## 行溢出
真实数据处存储指向溢出页的地址
- Compact: 溢出页存储部分剩余数据
- Compressed/Dynamic: 溢出页存储**全部数据**
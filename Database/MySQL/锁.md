# 全局锁
全库逻辑备份, 把整库每个表都 select 出来存成文本
```SQL
Flush tables with read lock
```

# 表级锁
## 表锁
在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

## 元数据锁 MDL
不显式使用
- 对一个表做增删改查操作的时候，加 MDL 读锁 *可以有多个线程同时对一张表增删改查*
- 对表做结构变更操作的时候，加 MDL 写锁

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个**事务提交后**再释放。

考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```
## 意向锁
对行记录添加S锁, X锁之前, 会对表添加 IS锁, IX锁
**意向锁之间不互斥, 只和表级S锁, X锁互斥**
*快速判断表中是否有记录被加锁*
## AUTO-INC 锁
插入数据时添加, 为`AUTO_INCREMENT`字段赋值, 插入执行完后释放
会影响性能
额外提供机制: 互斥量 Mutex, 用于取代 AUTO-INC 锁
`AUTO_INCREMENT`赋值后立刻释放, **可能主从不一致, 需要设置`binlog_format = row`**
修改`innodb_autoinc_lock_mode`来决定
默认情况下:
- 插入行数可确定: Mutex
- 插入行数不可确定: AUTO-INC 锁
# 行锁
## Record Lock
需要的时候加上, 事务提交后释放 ==两阶段锁协议==
分为读锁, 写锁 (S Lock, X Lock)
- S Lock: `select ... lock in share mode`
- X Lock: `select ... for update`
### 唯一键
- 索引存在, 只锁定当前行
- 索引不存在, 会锁住指定位置的空隙, 有缺口则用无穷补上
### 普通索引
- 索引存在, 锁定当前行+周围空隙, 找到第一个不符合条件的索引退化为间隙锁
- 索引不存在, 锁定当前行+周围空隙
### 无索引
锁定全表
## Gap Lock
- **可重复读**级别, 防止位于范围内事务id的记录插入, 解决幻读问题
- 用于 Next-Key Lock 锁住区间间隙
==两个间隙锁互不冲突==
## Next-Key Lock
Record Lock + Gap Lock
## 插入意向锁
==和意向锁区分==
插入一条记录时，判断插入位置是否已被其他事务加了间隙锁
如果有则阻塞, 直到间隙锁释放, 期间生成插入意向锁 *可以理解为特殊的间隙锁*
## 总结
好的, 我们来对这几种锁进行一次全面和系统的总结, 特别是厘清它们之间的关系和区别.
这次总结将围绕四个核心锁类型展开:
1. **记录锁 (Record Lock)**
2. **间隙锁 (Gap Lock)**
3. **临键锁 (Next-Key Lock)**
4. **插入意向锁 (Insert Intention Lock)**
### 一. 锁的个案分析 (Detailed Profiles)
#### 1. 记录锁 (Record Lock)
- **锁定目标:** 单个 **索引记录 (index record)**.
- **阻塞行为:** 阻塞其他事务对这一个特定索引记录的 `UPDATE`, `DELETE`, 以及 `SELECT ... FOR UPDATE/SHARE`.
- **主要目的:** 保护一个已存在的, 精确匹配的行, 防止其被并发修改. 这是最基本, 粒度最细的行锁.
#### 2. 间隙锁 (Gap Lock)
- **锁定目标:** 两个索引记录之间的 **开区间 (gap)**, 或者索引树的第一个记录之前/最后一个记录之后的空间.
- **阻塞行为:** 阻塞其他事务在这个间隙内的 `INSERT` 操作. **它不阻塞任何对已存在记录的读写**. 间隙锁之间是互相兼容的, 不同的事务可以同时持有同一个间隙的间隙锁.
- **主要目的:** 防止其他事务在某个范围内插入新数据, 从而避免 **幻读 (Phantom Reads)**. 它本身不锁定任何记录.
#### 3. 临键锁 (Next-Key Lock)
- **锁定目标:** **记录锁 + 间隙锁的组合**. 它锁定一个索引记录本身, 以及这个记录之前的那个间隙. 这是一个 **左开右闭** 的区间.
- **阻塞行为:** 既阻塞其他事务对该记录的修改 (`Record Lock` 的功能), 也阻塞其他事务在其前方间隙的插入 (`Gap Lock` 的功能).
- **主要目的:** 这是 InnoDB 在 `REPEATABLE READ` 隔离级别下的 **默认行锁算法**, 是解决幻读问题的主要功臣.
#### 4. 插入意向锁 (Insert Intention Lock)
- **锁定目标:** 这是一种特殊的 **间隙锁**, 它在 `INSERT` 操作执行之前设置.
- **阻塞行为:**
    - 插入意向锁 **之间互不冲突**. 多个事务可以同时在同一个间隙中持有插入意向锁, 只要它们插入的位置不冲突 (例如, 不插入重复的键值).
    - 它会被其他事务持有的 **间隙锁 (Gap Lock)** 或 **临键锁 (Next-Key Lock)** 所阻塞. 一个事务在尝试获取插入意向锁时, 如果发现该间隙已被其他事务的 Gap/Next-Key 锁占据, 则必须等待.
- **主要目的:** 提高 `INSERT` 操作的并发性. 如果没有插入意向锁, 那么当一个事务正在一个间隙中插入时, 其他任何事务都不能在该间隙中进行任何插入. 有了它, 多个不冲突的插入可以并发执行.
---
### 二. 宏观视角: InnoDB 的行锁策略与总结
InnoDB 的行锁策略可以理解为一个 **以 "临键锁" 为基准, 动态优化调整** 的智能系统.
1. 默认武器: 临键锁 (Next-Key Lock)
    在 REPEATABLE READ 隔离级别下, 为了彻底杜绝幻读, InnoDB 在扫描索引时, 默认使用的武器就是临键锁. 它既锁定了扫描到的记录, 又锁定了记录之前的范围, 确保万无一失.
2. 智能优化: 锁的"退化"
    虽然临键锁很安全, 但它锁定的范围过大可能会影响并发. 因此, InnoDB 会在保证数据一致性的前提下, 对锁进行"降级"或"优化":
    - **退化为记录锁:** 当查询使用的是 **主键或唯一索引**, 并且是 **等值查询**, 且能精确匹配到 **唯一的一条** 记录时, InnoDB 会判断这个查询不会产生幻读. 此时, 强大的临键锁就会退化成一个精准的 **记录锁**, 只锁定这一行, 把对其他空间的锁定全部释放, 以最大化并发.
    - **退化为间隙锁:** 当查询的记录 **不存在** 时, 或者在某些扫描场景下, 为了防止插入, InnoDB 只需要锁定间隙即可, 此时临键锁中"记录锁"的部分就没有意义了, 会退化成一个纯粹的 **间隙锁**.
3. 特殊场景: 插入操作的并发优化
    对于 INSERT 操作, 它也需要检查目标间隙是否已被锁定. 如果没有被 Gap/Next-Key 锁占据, 它不会粗暴地直接加上一个排他的 Gap 锁, 而是先设置一个 插入意向锁. 这个锁像一个"通行证", 告诉系统 "我准备在这里插入, 但我不会阻止其他也想插入的事务", 从而允许多个插入操作在同一个间隙中并发执行, 大大提高了写入性能.
### READ COMMITTED 隔离级别下的简化
如果将事务隔离级别设置为 `READ COMMITTED` (读已提交), 情况会大大简化:
- **InnoDB 会禁用间隙锁 (Gap Lock)**.
- 无论是唯一索引还是普通索引,无论是等值查询还是范围查询, 在这个级别下, InnoDB 只会使用 **记录锁 (Record Lock)**.
- **优点:** 锁的粒度更小, 并发性更高.
- **缺点:** 无法解决幻读问题.
---

### 三. 终极总结表

| 锁类型       | 锁定目标 (Target) | 核心功能 (Blocks What)      | 核心目的 (Main Purpose) |
| --------- | ------------- | ----------------------- | ------------------- |
| **记录锁**   | 单个索引记录        | 对该记录的 `UPDATE`/`DELETE` | 保护单行数据              |
| **间隙锁**   | 索引记录之间的"空隙"   | 对该间隙的 `INSERT`          | 防止幻读 (阻止插入)         |
| **临键锁**   | 记录锁 + 前方间隙锁   | 对记录的修改 + 对间隙的插入         | `RR` 级别下防止幻读的默认锁    |
| **插入意向锁** | `INSERT` 前的间隙 | 被 Gap/Next-Key 锁阻塞      | 提高并发插入性能            |

**一句话总结:** **InnoDB 在 RR 级别下默认使用临键锁来保证数据一致性并防止幻读, 但会在特定场景 (如唯一索引查询) 下将其优化为记录锁或间隙锁以提升并发, 同时通过插入意向锁这一特殊机制来解决高并发插入时的锁冲突问题.**
# Insert 流程
![640-1.webp](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures640-1.webp)

**加锁 double check 机制**: 确认引起唯一键冲突的行记录是正常数据而非草稿态或者删除态
# 死锁
遇到两个事务相互等待对方的锁释放
策略:
- 进入等待, 直到超时
- **等待图** 死锁检测, 发现死锁后，主动回滚死锁链条中的某一个事务 ==多用==

热点行更新, 死锁检测消耗大量资源:
- 业务上判断不出现死锁, 临时将死锁检测关闭
- 控制并发
- 将一行改成逻辑上的多行来减少锁冲突

# 更新丢失
两个事务同时更新一行数据, 导致一个事务的更新被另一个事务覆盖
解决方案: 使用`SELECT ... FOR UPDATE`语句
# 慢查询优化
1. 检查是否用了索引
2. 用的索引是否是最优的
3. 字段是否太多
4. 表数据是否过多, 需要分库分表
5. 机器性能
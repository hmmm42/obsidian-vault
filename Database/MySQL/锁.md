# 全局锁
全库逻辑备份, 把整库每个表都 select 出来存成文本
```SQL
Flush tables with read lock
```

# 表级锁
## 表锁
在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

## 元数据锁 MDL
不显式使用
- 对一个表做增删改查操作的时候，加 MDL 读锁 *可以有多个线程同时对一张表增删改查*
- 对表做结构变更操作的时候，加 MDL 写锁

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个**事务提交后**再释放。

考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```
## 意向锁
对行记录添加S锁, X锁之前, 会对表添加 IS锁, IX锁
*快速判断表中是否有记录被加锁*
## AUTO-INC 锁
插入数据时添加, 为`AUTO_INCREMENT`字段赋值, 插入执行完后释放
会影响性能
额外提供机制: 互斥量 Mutex, 用于取代 AUTO-INC 锁
`AUTO_INCREMENT`赋值后立刻释放, **可能主从不一致, 需要设置`binlog_format = row`**
修改`innodb_autoinc_lock_mode`来决定
默认情况下:
- 插入行数可确定: Mutex
- 插入行数不可确定: AUTO-INC 锁
# 行锁
## Record Lock
需要的时候加上, 事务提交后释放 ==两阶段锁协议==
分为读锁, 写锁 (S Lock, X Lock)
## Gap Lock
**可重复读**级别, 防止位于范围内事务id的记录插入, 解决幻读问题
## Next-Key Lock
Record Lock + Gap Lock
## 插入意向锁
插入一条记录时，判断插入位置是否已被其他事务加了间隙锁
如果有则阻塞, 直到间隙锁释放, 期间生成插入意向锁 *可以理解为特殊的间隙锁*
# 死锁
遇到两个事务相互等待对方的锁释放
策略:
- 进入等待, 直到超时
- **等待图** 死锁检测, 发现死锁后，主动回滚死锁链条中的某一个事务 ==多用==

热点行更新, 死锁检测消耗大量资源:
- 业务上判断不出现死锁, 临时将死锁检测关闭
- 控制并发
- 将一行改成逻辑上的多行来减少锁冲突
# MySQL 主从同步核心知识笔记
MySQL 主从同步 (Master-Slave Replication) 是其最重要的功能之一, 也是构建高性能、高可用数据库集群的基础.
## 1. 什么是主从同步？为什么需要它？
**定义**: 主从同步是指将一台 MySQL 服务器 (称为 Master, 主库) 的数据实时、异步地复制到一台或多台其他 MySQL 服务器 (称为 Slave, 从库) 的过程.
**核心用途**:
1.  **读写分离 (Read/Write Splitting)**:
    * 这是最主要的应用场景. 主库负责处理所有写操作 (INSERT, UPDATE, DELETE), 而一个或多个从库负责处理所有读操作 (SELECT).
    * **目的**: 将读写压力分散到不同服务器, 极大地提高了数据库的整体并发能力和性能.
2.  **高可用性与故障转移 (High Availability & Failover)**:
    * 当主库发生故障时, 可以快速将一个从库提升为新的主库, 对外继续提供服务.
    * **目的**: 减少因单点故障导致的停机时间, 保证业务的连续性.
3.  **数据备份 (Data Backup)**:
    * 可以在从库上进行数据备份操作 (如 `mysqldump`), 而不会对主库的性能产生影响.
    * **目的**: 实现无锁、无干扰的热备份.
4.  **异地容灾 (Off-site Disaster Recovery)**:
    * 可以将数据同步到一个位于不同地理位置的从库上.
    * **目的**: 当主机房因自然灾害等原因不可用时, 可以在异地恢复数据和服务.
## 2. 主从同步的核心原理
主从同步的实现依赖于三个核心线程和两种关键日志.
**核心线程**:
1.  **Master: Binlog Dump Thread (主库)**:
    * 当从库连接到主库时, 主库会为该从库创建一个 `dump` 线程.
    * 该线程负责读取主库的二进制日志 (Binlog) 中的事件, 并将其发送给从库.
2.  **Slave: I/O Thread (从库)**:
    * 从库的 `I/O` 线程负责连接到主库, 并接收主库 `dump` 线程发送过来的 Binlog 事件.
    * 它将接收到的事件写入到从库自己的**中继日志 (Relay Log)** 文件中.
3.  **Slave: SQL Thread (从库)**:
    * 从库的 `SQL` 线程负责读取中继日志 (Relay Log) 中的事件.
    * 然后, 它会在从库上**重放 (Replay)** 这些事件, 即执行一遍在主库上发生过的操作, 从而使从库的数据与主库保持一致.
**数据流转过程**:
`Master (数据变更) -> Binlog -> Dump Thread -> 网络 -> Slave I/O Thread -> Relay Log -> Slave SQL Thread -> Slave (数据变更)`
**为什么需要 Relay Log?**
Relay Log 是一个缓冲机制. 它将 "网络数据接收" 和 "SQL 执行" 这两个步骤解耦. 即使 SQL 线程执行较慢, I/O 线程仍然可以快速接收来自主库的 Binlog, 避免因从库执行慢而拖慢主库的网络连接.
## 3. 主从同步的模式 (Binlog 格式)
主库 Binlog 的记录格式决定了同步的方式, 主要有三种:
1.  **基于语句的复制 (Statement-Based Replication - SBR)**:
    * **原理**: 在 Binlog 中记录原始的 SQL 语句.
    * **优点**: Binlog 文件体积小, 节约网络带宽.
    * **缺点**: **不安全**. 某些非确定性函数 (如 `UUID()`, `NOW()`) 或 `UPDATE ... LIMIT` 等语句在主从库上执行的结果可能不一致, 导致数据漂移.
2.  **基于行的复制 (Row-Based Replication - RBR)**:
    * **原理**: 在 Binlog 中记录每一行数据变更的具体内容 (修改前和修改后的值).
    * **优点**: **非常安全**, 不会存在数据不一致的风险, 保证了主从数据的绝对一致.
    * **缺点**: Binlog 文件体积较大, 尤其是在执行批量更新或删除时.
3.  **混合模式复制 (Mixed-Based Replication - MBR)**:
    * **原理**: SBR 和 RBR 的结合体. 一般情况下使用 SBR, 当遇到不安全的 SQL 语句时, 自动切换到 RBR.
    * **优点**: 兼顾了 SBR 和 RBR 的优点, 是一种折中的方案.
**推荐**: 从 MySQL 5.7.7 版本开始, 默认的 Binlog 格式就是 **RBR (Row-Based Replication)**. 除非有特殊需求, 否则强烈建议使用 RBR, 因为数据的一致性和安全性是最重要的.
## 4. GTID 模式 (全局事务标识符)
GTID (Global Transaction Identifier) 是 MySQL 5.6 引入的、在 5.7 中得到增强的革命性功能.
* **定义**: 为主库上提交的每一个事务都生成一个全局唯一的 ID. 格式为 `source_id:transaction_id`.
* **传统模式 (File/Position)**: 从库需要知道它当前同步到了主库的哪个 Binlog 文件的哪个位置. 故障切换时, 需要人工查找这个位置, 非常繁琐且容易出错.
* **GTID 模式的优势**:
    * **自动定位**: 从库不再关心文件名和位置, 只需告诉主库它已经执行过的 GTID 集合, 主库会自动将所有未执行的事务发送过来.
    * **故障切换更简单**: 当主库宕机后, 切换新的主库非常方便, 无需手动找点.
    * **保证事务不被重复执行**.
**推荐**: 搭建新的主从环境时, **强烈建议启用 GTID 模式**.
## 5. 主从同步的延迟问题 (Replication Lag)
主从同步是异步的, 这意味着从库的数据状态总是会比主库稍晚一点, 这就是主从延迟.
**主要原因**:
1.  **从库性能差**: 从库的硬件配置 (CPU, 磁盘 IO) 远低于主库.
2.  **主库写入压力大**: 主库并发写入量巨大, 而在 MySQL 5.6 之前, 从库的 SQL 线程是**单线程**的, 无法跟上主库的写入速度.
3.  **大事务**: 主库上一个执行了很长时间的大事务 (如批量删除或更新), 会导致 Relay Log 积压, SQL 线程需要同样长的时间来重放.
**解决方案**:
4.  **硬件升级**: 保证从库与主库有相近的硬件配置.
5.  **并行复制 (Parallel Replication)**:
    * MySQL 5.6 引入了基于库的并行复制.
    * MySQL 5.7 引入了更高效的**基于 `LOGICAL_CLOCK` 的并行复制**, 允许属于不同组的事务在从库上并行执行, 极大地提高了同步效率. **这是解决延迟问题的核心方案**.
6.  **业务拆分**: 在应用层避免执行大事务.
## 6. 常见的主从架构
1.  **一主一从 (One Master, One Slave)**: 最基础的架构, 用于备份和高可用.
2.  **一主多从 (One Master, Multiple Slaves)**: 最常见的读写分离架构.
3.  **主主复制 (Master-Master Replication)**: 两台服务器互为主从, 都可以写入, 用于实现更高的高可用性. 但需要解决主键冲突等问题.
4.  **半同步复制 (Semi-Synchronous Replication)**:
    * **异步 (默认)**: 主库执行完 `COMMIT` 后立即返回给客户端, 不关心从库是否收到 Binlog. 主库宕机时可能丢失数据.
    * **半同步**: 主库 `COMMIT` 后, 必须等待至少一个从库确认收到 Binlog, 才会返回给客户端.
    * **作用**: 在性能和数据一致性之间做了一个平衡, 大大降低了主库宕机时数据丢失的风险.
---
**总结**: MySQL 主从同步是构建可扩展、高可用数据库服务的基石. 掌握其原理, 理解 GTID 和并行复制的重要性, 并根据业务需求选择合适的架构 (如异步 vs 半同步), 对于任何 MySQL DBA 或后端开发者都至关重要.
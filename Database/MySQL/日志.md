==写脏页+写入Buffer Pool的Undo页 -> 写入redolog buffer -> 累加binlog event -> 提交时redolog落盘 -> binlog落盘 -> 异步: 脏页, Undo页落盘==
# redo log
**物理**日志, 记录在某个 page 做了什么修改 
**其产生时在事务修改数据时（可能没有提交），以 page 为粒度**持续生成并投入到 redo log buffer，最终**在事务提交时被强制持久化落盘.** 在 innodb 中是能支持**多事务并行的，因此多个事务可能会穿插生成 redo log**，直到某个事务提交时，则强制将此前对应的一系列 redo log 进行强制落盘.
**InnoDB** 独有, 循环写
*“先写日志，再写数据”* 在空闲时将修改写入磁盘
- 提高数据库的事务处理性能 (避免每次提交都刷数据页)。
- 保证事务的持久性 (即使系统崩溃也能恢复已提交的事务)。
- 实现崩溃恢复 (通过 Redo Log 将数据库恢复到崩溃前的状态)。
## 组成
- redo log buffer: 内存中的 redo log
- redo log file: 磁盘上的 redo log
redo log 以 **page** 为粒度
每次执行写操作, 会将修改的页写入 redo log buffer, 提交时将 redo log buffer 写入磁盘
## 存储
整个 redo log buffer 为队列, 队列中以 log block 为单元
- 每个 log block 的大小为 512 字节
- 分为 header, body, tailer
- 一条 redo log 对应一个 page, 存在 log block buffer 中
- 多条 redo log 可以存放在同一个 log block 中
## 使用
**LSN**: 在某个时刻下，所有事务写入重做日志的总量, 可以反映事务生成的时序
## 抖动
- 脏页: 已经写入 redo log 但未写入磁盘数据页
- 干净页: 内存和磁盘上的数据页的内容一致

抖动原因: 从 redo log 写入数据 (flush)
- ! redo log 已满
- ! 内存不足, 需要淘汰数据页, 如果是脏页, 需要先将脏页写入磁盘
- 系统空闲
- 正常关闭

InnoDB 的刷盘速度取决于: 
- 脏页比例
- redo log 写盘速度
将`innodb_io_capacity`设置为磁盘的 IOPS, 不让脏页比例接近 $75\%$
# binlog
记录**逻辑操作**(所有数据变更), 事务提交时产生, 按照事务提交先后顺序进行排列
Server 层实现, 任何引擎都可以用
追加写
## 对比
redo log 效率更高
**为什么物理日志不可用于同步？** 
- 想象一下，主库和从库的 MySQL 版本、InnoDB 小版本、操作系统、甚至是磁盘格式都可能存在细微差异。如果你把主库上具体的物理页面修改操作原封不动地搬到从库去执行，很可能会因为内部数据结构不一致而导致**数据彻底损坏**。而 `Binlog` 的逻辑记录则没有这个问题，它只是告诉从库“要做什么事”，从库的 InnoDB 引擎会自己负责把这件事用“正确的方式”在自己的物理文件上完成。
- 循环写, 日志大小是固定的, binlog是追加写, 保留全量信息
# undo log
用于事务回滚, MVCC
==undo log的持久化依赖于 redo log==
undo log写入顺序在所有日志之前, 刚执行完语句未提交也会写, 保证可以回滚
每次生成新版本数据时, 保留旧版本数据, 形成版本链: 回滚指针 roll_ptr 指向上一个版本的 undo log
**1）屏蔽中间态数据：** 一个事务产生的修改，会**通过其事务 id 进行“版本”标识，这样在事务未提交前，其作出的修改都不会被外界所认可**，外界的读操作可以借助行记录对应的 undo log，回溯并获取到上一个已提交的正式数据版本
**2）全部提交：** 当事务**提交时，其事务 id 会获得“正名”** ，这样一瞬间，其产生的所有行记录对应的数据版本都会被外界所认可，**体现了原子性中“全部动作一起成功”** 的语义
**3）全部回滚**：**当事务回滚时，其事务 id 会失去“正名”** ，其产生的所有行记录对应数据版本都被外界否定，与此同时，可以**很方便地借助 undo log 将涉及修改的行记录内容回溯成上一个版本的状态，体现了原子性中“全部动作一起失败”** 的语义

## 存储
*存放在共享表空间 undo segment 中*, ==依赖 redo log 实现持久化==
- insert: 对于其他事务不可见, 只需记录删除操作
- update: 有 roll_ptr, 记录本次操作
# 写日志全流程
准备 => 提交, 保证两个 log 的数据一致性
#### 阶段一: 事务执行中
当客户端执行 `UPDATE T SET c=c+1 WHERE id=1;` 时:
1. **写入 Undo Log**:
	- 这是**第一步**. 在修改数据之前, InnoDB 必须先记录回滚所需的信息. 它会把 `id=1` 这一行修改前的数据 (旧值) 记录到 `Undo Log` 中.
	- **目的**: 保证事务的**原子性** (可以回滚) 和实现 **MVCC** (其他事务可以看到旧版本数据).
2. **修改内存中的数据**:
	- InnoDB 在内存的 Buffer Pool 中找到 `id=1` 对应的数据页, 并将 `c` 的值加 1. 此时, 这个数据页就成了 "脏页".
3. **写入 Redo Log Buffer**:
	- InnoDB 将"对哪个数据页做了什么修改"这个物理操作记录到内存中的 `Redo Log Buffer` 里.
	- **注意**: 此时 `Redo Log` 只是在**内存**中, 并没有刷入磁盘.
4. **生成 binlog event → 写入 binlog cache**
	- Server 层生成 bin~log event（逻辑操作），写入 **binlog cache**（仅内存）。
	- 事务未提交前不会落盘。
#### 阶段二: 事务提交时 (COMMIT)
当客户端执行 `COMMIT;` 时, 两阶段提交正式开始:
4. **步骤一: Redo Log Prepare (刷盘)** ==阶段一==
    - InnoDB 将内存中的 `Redo Log Buffer` 的内容**刷入磁盘**的 `Redo Log` 文件中.
    - 这个过程完成后, 事务在 `Redo Log` 中被标记为 **Prepare (准备)** 状态.
    - **此时, 即使数据库崩溃, 这个事务的修改也能通过 Redo Log 被恢复, 持久性得到了保障.**
5. **步骤二: Binlog 写入 (刷盘)** ==阶段二==
    - MySQL Server 层将该事务的变更内容从`binlog cache`写入到 `Binlog` 文件中.
    - `Binlog` 写入磁盘后, 用于主从复制的数据就已经准备好了. 
    - ==最终主从同步看的是binlog, 只要binlog刷盘了, 宕机后看到binlog ok和redo log prepare, 会补完事务提交==
6. **步骤三: Redo Log Commit (标记)**
    - `Binlog` 写入成功后, InnoDB 会在 `Redo Log` 中写入一个 `COMMIT` 标记, 表示这个事务已经**正式提交**.
    - 这个 `COMMIT` 标记代表两阶段提交的完成. 之后, 事务的修改将对其他事务可见 (根据隔离级别).
![2e5bff4910ec189fe1ee6e2ecc7b4bbe.png](https://raw.githubusercontent.com/hmmm42/Picbed/main/obsidian/pictures2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)


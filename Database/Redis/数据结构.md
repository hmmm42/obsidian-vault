kv存储结构, 所有的Key都是string
# 常用
## String
k-v 结构, kv 二进制安全, v 最多 `512MB`
### 实现
SDS (Simple Dynamic String)
- 整数值, 可用 long 表示: `int`
- 字符串, <=32Bytes: `embstr` *一次分配连续内存, 只读, 修改时转为`raw`*
- 字符串, >32Bytes: `raw` *两次分配内存, 两块空间*
### 应用
- 直接缓存 `SET` `GET` `EXISTS` `STRLEN` `DEL`
- 计数 `INCR` `DECR` `INCRBY` `DECRBY`
- 分布式锁 `SETNX` `PX`过期时间
- 共享 Session
## List
双向链表, 头尾各有一个指针, 最大长度 `2^32-1`
一个 List 由 key 唯一标识
`LPUSH` `RPUSH` `LPOP` `RPOP`
### 实现
quicklist, 双向链表, 每个节点存储一个 `ziplist` => 升级到 `listpack`
- 通过将多个ziplist用双向链表串联起来, `quicklist`既保证了在两端操作(LPUSH, RPOP)时拥有链表的O(1)高效性, 又通过ziplist节点大大减少了内存开销和指针碎片的数量.
- ==`ziplist`就是元素大小可变的数组, 内存空间连续, 包含上一个元素的长度字段用来实现反向遍历, 但是中间操作慢, 且无法O(1)随机访问== 连锁更新O(N^2)
- `listpack`不再存储前一个节点的长度, 而是**存储当前节点的总长度**. 当需要反向遍历时, 它通过查找一个特殊的结束符来定位到上一个节点的末尾, 然后再从那里读取上一个节点的总长度. ==避免了元数据变化导致的连锁更新==, 但是内存移动还是O(N)
### 应用: 消息队列
- 消息保序: `LPUSH` + `BPOP`
- 阻塞式读取: `BRPOP` 有数据则返回, 否则等待
- 重复消息: 生产者自行为每个消息生成全局唯一 ID
- 可靠性: `BRPOPLPUSH` 将读取的消息同时插入到备份 List
### 缺陷
- 不支持多个消费者消费同一条消息: 使用 **Stream** 代替
## Hash
哈希表 uid 表示多个 kv 对
小容量时 `ziplist` => 升级到 `listpack`, 大容量用`hashtable`
### hashtable
拉链法
与go类似的渐进式rehash
rehash时机: 
- 哈希冲突不严重时, 在没有rdb,aof任务时进行
- 严重, 直接进行
## Set
无序集合, 不允许重复元素 `intset`或`hashtable`
`intset`是一个有序的, 无重复的整数数组, 查找时可以使用二分查找, 非常节省内存.
**聚合运算(∪,∩)复杂度高**
应用: 点赞, 共同关注, 抽奖
## Zset
有序集合 `listpack`或`skiplist` + `hashtable`, 处理元素到分数, 分数到元素

# 其他
## BitMap
位图
应用:
- 签到统计: `SETBIT`, `GETBIT`, `BITCOUNT`, `BITPOS`首个1
- 判断登录态
- 连续签到用户总数 **进行与操作**
## HyperLogLog
set, 估算去重计数, 内存占用固定
- 统计网站 UV(unique vistor), DAU(日活跃用户)
## GEO
地理位置, 将二维坐标映射到一维
## Stream
专为消息队列设计, 支持多消费者消费同一条消息
- `XADD`添加消息 自动生成唯一ID, `XREAD`读取消息
- `XREAD block`阻塞读取
- `XGROUP`创建消费组, `XREADGROUP`读取消息
- 同一个消费组只能有一个消费者消费同一条消息, 不同消费组的消费者可以消费同一条消息 *前提: 创建消费组时指定了相同位置开始读取*
- `XACK`确认消费, `XAUTOCLAIM`自动确认
- `XPENDING`查看已读取但未确认的消息
**问题**:
- 消息丢失
- 消息堆积
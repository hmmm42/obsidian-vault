三种持久化方式: **AOF日志, RDB快照, 混合持久化**
# AOF日志
Append Only File 追加写入文件, 保存写操作命令
执行完写操作后再写入日志:
- 避免检查开销, 不阻塞
- 有丢失风险, 可能阻塞下一个命令 
## 写回
- Always: 每次写操作都写入AOF, 数据不丢失, 性能差, 可能会阻塞
- Everysec: 每秒写入AOF, 数据丢失1s, 性能好
- No: 由操作系统决定写回时机, 性能最好, 数据丢失风险大
## 重写
AOF 文件大小超过设定值, 创建新的AOF文件, 进行压缩
### 后台重写
由子进程完成, 主进程继续处理命令并将新的命令写入 ==AOF 重写缓冲区==
- 通过 fork 创建子进程, 子进程会复制父进程的内存空间
- **写时复制**机制:`fork` 瞬间，子进程拥有主进程内存数据的副本，但并未立即复制所有数据，只有当主进程或子进程修改了某个内存页时，才会复制该页。
- 子进程重写完成后，将重写缓冲区的数据追加到新的 AOF 文件末尾，最后替换旧文件。
# RDB快照
定期保存数据快照, 二进制文件 **全量快照**
- `save`: 会阻塞
- `bgsave`: 由子进程完成, 不会阻塞
**写时复制**, `bgsave`过程中, 主线程修改的数据要等到下一次快照才能保存
# 混合持久化
AOF + RDB
- AOF 重写时, 子进程不再生成纯 AOF 文件，而是先将当前内存中的数据集以 RDB 格式写入 AOF 文件的开头，然后将重写期间主进程收到的写命令以 AOF 格式追加到这个 RDB 数据的后面。
- 恢复时, 先加载 RDB 数据, 然后再加载 AOF 数据, RDB 加载速度快
- AOF 可读性变差, 兼容性变差
# 大key
影响:
- AOF Always 阻塞耗时大, Everysec 异步执行`fsync()`不影响, No 永不执行 `fsync()`
	- 只有always策略会受影响 
- AOF 重写: `fork`阻塞, 写时复制阻塞
- 客户端超时阻塞, 网络阻塞, 工作线程阻塞
- 内存分布不均

解决: 
- 把大key拆成key
- 定时检查大key, 用`unlink`异步删除
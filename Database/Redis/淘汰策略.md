# 过期删除
过期的 key 存在过期字典中
## 策略
- 定时删除: 设置过期时间时创建定时时间, CPU负担大
- 惰性删除: 访问key时才删除
- 定期删除: 定期随机取出一定数量 key, 检查并删除
Redis 策略: **惰性删除+定期删除**
默认检查间隔 10次/秒, 每次随机抽查20个, 如果数量不够继续就循环, 抽查时间上限 25ms
# 内存淘汰
运行内存超过`maxmemory <bytes>`时触发
默认淘汰策略: `noeviction`, 内存超限时禁止写入

- 在设置了过期时间的数据中进行淘汰：
	- **volatile-random**：随机淘汰设置了过期时间的任意键值；
	- **volatile-ttl**：优先淘汰更早过期的键值。
	- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
	- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
- 在所有数据范围内进行淘汰：
	- **allkeys-random**：随机淘汰任意键值;
	- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
	- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。
查看策略: `config get maxmemory-policy`
修改策略: 
- 命令`config set maxmemory-policy <策略>` 重启后失效
- 修改配置文件`maxmemory-policy <策略>`
## [[LRU]]
近似 LRU, 在对象中添加最后一次访问时间信息, 淘汰时随机采样
==问题: 无法解决缓存污染(一次读了大量数据)==
## [[LFU]]
LFU 字段: 8位最后一次访问时间信息 + 16位数据访问频次
key 被访问时, 计数器以概率增加 
1. 先按照上次访问距离当前的时长，来对 logc 进行衰减；
2. 然后，再按照一定概率增加 logc 的值
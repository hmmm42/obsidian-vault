参考[[Algo/数据结构/哈希表|哈希表]]

### 1. 静态哈希 (Static Hashing)

静态哈希是最基础的哈希形式，它的核心特点是桶（Bucket）的数量在初始创建后是**固定不变**的。

- **工作原理**:
    
    - 系统预先分配一个固定数量的桶（Primary Bucket Pages），比如 `N` 个。 11
        
    - 使用一个哈希函数 `h`，对于给定的键 `key`，通过 `h(key) mod N` 计算出它应该存放在哪个桶中。 22
        
    - 如果计算出的桶已满，新的记录就会被放入一个**溢出页（Overflow Page）**中，这个溢出页通过链表的形式连接到主桶上。 3333
        
- **主要问题**:
    
    - **数据增长**：随着数据不断插入，溢出链会越来越长。查询时，可能需要遍历很长的溢出链，导致性能严重下降。 4
        
    - **数据收缩**：如果大量数据被删除，许多桶会变得空空荡荡，造成巨大的空间浪费。 5
        
    - **解决方案**：唯一的解决办法是进行昂贵的**定期重组（Reorganization）**，即用一个新的桶数量 `N'` 重新组织整个文件，但这会导致服务在重组期间性能下降甚至不可用。 6
        

_(概念图基于 77)_

---

### 2. 可扩展哈希 (Extendible Hashing)

为了解决静态哈希的“静态”问题，可扩展哈希被设计出来。它是一种动态哈希，能够优雅地适应数据的增长，其核心是引入了一个 **目录（Directory）** 结构。

- **工作原理**:
    
    - **目录结构**：系统维护一个指针数组，称为“目录”。目录的大小总是2的幂，比如 2d。 8 `d` 被称为**全局深度（Global Depth）**。
        
    - **哈希与寻址**：要查找一个键 `key` 时，计算其哈希值，并取该哈希值的**最后 `d` 位**，这个二进制数就直接对应目录的索引，从而找到指向目标桶的指针。 9
        
    - **局部深度**：每个桶自身维护一个**局部深度（Local Depth）`d'`**，表示该桶内所有记录的哈希值共享的最后 `d'` 位是相同的。 10 多个目录项可以指向同一个桶，只要 `d' < d`。
        
- **如何“扩展”**:
    
    - 当一个桶满了需要分裂时，系统会检查其局部深度 `d'`。
    - **情况一 (d' &lt; d)**：如果该桶的局部深度小于目录的全局深度，只需分裂该桶，将其中的记录根据新的哈希位（第 `d'+1` 位）重新分配到新旧两个桶中，然后修改目录中的部分指针指向新桶即可。**目录本身大小不变**。
    - **情况二 (d' = d)**：如果该桶的局部深度等于全局深度，说明目录已经无法区分新分裂出的桶了。此时，系统必须先将**目录的大小加倍**（即全局深度 `d` 加1），然后再分裂桶并更新指针。这是该方法“可扩展”的核心。 11
        
- **优缺点**:
    
    - **优点**：查询性能很好，通常只需要两次I/O（一次读目录，一次读桶）。它通过目录动态扩展，避免了长溢出链。 12
        
    - **缺点**：如果哈希函数不均匀导致数据倾斜，目录的大小可能会急剧增长，甚至超过内存容量，成为新的瓶颈。 13
        

_(概念图基于 14)_

---

### 3. 线性哈希 (Linear Hashing)

线性哈希是另一种优秀的动态哈希方法，它避免了可扩展哈希中可能存在的巨大目录，实现了更平滑、线性的空间增长。

- **工作原理**:
    
    - **无目录**：它不使用目录结构，而是维护一个连续的桶序列。 15
        
    - **增量分裂**：桶的分裂不是在溢出时立即发生，而是按照一个预设的规则进行。系统维护一个 **`next` 指针**，指向下一个要被分裂的桶。 16
        
    - **分裂时机**：当文件负载（例如，记录总数/桶总容量）超过某个阈值时，无论哪个桶发生了溢出，系统都会分裂 `next` 指针指向的桶。 17
        
    - **分裂过程**：分裂时，`next` 指针指向的桶中的所有记录会被重新哈希，并分配到原来的桶和一个在文件末尾**新创建的桶**中。分裂完成后，`next` 指针加1。 18 当 `next` 指针遍历完一轮所有初始桶后，整个哈希文件的层级（level）就提升了。
        
    - **哈希函数族**：线性哈希使用一系列的哈希函数，如 h_i(key)=h(key)pmod2icdotN 。随着分裂的进行，系统使用的哈希函数也在演进。 19
        
- **查询过程**:
    
    - 要查找一个键，先用当前的哈希函数 h_i 计算桶号。
    - 如果计算出的桶号在 `next` 指针**之前**，说明这个桶可能已经分裂了，需要用下一级的哈希函数 h_i+1 再次计算，以确定记录到底在哪个桶（原始桶或分裂出的新桶）。 20
        
    - 如果桶号在 `next` 指针**之后**，说明它还没被分裂，记录一定就在这个桶或其溢出链中。
- **优缺点**:
    
    - **优点**：空间增长平滑，一次只增加一个桶，且没有目录的额外开销。在数据倾斜的情况下，其空间利用率通常优于可扩展哈希。 21
        
    - **缺点**：由于分裂不是在溢出时立即发生，所以仍然需要溢出链来临时处理溢出，查询性能可能会因此受到一些影响。 22
        

### 总结与比较

|          |                |                      |                      |
| -------- | -------------- | -------------------- | -------------------- |
| **特性**   | **静态哈希**       | **可扩展哈希**            | **线性哈希**             |
| **核心结构** | 固定数量的桶 + 溢出链   | 可加倍的目录 + 桶           | 连续的桶序列 + `next`指针    |
| **空间增长** | 不增长，需手动重组 26   | 桶分裂，目录按需加倍 27        | 逐个增加桶，线性平滑增长 28      |
| **性能特点** | 随数据增长性能急剧下降 29 | 查询性能稳定，通常为2次I/O 30   | 平均性能良好，但可能存在临时溢出链 31 |
| **主要缺点** | 僵化，无法适应动态数据 32 | 数据倾斜时目录可能过大，空间开销高 33 | 需要溢出链，分裂和溢出是解耦的 34   |
| **适用查询** | 仅限等值查询         | 仅限等值查询               | 仅限等值查询 35            |

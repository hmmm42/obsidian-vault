
## 结构特性

一棵 M 阶 (Order M) 的 B+ 树具有以下特点：

*   **节点类型：** 分为内部节点（索引节点）和叶子节点（数据节点）。
*   **内部节点：**
    *   每个内部节点最多包含 `M` 个子节点指针和 `M-1` 个键。
    *   每个内部节点（除根节点外）至少包含 `⌈M/2⌉` 个子节点指针和 `⌈M/2⌉ - 1` 个键。
    *   根节点若不是叶子节点，则至少有 2 个子节点。
    *   内部节点的键用于索引，不存储实际数据记录。键 `K_i` 左侧子树中的所有键都小于 `K_i`，右侧子树中的所有键都大于等于 `K_i`。
*   **叶子节点：**
    *   所有叶子节点位于同一层级。
    *   叶子节点包含数据条目（通常是 `(键, 值)` 或 `(键, 数据记录指针)`）。
    *   每个叶子节点（除根节点外）至少包含 `⌈L/2⌉` 个数据条目，最多包含 `L` 个数据条目（`L` 通常与 `M` 不同，取决于数据条目大小）。
    *   叶子节点通过双向链表连接，方便进行范围查询和顺序访问。
*   **平衡性：** 插入和删除操作会维持树的平衡，确保从根到任何叶子节点的路径长度相同。搜索效率稳定，时间复杂度为 O(log N)。

## 插入操作 (Insertion)

1.  **查找位置：** 从根节点开始，根据键值向下查找，直到找到合适的叶子节点来插入新的数据条目。
2.  **插入数据：** 将数据条目插入到目标叶子节点，并保持节点内条目的有序性。
3.  **处理节点溢出 (Node Overflow)：**
    *   **分裂 (Split)：** 如果插入后叶子节点的数据条目数量超过 `L`：
        *   将该节点分裂成两个节点。
        *   将原节点中间的键（通常是第 `⌈(L+1)/2⌉` 个键）复制到父节点中，作为指向新节点的索引。
        *   如果父节点也因此溢出（键数量超过 `M-1`），则递归地对父节点执行分裂操作，直到根节点或不再溢出。如果根节点分裂，树的高度增加 1。
    *   **重新分配 (Redistribution) - 可选优化：** 在分裂前，可以检查相邻的兄弟叶子节点是否有空间。如果有，可以将部分数据条目移动到兄弟节点，避免分裂，从而减少节点数量。

## 删除操作 (Deletion)

1.  **查找位置：** 从根节点开始，根据键值向下查找，定位到包含要删除的数据条目的叶子节点。
2.  **删除数据：** 从叶子节点中删除该数据条目。
3.  **处理节点下溢 (Node Underflow)：**
    *   如果删除后叶子节点的数据条目数量少于 `⌈L/2⌉`：
        *   **重新分配 (Redistribution)：** 检查相邻的兄弟叶子节点。如果某个兄弟节点的数据条目数量大于 `⌈L/2⌉`，可以从该兄弟节点“借”一个数据条目过来，并更新父节点中对应的键值。
        *   **合并 (Merge)：** 如果无法进行重新分配（兄弟节点也都刚好满足最小条目数），则将该叶子节点与其一个相邻的兄弟节点合并。同时，需要从父节点中删除指向被合并节点的那个键和指针。
        *   **递归处理父节点：** 如果合并操作导致父节点下溢（键数量少于 `⌈M/2⌉ - 1`），则递归地对父节点执行重新分配或合并操作，直到根节点或不再下溢。如果根节点的最后一个键和指针被移除（只剩一个子节点），则该子节点成为新的根节点，树的高度减少 1。
    *   **注意：** 删除内部节点中的键可能也需要进行重新分配或合并操作，逻辑与叶子节点类似，但操作对象是键和子节点指针。
好的，这是为应对考试准备的、使用LaTeX格式化所有数学公式的查询操作I/O次数计算方法总结。

### **基础变量定义**

在开始前，我们先约定好公式中使用的变量：

- N, M: 分别代表关系R和关系S占用的磁盘页（或块）数。
- B: 内存中可用的缓冲区页（或块）数。
- pR​: 关系R中，平均每页包含的元组（记录）数。
- RF: 查询条件的缩减因子（Selectivity / Reduction Factor），即满足条件的记录所占的百分比。

---

### **一、 选择操作 (Selection)**

针对关系R (大小为N页) 执行 `SELECT ... FROM R WHERE ...`

- **无索引**
    
    - **方法**: 全表扫描。
    - **I/O耗费**: N
- **B+树索引**
    
    - **等值查询** (如 `id = 100`)
        - **簇聚索引**: ≈索引遍历(2…4)+1 (1次I/O读数据块)。
        - **非簇聚索引**: ≈索引遍历(2…4)+满足条件的元组数 (最坏情况，每个元组都需一次I/O)。
    - **范围查询** (如 `age > 30`)
        - **簇聚索引**: ≈索引遍历(2…4)+(N×RF) (读取所有包含结果的数据块)。
        - **非簇聚索引**: ≈索引遍历(2…4)+(总元组数×RF) (性能极差，通常不如全表扫描)。
- **哈希索引**
    
    - **仅适用于等值查询**。
    - **I/O耗费**: ≈索引查找(1…2)+读取数据耗费。其中“读取数据耗费”的计算方式与B+树等值查询相同，取决于索引是否簇聚。

---

### **二、 投影操作 (Projection)**

执行 `SELECT DISTINCT ...`，假设原表R大小为N页，投影后的中间结果大小为T页。

- **基于排序**
    
    - **方法**: 先扫描原表生成中间表，再对中间表进行外部排序去重。
    - **I/O耗费**: ≈N(读R)+T(写T)+Cost(外部排序T)。
    - Cost(外部排序T) 约为 2×T×(排序总趟数)。
- **基于哈希**
    
    - **方法**: 分区(Partition)阶段 + 去重(Duplicate Elimination)阶段。
    - **I/O耗费** (假设分区大小可装入内存): ≈N+2T。

---

### **三、 连接操作 (Join)**

连接关系R (M页) 和关系S (N页)。

- **块嵌套循环连接 (Block Nested Loop Join)**
    
    - ❗ **技巧**: 选择较小的表作为**外层关系**可以显著降低成本。
    - **I/O耗费** (设R为外层): M+(⌈M/(B−2)⌉×N)
        - M: 读一遍外层关系R的成本。
        - ⌈M/(B−2)⌉: 外层关系R被分成的块数，也即需要扫描内层关系S的总次数。
        - N: 读一遍内层关系S的成本。
- **索引嵌套循环连接 (Index Nested Loop Join)**
    
    - **方法**: 遍历外层关系R的每一条元组，通过内层关系S连接键上的索引来查找匹配项。
    - **I/O耗费** (设R为外层，S上有索引): M+(R的总元组数×Cost(在S上进行一次索引查找))
    - Cost(在S上进行一次索引查找) 的成本取决于S上索引的类型和是否簇聚。
- **排序-合并连接 (Sort-Merge Join)**
    
    - **方法**: 先将两个关系按连接键排序，然后进行一次合并。
    - **I/O耗费**: Cost(外部排序R)+Cost(外部排序S)+M+N
    - 如果表已有序，则可以省去排序成本。
- **哈希连接 (Hash Join)**
    
    - **方法**: 分区(Partition) + 探测(Probe)。只适用于等值连接。
    - **I/O耗费** (理想情况): 3×(M+N)
        - 该成本包括：读写R和S各一次用于分区（2×(M+N)），再读R和S各一次用于探测连接（M+N）。

---

### **四、 核心算法：外部排序 (External Sort)**

对一个大小为N页的文件进行排序。

- **I/O耗费**: 2×N×(总趟数)
- **总趟数**: 1+⌈logB−1​(N1)⌉
    - 1: 指的是生成初始排好序的顺串（run）的第一趟。
    - logB−1​: 归并阶段的趟数。因为每次归并最多可以将 B−1 个顺串合并成一个。
    - N1: 初始顺串的数量， N1=⌈N/B⌉。


### 一、 外部排序 (External Sort)

#### 1. 原理与问题背景

当需要排序的数据量**远大于**可用内存时，我们就无法将所有数据一次性加载到内存中进行排序（如快速排序）。**外部排序**就是为了解决这个问题的算法，它的核心原理是**分而治之（Divide and Conquer）**。

其基本思想是：先将大文件分解成内存可以容纳的小块，将这些小块分别排序后存回磁盘，形成多个有序的子文件（称为**顺串 (run)**）；然后再通过高效的归并操作，将这些有序的顺串合并成一个最终的有序大文件 1。

#### 2. 执行方法

外部排序主要分为两个核心阶段：

**阶段一：生成初始顺串 (Creating Initial Runs)** 2

1. 从磁盘读取文件的一部分到内存缓冲区中，直到缓冲区（假设大小为`B`个页）被装满。
2. 在内存中，使用高效的内排序算法（如快速排序）对这`B`页数据进行排序。
3. 将排序好的这`B`页数据写回磁盘，形成一个有序的临时文件，这个文件就是一个“顺串”。
4. 重复以上步骤，直到原始文件的所有数据都被处理完毕。最终，磁盘上会生成 `⌈N/B⌉` 个长度为`B`页的有序顺串（`N`是原始文件总页数）。

**阶段二：多路归并 (Multi-way Merge)** 3

现在我们有了一堆有序的顺串，需要将它们合并成一个。

1. 系统将内存缓冲区`B`个页中的`B-1`个页作为**输入缓冲区**，剩下的1个页作为**输出缓冲区**。
2. 同时打开前`B-1`个顺串，并将每个顺串的第一个页读入一个对应的输入缓冲区。
3. 在`B-1`个输入缓冲区中，比较每个缓冲区的第一个元素，找出其中最小的那个。
4. 将这个最小的元素复制到输出缓冲区，并将其在对应输入缓冲区中的指针后移。
5. 如果某个输入缓冲区被读完，就从其对应的磁盘顺串文件中读取下一页来填充它。
6. 如果输出缓冲区满了，就将其内容一次性写入最终的排序结果文件中。
7. 重复步骤3-6，直到所有输入缓冲区的顺串都被处理完毕。

如果顺串的数量超过`B-1`，那么这个归并阶段就需要进行多趟（pass），即先将前`B-1`个顺串合并成一个更长的新顺串，再将这个新顺串与其他顺串进行下一趟归并。
#### 3. 耗费分析

外部排序的总I/O耗费主要取决于总共需要对数据进行多少趟完整的读写。

- **总耗费** ≈ `2 * N * (总趟数)`
- **总趟数** = `1 (初始生成顺串趟) + 归并趟数`
- **归并趟数** ≈ `⌈log_{B-1}(N1)⌉`，其中`N1`是初始顺串的数量（`N1 = ⌈N/B⌉`）。
- 这个公式的含义是：每一趟归并能将顺串的数量减少`B-1`倍，因此需要对数级的归并趟数 5。
    

---

### 二、 块嵌套循环连接 (Block Nested Loop Join)

#### 1. 原理与问题背景

简单的嵌套循环连接效率极低，因为它对外层表的**每一条记录**都要扫描一遍完整的内层表。**块嵌套循环连接**是对其最重要也最有效的优化，其核心原理是**以块为单位进行处理，从而最大限度地减少对内层表的扫描次数**。

#### 2. 执行方法

1. **选择内外层关系**: 为了使成本最低，通常选择两个关系中**较小**的那个作为**外层关系 (Outer Relation)**，较大的作为**内层关系 (Inner Relation)**。
2. **按块读取外层关系**: 从外层关系（设为R）中读取一个“块”（大小为`B-2`个页，`B`为内存缓冲区大小）到内存中 6。
    
3. **扫描完整的内层关系**: 对这个已在内存中的R的块，**完整地扫描一遍**内层关系（S）。
4. **在内存中进行连接**: 在扫描S的过程中，每从S读入一个页，就将其中的每一条记录与内存中R的块里的所有记录进行连接条件的判断，将匹配的结果输出。
5. **处理外层关系的下一个块**: 当S被完整扫描一遍后，清空内存，读取R的**下一个**块，然后**再次完整地扫描一遍S**，重复步骤3和4。
6. 重复以上过程，直到R的所有块都被处理完毕。

_(概念图基于 7)_

- **内存优化**: 为了加速步骤4中内存里的匹配过程，可以不使用循环比较，而是将读入内存的R的块建成一个**哈希表**。这样，对于S中的每一条记录，只需一次哈希探测即可，效率更高 8。
    

#### 3. 耗费分析

- **总耗费** ≈ `M + (⌈M / (B-2)⌉ * N)` 9
    
    - `M`: 读取外层关系R的成本。整个过程R只需被读一遍。
    - `⌈M / (B-2)⌉`: 这是外层关系R被分成的块数。
    - `N`: 读取内层关系S的成本。
    - **公式含义**: 总耗费等于读取一遍外层关系R的成本，**加上**“R的块数”那么多次“读取一遍内层关系S”的成本。

通过这种方式，对内层表的扫描次数从“R的总记录数”次锐减到了“R的总块数”次，性能得到了极大的提升。
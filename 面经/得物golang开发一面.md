1自我介绍
2问了点实习，以及项目拷打，后面八股
3rpc是什么，微服务怎么通信的？a和b通信，怎么知道b服务是有哪些方法的
4goroutine和线程区别
5go的web开发中，每个socket，都有一个goroutine监听吗？
6slice 和 数组区别，slice扩容机制
7MySQL的常用存储引擎，区别
8bp树和b树区别
9redis常用数据结构
大概这么多差不多半个小时多一点


### 1. gRPC是什么, 微服务怎么通信的? A和B通信, 怎么知道B服务有哪些方法?

这一个问题其实包含了三个子问题, 我们来逐个分解.

**RPC**, 全称是 **远程过程调用 (Remote Procedure Call)**. 它是一种计算机通信协议, 其核心思想是: **让开发者调用一个远程服务器上的函数 (或过程), 就像调用本地函数一样简单, 无需关心底层的网络通信细节.**

#### 核心目标与类比

想象一下, 你在你的代码中调用一个本地函数:

```go
// 本地调用
result := calculateSum(10, 20)
fmt.Println(result) // 输出 30
```

现在, 假设 `calculateSum` 这个函数实际上位于另一台服务器上. 如果没有 RPC, 你需要手动处理一系列复杂的网络操作:

1.  建立网络连接 (如 TCP Socket).
2.  将参数 `10` 和 `20` 按照约定的格式打包成二进制数据 (序列化).
3.  通过网络发送这些数据.
4.  等待服务器返回结果.
5.  接收网络数据.
6.  将返回的二进制数据解析成你能用的结果 (反序列化).
7.  关闭连接.

**RPC 的作用就是将上面这一整套复杂的流程封装起来.** 它为你提供一个代理 (Proxy/Stub), 让你依然可以像本地调用一样写代码:

```go
// 看起来像本地调用, 实际上是 RPC
result, err := remoteCalculator.CalculateSum(10, 20)
if err != nil {
    // 处理网络或远程执行错误
}
fmt.Println(result)
```

你只需要直接调用 `remoteCalculator.CalculateSum`, 所有网络相关的细节都由 RPC 框架在底层帮你完成了.

#### RPC 的工作流程

一个完整的 RPC 调用通常包含以下步骤:

1.  **客户端调用 (Client Call):** 客户端应用代码调用一个本地对象的方法, 这个本地对象被称为 **存根 (Stub)**. 这个存根是由 RPC 框架根据服务定义生成的, 它和远程服务提供的方法有完全相同的签名.

2.  **序列化 (Serialization / Marshalling):** 客户端存根接收到调用后, 会将方法的参数 (如 `10`, `20`) 打包, 并转换成一种可以在网络上传输的标准化格式 (如二进制流). 这个过程称为序列化或编组.

3.  **网络传输 (Network Transfer):** 客户端的 RPC 运行时库 (Runtime) 通过底层的网络协议 (如 TCP) 将序列化后的消息发送到远程服务器.

4.  **反序列化 (Deserialization / Unmarshalling):** 服务器端的 RPC 运行时库接收到消息后, 将其交给对应的 **骨架 (Skeleton)**. 骨架会将接收到的二进制流解析, 还原成原始的方法参数. 这个过程叫反序列化或解组.

5.  **服务端执行 (Server Execution):** 服务器端的骨架使用反序列化后的参数, 调用真正的业务逻辑实现代码.

6.  **返回结果:** 执行完成后, 服务器端将返回值进行序列化, 通过网络传回给客户端. 客户端再进行反序列化, 最终将结果返回给最初的调用方.

#### 总结

  * **RPC 是一种编程模型/协议, 不是某个具体的技术.** 它定义了一种让远程调用透明化的思想.
  * **gRPC, Thrift, Dubbo 等都是 RPC 思想的具体实现框架.**
  * **gRPC** 是一个现代的 RPC 框架, 它选择使用 **HTTP/2** 作为传输层协议, 使用 **Protocol Buffers** 作为序列化协议, 这使得它非常高效.

所以, 当面试官问 "RPC 是什么" 时, 最佳的回答是先解释上面这个通用的概念和工作流程, 然后可以补充说: "gRPC 就是一个非常流行和高效的 RPC 实现方案".

-----

感谢你的指正, 这样的追问有助于让答案更加精准和深入. 其他问题的解答保持不变, 因为它们不依赖于这个前提.
#### gRPC是什么?

gRPC (gRPC Remote Procedure Calls) 是一个由 Google 开发的, 开源的, 高性能的远程过程调用 (RPC) 框架.

它的核心特点是:
* **基于 HTTP/2:** 相比 HTTP/1.1, HTTP/2 提供了多路复用, 服务端推送, 头部压缩等特性, 使得通信效率更高.
* **使用 Protocol Buffers (Protobuf):** 这是 Google 的一种与语言无关, 平台无关的可扩展机制, 用于序列化结构化数据. Protobuf 将数据序列化为二进制格式, 体积小, 解析速度快, 比起基于文本的 JSON/XML 更高效.
* **跨语言:** 通过 `.proto` 文件定义服务接口, 可以自动生成不同语言 (如 Go, Java, Python, C++ 等) 的客户端和服务端代码.

简单来说, gRPC 让你可以在一个应用中轻松地调用另一个应用中的方法, 就像调用本地方法一样, 而无需关心底层的网络通信和数据编解码细节.

#### 微服务怎么通信?

微服务之间的通信主要分为两大类:

1.  **同步通信 (Synchronous Communication):**
    * **特点:** 调用方发起请求后, 会阻塞等待服务方的响应.
    * **常见技术:**
        * **RPC (Remote Procedure Call):** 如 gRPC, Thrift. 性能高, 有严格的接口约束.
        * **RESTful API (基于 HTTP):** 使用标准的 HTTP 方法 (GET, POST, PUT, DELETE) 进行通信, 通用性好, 人类可读性强 (通常使用 JSON).
    * **优点:** 编程模型简单, 易于理解.
    * **缺点:** 服务之间耦合度高. 如果一个服务宕机或响应缓慢, 会阻塞整个调用链 (服务雪崩).

2.  **异步通信 (Asynchronous Communication):**
    * **特点:** 调用方发送消息后, 不需要立即等待响应, 而是通过消息中间件进行解耦.
    * **常见技术:**
        * **消息队列 (Message Queue):** 如 RabbitMQ, Kafka, RocketMQ. 服务A将消息发送到队列, 服务B从队列中消费消息.
    * **优点:** 服务解耦, 提高系统的可用性和伸缩性. 一个服务暂时不可用, 不会影响到上游服务.
    * **缺点:** 架构更复杂, 需要考虑消息丢失, 重复消费, 消息顺序等问题.

#### A和B通信, 怎么知道B服务有哪些方法?

这个问题的核心是 **服务契约 (Service Contract)**.

在微服务架构中, 服务A (客户端) 之所以知道服务B (服务端) 有哪些方法可以调用, 是因为它们之间有一个共同遵守的 "约定" 或 "合同". 这个合同定义了服务的名称, 方法, 参数和返回值类型.

* **对于 gRPC:** 这个契约就是 `.proto` 文件. 服务B的开发者会先编写一个 `.proto` 文件来定义服务接口. 然后, 服务A和服务B的开发者都会使用这个文件来生成各自语言的客户端存根 (Client Stub) 和服务端骨架 (Server Skeleton). 服务A通过调用自动生成的客户端代码来发起请求, 这些代码已经包含了所有的方法定义.

* **对于 RESTful API:** 这个契约通常是 **API文档**, 比如使用 OpenAPI (Swagger) 规范编写的文档. 文档中会详细描述每个 URL 路径, 支持的 HTTP 方法, 请求参数和响应格式. 开发者根据这个文档进行开发和调用.

总结: **服务A通过预先定义的接口契约 (如 `.proto` 文件或 API 文档) 来了解服务B提供了哪些方法.**

---

### 2. goroutine和线程区别

这是 Go 语言面试中的高频问题, 核心在于理解 Go 的并发模型.

| 特性 | Goroutine | 线程 (Thread) |
| :--- | :--- | :--- |
| **管理者** | Go 运行时 (Go Runtime Scheduler) | 操作系统内核 (OS Kernel) |
| **创建/销毁成本** | **非常低**. 初始栈空间只有约 2KB, 创建和销毁开销很小. 可以轻松创建成千上万个. | **较高**. 栈空间通常为几 MB, 创建和销毁涉及系统调用, 开销大. |
| **调度方式** | **用户态调度**. Go 调度器 (M:P:G 模型) 在用户空间完成 goroutine 的切换, 不涉及内核态和用户态的切换, 速度极快. | **内核态调度**. 线程的调度由操作系统内核负责, 切换时需要从用户态陷入内核态, 开销较大. |
| **栈空间** | **动态伸缩**. 初始栈很小 (2KB), 如果需要, 会自动进行扩容或缩容. | **固定大小**. 创建时即分配固定大小的栈 (如 2MB), 不易改变. |
| **通信方式** | 推荐使用 **Channels** (`chan`) 进行通信, 遵循 "不要通过共享内存来通信, 而要通过通信来共享内存" 的哲学. 当然也支持传统的锁 (`sync` 包). | 主要通过 **共享内存** 和 **锁 (Mutex, Semaphore)** 等机制进行同步和通信. |
| **标识** | Go 1.14+ 提供了 `go id` 但不推荐在业务逻辑中使用. Goroutine 没有一个稳定可供外部使用的身份标识. | 每个线程都有一个唯一的线程 ID (TID). |

**核心记忆点:** Goroutine 是由 Go 语言运行时管理的, 更轻量, 调度更高效的 "用户态线程".

---

### 3. go的web开发中, 每个socket, 都有一个goroutine监听吗?

这个问题考察对 `net/http` 包工作原理的理解.

答案不是 "一个 goroutine 监听一个 socket", 而是 **"一个 goroutine 处理一个已接受的连接 (connection)"**.

标准的 `http.Server` 工作流程如下:

1.  **Listen:** 主 goroutine 调用 `net.Listen("tcp", ":8080")`. 这会在操作系统层面创建一个监听 socket, 并将其绑定到指定的端口 (8080).
2.  **Accept Loop:** 之后, 主 goroutine 进入一个无限 `for` 循环, 在循环中调用 `listener.Accept()`. 这个 `Accept()` 方法会阻塞, 直到有一个新的客户端连接请求到达.
3.  **Spawn Goroutine:** 当 `Accept()` 成功返回一个新的连接 (`net.Conn`, 这本质上就是一个代表客户端和服务端之间连接的 socket) 时, `http.Server` 会 **启动一个新的 goroutine** (`go srv.Serve(conn)`).
4.  **Handle Connection:** 这个新创建的 goroutine 的职责就是处理这一个连接上的所有后续请求. 它会读取 HTTP 请求, 调用对应的 `Handler` 处理, 然后将 HTTP 响应写回这个连接, 直到连接关闭.
5.  **Continue Accepting:** 与此同时, 主 goroutine 在创建完新的 goroutine 后, 不会等待它执行完毕, 而是立即返回 `for` 循环的顶部, 再次调用 `Accept()` 等待下一个新连接.

**总结:**
* 只有一个 goroutine (主 goroutine) 在 **监听 (Accepting)** 新的连接.
* **每接受一个** 新的连接, 就会 **创建一个新** 的 goroutine 来专门处理这个连接上的所有通信.
这种 "one-goroutine-per-connection" 的模型是 Go 能够轻松处理高并发网络请求的关键.

---

### 4. slice 和 数组区别, slice扩容机制

#### 区别

**数组 (Array):**
* **定长:** 长度是固定的, 在定义时就已确定.
* **值类型:** 数组的长度是其类型的一部分. `[4]int` 和 `[5]int` 是两种不同的类型. 当数组作为参数传递给函数时, 传递的是整个数组的拷贝.
* **声明:** `var arr [5]int`

**切片 (Slice):**
* **变长:** 长度是动态的, 可以通过 `append` 等操作改变.
* **引用类型:** 切片本质上是一个包含三个字段的结构体:
    1.  `Pointer`: 指向底层数组中某个元素的指针.
    2.  `Length`: 切片的长度, 即切片中元素的个数 (`len()` 函数获取).
    3.  `Capacity`: 切片的容量, 即从切片开始位置到底层数组末尾的元素个数 (`cap()` 函数获取).
* 当切片作为参数传递时, 传递的是这个结构体的拷贝 (指针地址的拷贝), 所以函数内部对切片元素的修改会影响到外部.
* **声明:** `var s []int`

你可以把切片看作是 "对底层数组的一个动态窗口".

#### 扩容机制

当使用 `append` 函数向一个切片添加元素, 并且添加后其 `length` 将会超过 `capacity` 时, Go 会触发扩容机制.

扩容的步骤如下:
1.  **分配新数组:** Go 运行时会分配一块新的, 更大的内存空间, 用来作为新的底层数组.
2.  **复制旧数据:** 将旧切片底层数组中的所有元素拷贝到新的底层数组中.
3.  **添加新元素:** 将 `append` 的新元素添加到新数组的末尾.
4.  **更新切片头:** 返回一个新的切片, 其 `Pointer` 指向新数组, `Length` 更新为添加元素后的大小, `Capacity` 更新为新数组的总容量.

**容量增长策略 (大致规则, 具体实现可能随 Go 版本微调):**
* **当原切片容量 `< 1024` 时:** 新容量会翻倍, 即 `newCap = oldCap * 2`.
* **当原切片容量 `>= 1024` 时:** 新容量会以大约 1.25 倍的因子增长 (`newCap = oldCap * 1.25`), 避免内存的过度浪费.

这个策略是在性能 (减少分配次数) 和内存使用 (避免浪费) 之间做出的权衡.

---

### 5. MySQL的常用存储引擎, 区别

MySQL 中最常用的两个存储引擎是 **InnoDB** 和 **MyISAM**.

| 特性 | InnoDB | MyISAM |
| :--- | :--- | :--- |
| **事务 (Transaction)** | **支持**. 遵循 ACID 模型, 支持提交 (Commit), 回滚 (Rollback), 崩溃恢复. | **不支持**. |
| **锁级别 (Locking)** | **行级锁 (Row-level Lock)**. 也支持表锁. 行级锁在高并发写入时冲突更小, 性能更好. | **表级锁 (Table-level Lock)**. 对表进行写操作时, 会锁定整张表, 并发性能差. |
| **外键 (Foreign Key)** | **支持**. | **不支持**. |
| **崩溃恢复** | **支持**. 通过 redo log 和 undo log 实现. | **不支持**. 容易损坏. |
| **默认引擎** | **是** (从 MySQL 5.5 开始). | 否 (早期版本的默认引擎). |
| **索引结构** | **聚簇索引**. 数据文件本身就是按 B+Tree 组织的索引文件, 叶子节点直接存储行数据. | **非聚簇索引**. 索引 (B+Tree) 和数据是分开的, 索引的叶子节点存储的是数据行的地址. |
| **`SELECT COUNT(*)`**| 需要扫描全表或全索引, 速度较慢. | 内部维护了一个行数计数器, 如果没有 `WHERE` 条件, 查询非常快. |
| **适用场景** | 需要事务和高并发写入的场景, 如订单系统, 金融系统, 是绝大多数应用的首选. | 读密集, 写较少, 对事务完整性要求不高的场景, 如日志表. 但现在已逐渐被 InnoDB 取代. |

**面试总结:** 首选 InnoDB. 它的行级锁和事务支持是现代应用所必需的. MyISAM 的主要优势 (如 `COUNT(*)` 速度) 在大多数场景下已不再重要.

---

### 6. B+树和B树区别

B+树是 B树 的一种优化变体, 专门为磁盘等外部存储设备设计, 也是 MySQL InnoDB 索引的底层数据结构.

**B树 (B-Tree):**
* **数据存储:** **所有节点 (内部节点和叶子节点) 都会存储数据 (或指向数据的指针).**
* **查询:** 查找一个键时, 可能在到达叶子节点之前, 就在某个内部节点上找到了, 查询路径长度不固定.

**B+树 (B+Tree):**
* **数据存储:** **只有叶子节点才存储真正的数据 (或指向数据的指针).** 内部节点只存储索引键, 不存储数据.
* **节点链接:** **所有叶子节点通过一个双向链表连接起来**.
* **查询:** 任何查询都必须从根节点走到某个叶子节点才能命中, 查询路径长度固定.

**B+树作为数据库索引的优势:**

1.  **更适合范围查询:** 由于所有叶子节点都通过链表连接, 当执行范围查询 (如 `WHERE id > 100 AND id < 200`) 时, 只需定位到第一个叶子节点 (100), 然后沿着链表顺序遍历即可, 非常高效. 而 B 树可能需要不断地回溯和遍历树的多个部分.
2.  **更高的"扇出" (Fan-out):** 因为 B+树的内部节点不存储数据, 只存储键, 所以在同样大小的磁盘页 (Page, 如 16KB) 中, B+树的内部节点可以容纳比 B 树更多的键. 更高的扇出意味着树的高度更低, 更扁平. 这大大减少了查找数据时所需的磁盘 I/O 次数, 从而提升了查询性能. **这是最核心的优势.**
3.  **稳定的查询性能:** 任何关键字的查找都必须走一条从根到叶的路径, 查询性能稳定.

---

### 7. redis常用数据结构

Redis 是一个 Key-Value 数据库, 但它的 Value 支持多种复杂的数据结构.

1.  **String (字符串):**
    * **描述:** 最基本的数据类型, 一个 key 对应一个 value. value 最多可以容纳 512MB.
    * **用途:** 缓存 (网页, 对象), 计数器 (`INCR`, `DECR`), 分布式锁 (`SETNX`).

2.  **List (列表):**
    * **描述:** 简单的字符串列表, 按照插入顺序排序. 你可以添加一个元素到列表的头部 (左边) 或尾部 (右边). 底层是双向链表或压缩列表 (ziplist).
    * **用途:** 消息队列 (使用 `LPUSH`/`RPOP` 实现简单的生产者消费者模式), 微博/朋友圈的时间线 (timeline).

3.  **Hash (哈希/字典):**
    * **描述:** 一个键值对 (key-value) 的集合. 一个 key 包含多个 field 和 value 的映射. 非常适合存储对象.
    * **用途:** 存储用户信息 (key: `user:1`, fields: `name`, `age`, `email`), 购物车.

4.  **Set (集合):**
    * **描述:** String 类型的无序集合. 元素是唯一的, 不允许重复.
    * **用途:** 标签 (tags), 共同好友/关注 (交集 `SINTER`), 抽奖系统 (随机取一个 `SRANDMEMBER`).

5.  **Sorted Set (ZSET, 有序集合):**
    * **描述:** 和 Set 类似, 也是不重复的字符串集合, 但每个元素都会关联一个 double 类型的分数 (score). Redis 正是通过分数来为集合中的成员进行从小到大的排序.
    * **用途:** 排行榜 (leaderboard), 带权重的任务队列, 范围查找 (如查找积分在某个区间的用户).

**除了以上五种基础类型, 还可以提一下更高级的来展示知识广度:**
* **Bitmap:** 位图, 可用于状态统计, 如用户签到, 活跃用户统计.
* **HyperLogLog:** 用极小的内存来做基数统计, 如统计页面的 UV.
* **Stream:** Redis 5.0 新增的, 功能更完善的消息队列.

---

希望这份详细的分析和解答能对你有所帮助! 这些问题都非常经典, 深刻理解它们对技术面试和实际工作都大有裨益.
总共80分钟面试
1、自我介绍
2、项目
3、热点key问题怎么解决？
我说了缓存击穿的相关解决方案，如互斥锁或者逻辑过期。但是面试官好像不是问这个。
4、问我还有什么情况会导致热点key，除了你说的redis宕机了，我回答还有过了TTL大量热点key失效。好像回答的也不对。
5、怎么实现缓存和数据库的一致性呢？
我回答的延迟双删，等删除完缓存等一段时间再去删除缓存，但是这个时间要根据测试得到，测试出查询完数据库到更新缓存缓存之间的这个时间，这个时间大概就是两次删除缓存之间的时间；还有就是用分布式队列或者分布式锁去实现，让异步变同步，保证每次只能有一个请求去执行。
6、你的意思是把数据库操作和缓存操作绑定在一起吗？
是的，就是给数据库操作和缓存操作的这个请求加上分布式锁，保证串行执行。
7、id是主键索引，如果我查询了一个非主键索引，执行的大致流程是怎样的？
我说反了，我说成先找到主键索引，再根据主键索引回表找非主键索引，太紧张了。哭死。
是怎么做到有一个程序要执行三个部分，三个部分可以独立执行互不依赖，起三个线程去执行，它是怎么做到去等待这三个线程全执行完再去走下面的流程的？
这个我说了使用倒计时器CountDownLatch，每个任务执行结束就countDown一次，state--，直到三个线程都执行结束，state=0，会unpark()主调用线程，主调用线程从await()方法中恢复过来，执行接下来的代码。
还说了可以使用CompartableFuture里面的API进行异步任务的组合编排
8、你觉得它的通知是及时的吗？unpark()方法底层是怎么通知的？
我回答是及时的，底层调用了unpark会释放锁，然后主线程的await就会获取到锁，就能执行了。但是感觉答错了。
9、还有问我事务的隔离级别？哪种隔离级别可以避免幻读？
四种。然后我回答的是默认的可重复读可以避免大部分的幻读，串行化能完全解决。
10、对于你刚刚说的可重复读他是怎么解决幻读问题的？
我回答有两种方式：一种是MVCC，普通快照读；一种是临键锁next-lock Key。

11、对于你说的能解决大部分幻读问题，那什么情况解决不了幻读问题呢？
我回答当两次快照读中间穿插了一次当前读就会出现幻读问题，但是也不一定如果当前读的修改范围没有覆盖到快照读查询的范围也不会有幻读的出现。
12、算法题我磨蹭了30分钟，没写出来
有三道：一道题是任务编排
12.1 有N个任务，其中[i,j]表示任务i依赖任务j，最后输出任务的编排
示例：[0,1,2]
其中0依赖1，1依赖2
输出[0,1] [1,2]
不会，连题都不理解
12.2 lc的单调栈 写出来了
12.3 有一个时钟，时钟一开始指向12点，时针每次能顺时针走1步或者逆时针走1步，最终回到12点，请问有多少种走法？这个我没思路，没做出来
13、还有一道SQL：
说是两个事务都执行以下SQL，问我最后a的值（a的值原来是1）
begin;
select a from t where id =2;
update t set a = a+1;
commit;
我回答说是事务1在执行update的时候会将数据行锁住，然后事务2会阻塞，等事务1commit了事务2才会执行，所以a的值应该是3.其实我觉得不对但是我感觉他想问我的是两个都同时开始然后交叉执行，所以最先开始的那个事务读到的是a=2，因为MVCC，所以事务1是看不到事务2对它修改的。但是我又觉得它说的是最后一个提交的事务完成后a的值，这样的话就是3呀。这么简单的题我都没说好。
14、你了解设计模式吗？
我说了解工厂模式、生产者消费者模式以及单例模式，然后他让我手写一个工厂模式
我当时有点紧张，没写出来，就写了一个框架。写的是简单工厂模式，我说涉及三个角色：抽象产品、具体产品和工厂。
抽象产品是个接口，里面有抽象方法。
具体产品是对抽象产品的实现类，实现了里面的抽象方法。
工厂负责生产。我举得是支付的场景：微信支付和支付宝支付。
最后我还多说了工厂方法模式的话是涉及四个角色：抽象产品、具体产品、抽象工厂和具体工厂。对支付的场景简单说了一下
15、接着问我那工厂方法模式有什么优点？
我说简单工厂不符合OCP原则，他问我什么是OCP原则，我说是开闭原则。我说简单工厂如果要加代码的话需要修改工厂类的代码，不符合OCP；如果是工厂方法模式的话只需要多写几个类，再实现一个工厂类就行。
16、还有什么其他的优点吗？我没想出来了。
17、反问：你还有什么想要问我的吗？
我说这边的业务是什么？然后他问我用过他们的番茄小说吗？我说我没看过小说。。。
加入我去了实习，我要做什么工作？
你希望候选人有什么样的品质？
我们这个大概有几轮面试？3-4轮。
真的是纯技术，没有一句废话
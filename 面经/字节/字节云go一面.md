自我介绍
业务介绍
项目拷打
MVC架构是什么
meilisearch的底层原理（倒排索引和前缀树的实现）
推模型与拉模型的区别
点对点通信
怎么设计一个合适的高并发推拉模型
gmp并发模型
为什么go要设计这个模型
gc回收
混合写屏障在那个时间段运行的
内存逃逸分析
内存为什么要设置堆与栈
Linux的虚拟地址相关
进程与线程区别
四大事务隔离级别，常用哪种，解决了那些事情
Redis高并发怎么做的
Redis zset 数据结构
docker实现原理
手撕 字符串解码（就差一行代码怎么都想不起来怎么做）
### MVC 架构是什么
MVC 是一种经典的软件架构模式, 旨在将应用程序的用户界面和底层业务逻辑分离, 以提高代码的可维护性, 可扩展性和可测试性.
  * **M - Model (模型):**
      * **职责:** 负责应用程序的 **业务逻辑和数据状态**. 它封装了数据 (比如从数据库中获取的用户对象) 以及操作这些数据的方法. Model 不关心数据如何展示, 只关心数据本身和业务规则.
  * **V - View (视图):**
      * **职责:** 负责 **数据的展示和用户界面 (UI)**. 它从 Model 获取数据, 并将其呈现给用户. View 本身不包含任何业务逻辑, 它是一个纯粹的展示层.
  * **C - Controller (控制器):**
      * **职责:** 作为 **模型和视图之间的协调者**. 它接收用户的输入 (例如, HTTP 请求), 解析请求, 然后调用相应的 Model 来处理业务逻辑, 最后选择一个合适的 View 来呈现结果.
**工作流程 (以 Web 应用为例):**
1.  用户在浏览器中操作, 发起一个 HTTP 请求.
2.  控制器 (Controller) 接收并解析这个请求.
3.  控制器调用模型 (Model) 的方法, 以更新数据或获取数据.
4.  模型处理完业务逻辑后, 将结果返回给控制器.
5.  控制器将模型返回的数据传递给视图 (View).
6.  视图使用这些数据渲染成最终的 HTML 页面, 返回给浏览器.
**核心思想:** **关注点分离 (Separation of Concerns)**. 每个组件只做自己的事, 互不干扰, 从而使系统更加模块化.
-----
### Meilisearch 的底层原理 (倒排索引和前缀树的实现)
Meilisearch 以其极快的搜索速度和"开箱即用"的体验著称, 其核心依赖于几个关键的数据结构和算法, 其中最重要的是倒排索引和为前缀搜索优化的数据结构.
  * **倒排索引 (Inverted Index):**
      * 这是所有现代搜索引擎的基石. 传统的正向索引是 `文档ID -> 文档内容`, 而倒排索引正好相反, 它的结构是 **`词元 (Token) -> 包含该词元的文档列表`**.
      * **实现过程:**
        1.  **分词 (Tokenization):** 将文档内容切分成一个个独立的词元 (单词).
        2.  **标准化 (Normalization):** 将词元转换为标准形式 (如转为小写, 去除词根等).
        3.  **建立索引:** 创建一个字典, key 是标准化后的词元, value 是一个列表 (Posting List), 列表中记录了所有包含该词元的文档 ID, 以及词元在该文档中出现的位置, 频率等信息.
      * **查询:** 当用户搜索 "apple" 时, Meilisearch 不需要遍历所有文档, 而是直接在倒排索引这个 "字典" 中查找 "apple" 这个 key, 瞬间就能拿到所有包含 "apple" 的文档列表, 极大地提高了查询效率.
  * **前缀树的实现 (Prefix Trees / Tries):**
      * Meilisearch 的"搜索即输入 (search-as-you-type)"功能非常快, 这主要归功于对前缀搜索的极致优化. 虽然它不直接使用经典的前缀树 (Trie), 而是使用一种更高效的变体, 叫做 **Finite State Transducer (FST)**, 但其原理与前缀树相通.
      * **前缀树 (Trie):** 是一种树形结构, 每个节点代表一个字符. 从根节点到某个节点的路径就构成一个单词或前缀.
      * **FST:** 你可以把它理解为一个 **压缩过的前缀树**. 它将共享的后缀合并, 极大地减少了内存占用. 在 FST 中, 从根节点到任意节点的路径不仅能形成一个词, 还能关联一个输出值 (比如词频或内部ID).
      * **查询:** 当用户输入 "app" 时, Meilisearch 可以在 FST 中快速遍历 `a -> p -> p` 这条路径, 然后从这个节点出发, 找到所有可能的后续路径, 从而得到所有以 "app" 开头的词及其关联的文档列表, 响应速度极快.
**总结:** Meilisearch 通过 **倒排索引** 实现了快速的全文匹配, 通过 **FST (一种高度优化的前缀树)** 实现了闪电般的前缀搜索和自动补全.
-----
### 推模型与拉模型的区别 / 怎么设计一个合适的高并发推拉模型
  * **拉模型 (Pull Model):**
      * **定义:** 由 **客户端** 主动发起请求, 向服务器拉取数据.
      * **例子:** 浏览器访问网页, Prometheus 定时去拉取监控指标.
      * **优点:** 客户端控制节奏, 实现简单, 服务器无状态.
      * **缺点:** 实时性差, 如果没有新数据, 会产生很多无效的轮询请求.
  * **推模型 (Push Model):**
      * **定义:** 由 **服务器** 主动发起, 将数据推送给客户端.
      * **例子:** 手机推送通知, WebSocket 实时消息.
      * **优点:** 实时性好, 节省了无效轮询的开销.
      * **缺点:** 需要服务器维护与客户端的长连接, 对服务器资源消耗大, 实现更复杂.
**设计一个合适的高并发推拉模型:**
一个好的设计通常是 **推拉结合, 各取所长**. 以一个 **IM 即时通讯系统** 为例:
1.  **核心通信用"推" (保证实时性):**
      * 用户登录后, 客户端会与一台 **长连接网关 (Connection Gateway)** 建立一个 **WebSocket** 连接.
      * 当用户A给用户B发送消息时, 消息会经过业务服务器, 然后被投递到用户B所连接的那台长连接网关, 网关再通过 WebSocket **主动推送** 给用户B的客户端.
      * 这个长连接网关层需要被设计成高可用的集群, 能够支持海量的并发连接. Go 语言非常适合做这个.
2.  **消息可靠性用"拉" (保证不丢):**
      * 所有消息在被推送的同时, 都会在服务器端写入一个 **"收件箱"** (可以用 Redis 的 ZSET 或专业的时序数据库实现).
      * 当客户端因为网络问题断线重连, 或者从后台切换回前台时, 它会主动向服务器发起一个 **拉取请求**, 比如 `pull_messages(last_message_id)`.
      * 服务器会从"收件箱"中拉取所有在 `last_message_id` 之后的消息, 一次性返回给客户端, 保证了消息的最终可达性.
3.  **系统设计要点:**
      * **长连接网关:** 需要水平扩展, 并且需要一个注册中心 (如 Redis) 来维护 `userId` 和其所连接的网关服务器地址的映射关系.
      * **消息总线:** 在业务服务器和长连接网关之间引入消息队列 (如 Kafka), 进行解耦和削峰填谷.
      * **离线推送:** 对于完全离线的用户, 消息会被投递到第三方推送服务 (APNs, FCM), 这是一个典型的"推"模型应用.
-----
### Go 并发模型 (GMP) / 为什么 Go 要设计这个模型
**GMP 模型:**
GMP 是 Go 语言运行时调度器的核心, 是其高并发能力的基础.
  * **G (Goroutine):** Go 语言中的轻量级用户态线程, 是并发执行的基本单位.
  * **M (Machine):** 内核线程, 是操作系统进行调度的实体, 真正干活的人.
  * **P (Processor):** 逻辑处理器, 是 G 和 M 之间的中间层. P 维护了一个可运行的 Goroutine 队列 (Local Run Queue). M 必须绑定一个 P 才能执行 P 队列中的 G. P 的数量通常由 `GOMAXPROCS` 决定, 默认为 CPU 核心数.
**为什么 Go 要设计这个模型?**
Go 设计 GMP 模型的根本目的是为了在多核时代, **以最低的开销, 最大化地利用 CPU 资源, 同时为开发者提供极其简单的并发编程体验.**
1.  **避免内核级线程的昂贵开销:** 传统的线程模型 (1:1, 一个用户线程对应一个内核线程) 创建和切换成本都很高. Go 的 GMP 模型 (M:N) 将成千上万的 G 复用到少数几个 M 上, 绝大多数的 G 切换都在用户态由 Go 的调度器完成, 速度极快.
2.  **充分利用多核:** 通过设置 P 的数量等于 CPU 核心数, Go 可以保证在理想情况下, 每个 CPU 核心上都有一个 M 在不停地执行 G, 实现了真正的并行计算.
3.  **解决阻塞问题 (Work Stealing):** 如果一个 M 在执行某个 G 时, G 因为系统调用 (如文件 IO) 而阻塞, 这个 M 会和它的 P 解绑, 但 P 不会闲着, Go 的调度器会寻找另一个空闲的 M 来绑定这个 P, 继续执行 P 队列中其他的 G. 同时, 当一个 P 的任务队列为空时, 它可以从其他 P 的队列中 "窃取" 一些 G 来执行, 进一步提高了 CPU 的利用率.
**总结:** GMP 模型是 Go 对操作系统线程模型的一次重大革新, 它通过在用户态实现一个高效的调度器, 巧妙地解决了线程开销大和调度效率低的问题.
-----
### Go GC 回收 / 混合写屏障在那个时间段运行的
**Go GC 回收:**
Go 使用的是 **三色标记清除法 (Tri-color Mark-and-Sweep)** 的并发垃圾回收器. 其主要目标是在进行垃圾回收时, 尽可能地减少对用户程序造成的暂停 (Stop The World, STW) 时间.
**混合写屏障 (Hybrid Write Barrier):**
混合写屏障是 Go 1.8 引入的一项关键技术, 用来保证在并发标记阶段, 数据一致性不出错 (即不会把存活的对象误认为垃圾).
**运行时间段:**
混合写屏障 **只在 GC 的并发标记阶段 (Marking Phase) 处于开启状态并运行**.
具体来说, 一个 GC 周期分为几个阶段:
1.  **标记准备 (Mark Setup - STW):** 一个非常短暂的 STW, 主要工作是开启写屏障.
2.  **并发标记 (Marking - Concurrent):**
      * 这是 GC 的主要工作时间, GC 的标记协程和用户的 Goroutine **并行执行**.
      * **就在这个阶段, 每当用户的 Goroutine 尝试在堆上执行一次指针写入操作时, 混合写屏障就会被触发.**
      * 写屏障的作用是: 如果一个黑色对象 (已被扫描) 指向了一个白色对象 (未被扫描), 它会把这个白色对象涂成灰色, 以确保 GC 后续能扫描到它, 防止对象丢失.
3.  **标记终止 (Mark Termination - STW):** 第二个短暂的 STW, 完成标记工作, 关闭写屏障.
4.  **并发清除 (Sweeping - Concurrent):** GC 清理未被标记的垃圾对象, 这个过程也和用户 Goroutine 并行.
所以, 混合写屏障并不是一直运行, 而是作为 GC 并发标记阶段的一个"保护性"机制, 在后台默默工作.
-----
### 内存逃逸分析 / 内存为什么要设置堆与栈
  * **内存逃逸分析 (Escape Analysis):**
      * 这是 Go 编译器在 **编译阶段** 进行的一项优化分析.
      * **目的:** 判断一个变量的生命周期是否会超出其所在的函数栈. 如果不会, 就将其分配在 **栈 (Stack)** 上; 如果会, 就必须将其分配在 **堆 (Heap)** 上, 这个过程就称为"逃逸".
      * **逃逸场景:**
          * **指针返回:** 函数返回了对一个局部变量的指针.
          * **被闭包引用:** 变量被一个闭包函数引用, 而闭包可能在函数返回后被调用.
          * **发送到 channel:** 将变量的指针发送到 channel 中.
          * **动态类型逃逸:** `fmt.Println` 这样的函数接受 `interface{}` 参数, 编译器无法在编译期确定其具体类型和大小, 通常会导致逃逸.
          * **栈空间不足:** 分配的变量过大, 超出了当前栈的容量.
  * **为什么要设置堆与栈?**
    这是操作系统内存管理的经典设计, 目的是为了在 **性能** 和 **灵活性** 之间取得平衡.
      * **栈 (Stack):**
          * **优点:** 管理非常高效. 内存分配和释放只是移动一下栈顶指针, 几乎没有开销. 访问速度快 (局部性原理).
          * **缺点:** 空间有限, 且生命周期与函数绑定, 不够灵活.
          * **用途:** 存储函数调用时的局部变量, 函数参数, 返回地址等.
      * **堆 (Heap):**
          * **优点:** 空间大, 生命周期灵活, 可以在程序的任何地方申请和释放.
          * **缺点:** 管理成本高. 分配和释放内存需要复杂的算法 (如 Go 的 GC), 容易产生内存碎片, 访问速度相对较慢.
          * **用途:** 存储那些生命周期不确定的, 或者多个函数/goroutine 需要共享的数据.
**总结:** **栈追求的是极致的分配和回收效率, 堆追求的是灵活的生命周期管理.** Go 的逃逸分析就是尽可能地让变量留在栈上, 以减轻堆分配的压力和 GC 的负担, 从而提升程序性能.
-----
### Linux 的虚拟地址相关 / 进程与线程区别
  * **Linux 的虚拟地址:**
      * 虚拟地址是现代操作系统提供给每个进程的一个核心抽象. 它让每个进程都"以为"自己独占了一块巨大, 连续, 从 0 开始的内存空间.
      * **作用:**
        1.  **隔离性:** 每个进程的虚拟地址空间都是独立的, 一个进程无法直接访问另一个进程的内存, 保证了系统的安全和稳定.
        2.  **内存管理:** 操作系统通过 **页表 (Page Table)** 将虚拟地址映射到物理内存地址上. 这使得物理内存可以被不连续地使用, 并且可以通过页面置换算法, 将不常用的内存页换出到磁盘 (Swap), 从而让程序可以使用比实际物理内存更大的空间.
        3.  **简化编程:** 程序员无需关心物理内存的碎片化和具体地址, 只需在逻辑上管理自己的虚拟地址空间即可.
  * **进程与线程区别:**
      * **进程 (Process):** 是操作系统进行 **资源分配和调度** 的基本单位. 它是一个"重量级"的实体, 拥有自己独立的地址空间, 文件描述符, 程序计数器等.
      * **线程 (Thread):** 是 **CPU 调度和分派** 的基本单位, 它被包含在进程之中, 是进程中的实际运作单位.
      * **核心区别:**
        1.  **资源:** 进程是拥有资源的基本单位, 线程是共享进程资源的基本单位. 同一个进程内的所有线程共享该进程的地址空间, 文件等资源.
        2.  **开销:** 创建进程和进行进程间切换的开销远大于线程. 因为进程切换需要切换整个页表和内核状态, 而线程切换只需要保存和恢复少量寄存器状态.
        3.  **通信:** 进程间通信 (IPC) 需要借助操作系统提供的复杂机制 (如管道, 信号量, 共享内存). 线程间通信则非常方便, 可以直接读写共享的进程内存 (但需要注意同步和加锁).
-----
### 四大事务隔离级别, 常用哪种, 解决了那些事情
1.  **Read Uncommitted (读未提交):** 级别最低. 一个事务可以读取到另一个事务 **未提交** 的数据. 会产生 **脏读**.
2.  **Read Committed (读已提交):** 一个事务只能读取到其他事务 **已经提交** 的数据. 解决了 **脏读**. 但可能产生 **不可重复读** (同一事务内, 多次读取同一行数据, 结果可能不同).
3.  **Repeatable Read (可重复读):** 保证在同一个事务中, 多次读取同一行数据, 结果都是一致的. 解决了 **不可重复读**. 但可能产生 **幻读** (同一事务内, 多次执行范围查询, 结果集中的记录数可能不同).
4.  **Serializable (串行化):** 级别最高. 强制事务串行执行, 避免了所有并发问题, 包括 **幻读**. 但性能最差.
<!-- end list -->
  * **常用哪种:**
      * **MySQL (InnoDB): 默认是 `Repeatable Read`**. 它通过 MVCC 和 Next-Key Lock 机制, 在很大程度上解决了幻读问题, 是一个兼顾了性能和一致性的选择.
      * **PostgreSQL, Oracle 等: 默认是 `Read Committed`**. 它们认为不可重复读在很多业务场景下是可以接受的, 而这个级别能提供更好的并发性能.
-----
### Redis 高并发怎么做的 / Redis zset 数据结构
  * **Redis 高并发怎么做的:**
    1.  **完全基于内存:** 所有操作都在内存中完成, 速度极快, 这是其性能的基石.
    2.  **单线程模型:** Redis 的核心命令执行模块是单线程的. 这避免了多线程环境下复杂的上下文切换和锁竞争开销.
    3.  **I/O 多路复用:** Redis 使用了 `epoll` (Linux下) 这样的 I/O 多路复用技术. 它可以在一个线程内, 高效地处理成千上万个客户端的网络连接, 而不会被某个慢速的连接阻塞. 这是其能够支撑高并发连接的关键.
    4.  **高效的数据结构:** 为不同的场景设计了专门优化的数据结构, 如 SDS, ziplist, skiplist 等.
  * **Redis zset 数据结构:**
    `zset` (有序集合) 是 Redis 中一个非常强大的数据结构. 它的底层实现是 **跳表 (Skip List)** 和 **哈希表 (Hash Table)** 的组合.
      * **哈希表:** 存储了 `成员(member) -> 分数(score)` 的映射. 这使得通过成员名来查找其分数的操纵时间复杂度是 O(1).
      * **跳表:** 存储了所有成员, 并按照分数进行排序. 这使得范围查询 (如获取排行榜前 10 名) 和按分数查找的操作时间复杂度是 O(logN).
通过这两种数据结构的组合, `zset` 既能实现快速的单点查询, 又能实现高效的范围查询.
-----
### Docker 实现原理
Docker 并不是一个虚拟机, 它是一种轻量级的操作系统层虚拟化技术. 它的实现主要依赖于 Linux 内核提供的两个核心特性:
1.  **命名空间 (Namespaces):** 这是实现 **隔离** 的关键. Docker 为每个容器创建了独立的命名空间, 让容器内的进程"以为"自己在一个独立的操作系统中运行.
      * `PID namespace`: 拥有独立的进程树.
      * `NET namespace`: 拥有独立的网络协议栈 (IP地址, 路由表, 端口等).
      * `MNT namespace`: 拥有独立的文件系统挂载点.
      * ... 等等.
2. **控制组 (Control Groups, cgroups):** 这是实现 **资源限制** 的关键. cgroups 可以限制一个容器能使用的 CPU, 内存, 磁盘 I/O 等资源的上限, 防止某个容器耗尽宿主机的资源.
3. **镜像 (Image):** Docker 镜像通过 **联合文件系统 (UnionFS)** 实现. 镜像由多个只读的层 (Layer) 构成, 当容器启动时, 会在这些只读层之上再挂载一个可写的容器层. 这种分层结构使得镜像的复用, 存储和分发都非常高效.
**总结:** Docker = **命名空间 (隔离)** + **控制组 (限制)** + **联合文件系统 (镜像)**.
### 手撕 字符串解码 (就差一行代码怎么都想不起来怎么做)
这个问题通常是类似 `3[a2[c]]` -\> `accaccacc` 的解码. 这是一个经典的可以用 **栈** 来解决的问题. 想不起来的那一行很可能就是出栈时拼接字符串和数字的关键逻辑.
"好的, 这个问题我之前遇到过. 它的核心是处理括号的嵌套和数字的重复, 用两个栈, 一个存数字, 一个存字符串, 会非常清晰."
```go
import (
    "strings"
    "unicode"
)
func decodeString(s string) string {
    // numStack 存储'['之前的数字
    numStack := []int{}
    // strStack 存储'['之前的字符串
    strStack := []string{}
    var currentNum int
    var currentStr strings.Builder
    for _, char := range s {
        if unicode.IsDigit(char) {
            // 解析数字
            currentNum = currentNum*10 + int(char-'0')
        } else if char == '[' {
            // 遇到'[' , 将当前数字和字符串入栈
            numStack = append(numStack, currentNum)
            strStack = append(strStack, currentStr.String())
            // 重置, 为括号内的内容做准备
            currentNum = 0
            currentStr.Reset()
        } else if char == ']' {
            // 遇到']', 开始解码
            // 1. 弹出'['前的数字
            repeatCount := numStack[len(numStack)-1]
            numStack = numStack[:len(numStack)-1]
            // 2. 弹出'['前的字符串
            prevStr := strStack[len(strStack)-1]
            strStack = strStack[:len(strStack)-1]
            // 3. 构建解码后的字符串
            // 很多时候就是下面这一行逻辑会卡住
            // 将当前括号内的字符串(currentStr)重复N次, 然后拼接到括号前的字符串(prevStr)之后
            decodedPart := strings.Repeat(currentStr.String(), repeatCount)
            // 更新 currentStr 为拼接后的结果
            currentStr.Reset()
            currentStr.WriteString(prevStr)
            currentStr.WriteString(decodedPart)
        } else {
            // 普通字符, 直接拼接
            currentStr.WriteRune(char)
        }
    }
    return currentStr.String()
}
```
"关键就是处理右括号 `]` 的时候, 需要从栈里取出之前保存的状态 (重复次数和前缀字符串), 然后进行 `strings.Repeat` 和拼接操作, 更新当前正在构建的字符串. 这一步是整个逻辑的核心."
### 点对点通信
“点对点 (Peer-to-Peer, P2P) 通信是一种网络架构, 在这种架构中, 网络的参与者 (Peers) 直接相互通信, 而不需要通过一个中心化的服务器进行中转. 每个节点既是客户端, 也是服务器.
  * **例子:** 最经典的例子是 BitTorrent 下载. 当你下载一个文件时, 你会从一个中心化的 Tracker 服务器获取其他正在下载/拥有该文件的 Peer 的列表, 但之后的文件数据传输, 是直接在你的电脑和这些 Peer 之间进行的.
  * **优点:**
      * **可扩展性强:** 参与者越多, 网络的总带宽和服务能力也越强.
      * **鲁棒性高:** 没有中心服务器这个单点故障.
  * **挑战:**
      * **节点发现:** 如何找到其他节点是一个难题.
      * **NAT 穿透:** 大部分用户都在路由器后面 (NAT), 两个处于不同 NAT 后面的节点要建立直接连接非常困难.
      * **安全和管理:** 不易管理和保证内容的安全.”
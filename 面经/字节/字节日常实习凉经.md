总共80分钟面试
1、自我介绍
2、项目
3、热点key问题怎么解决？
我说了缓存击穿的相关解决方案，如互斥锁或者逻辑过期。但是面试官好像不是问这个。
4、问我还有什么情况会导致热点key，除了你说的redis宕机了，我回答还有过了TTL大量热点key失效。好像回答的也不对。
5、怎么实现缓存和数据库的一致性呢？
我回答的延迟双删，等删除完缓存等一段时间再去删除缓存，但是这个时间要根据测试得到，测试出查询完数据库到更新缓存缓存之间的这个时间，这个时间大概就是两次删除缓存之间的时间；还有就是用分布式队列或者分布式锁去实现，让异步变同步，保证每次只能有一个请求去执行。
6、你的意思是把数据库操作和缓存操作绑定在一起吗？
是的，就是给数据库操作和缓存操作的这个请求加上分布式锁，保证串行执行。
7、id是主键索引，如果我查询了一个非主键索引，执行的大致流程是怎样的？
我说反了，我说成先找到主键索引，再根据主键索引回表找非主键索引，太紧张了。哭死。

是怎么做到有一个程序要执行三个部分，三个部分可以独立执行互不依赖，起三个线程去执行，它是怎么做到去等待这三个线程全执行完再去走下面的流程的？
这个我说了使用倒计时器CountDownLatch，每个任务执行结束就countDown一次，state--，直到三个线程都执行结束，state=0，会unpark()主调用线程，主调用线程从await()方法中恢复过来，执行接下来的代码。
还说了可以使用CompartableFuture里面的API进行异步任务的组合编排
8、你觉得它的通知是及时的吗？unpark()方法底层是怎么通知的？
我回答是及时的，底层调用了unpark会释放锁，然后主线程的await就会获取到锁，就能执行了。但是感觉答错了。
9、还有问我事务的隔离级别？哪种隔离级别可以避免幻读？
四种。然后我回答的是默认的可重复读可以避免大部分的幻读，串行化能完全解决。
10、对于你刚刚说的可重复读他是怎么解决幻读问题的？
我回答有两种方式：一种是MVCC，普通快照读；一种是临键锁next-lock Key。

11、对于你说的能解决大部分幻读问题，那什么情况解决不了幻读问题呢？
我回答当两次快照读中间穿插了一次当前读就会出现幻读问题，但是也不一定如果当前读的修改范围没有覆盖到快照读查询的范围也不会有幻读的出现。
12、算法题我磨蹭了30分钟，没写出来
有三道：一道题是任务编排
12.1 有N个任务，其中[i,j]表示任务i依赖任务j，最后输出任务的编排
示例：[0,1,2]
其中0依赖1，1依赖2
输出[0,1] [1,2]
不会，连题都不理解
12.2 lc的单调栈 写出来了
12.3 有一个时钟，时钟一开始指向12点，时针每次能顺时针走1步或者逆时针走1步，最终回到12点，请问有多少种走法？这个我没思路，没做出来
13、还有一道SQL：
说是两个事务都执行以下SQL，问我最后a的值（a的值原来是1）
begin;
select a from t where id =2;
update t set a = a+1;
commit;
我回答说是事务1在执行update的时候会将数据行锁住，然后事务2会阻塞，等事务1commit了事务2才会执行，所以a的值应该是3.其实我觉得不对但是我感觉他想问我的是两个都同时开始然后交叉执行，所以最先开始的那个事务读到的是a=2，因为MVCC，所以事务1是看不到事务2对它修改的。但是我又觉得它说的是最后一个提交的事务完成后a的值，这样的话就是3呀。这么简单的题我都没说好。
14、你了解设计模式吗？
我说了解工厂模式、生产者消费者模式以及单例模式，然后他让我手写一个工厂模式
我当时有点紧张，没写出来，就写了一个框架。写的是简单工厂模式，我说涉及三个角色：抽象产品、具体产品和工厂。
抽象产品是个接口，里面有抽象方法。
具体产品是对抽象产品的实现类，实现了里面的抽象方法。
工厂负责生产。我举得是支付的场景：微信支付和支付宝支付。
最后我还多说了工厂方法模式的话是涉及四个角色：抽象产品、具体产品、抽象工厂和具体工厂。对支付的场景简单说了一下
15、接着问我那工厂方法模式有什么优点？
我说简单工厂不符合OCP原则，他问我什么是OCP原则，我说是开闭原则。我说简单工厂如果要加代码的话需要修改工厂类的代码，不符合OCP；如果是工厂方法模式的话只需要多写几个类，再实现一个工厂类就行。
16、还有什么其他的优点吗？我没想出来了。
17、反问：你还有什么想要问我的吗？
我说这边的业务是什么？然后他问我用过他们的番茄小说吗？我说我没看过小说。。。
加入我去了实习，我要做什么工作？
你希望候选人有什么样的品质？
我们这个大概有几轮面试？3-4轮。
真的是纯技术，没有一句废话

非常感谢你对这次面试的复盘, 这种详细的自我剖析是成长最快的方式. 面试紧张是很正常的, 很多时候明明知道但就是说不清楚. 我们一起来把这些问题捋顺, 看看面试官可能在考察什么, 以及更优的回答方式是什么.

-----

### 3 & 4. 热点 Key 问题

  * **你的回答分析:** 你提到的缓存击穿(互斥锁, 逻辑过期)和 TTL 集中失效(导致雪崩)都是热点 Key 可能引发的问题, 这说明你对缓存的基础知识是掌握的. 面试官觉得不对, 很可能是他想考察一个你没提到的, 但非常经典的场景.

  * **面试官的意图:** 他可能在区分**缓存击穿**和**缓存穿透**. 你回答的是前者(数据在DB里有, 缓存里没了), 而他可能想听的是后者(数据在DB和缓存里都没有).

  * **更全面的回答:**
    “热点 Key 问题可以从两个维度看: ‘怎么产生的’和‘会造成什么后果’.”

    **产生原因:**

    1.  **业务上的热点:** 比如秒杀活动的商品, 或者一条热搜新闻, 这是天然的热点.
    2.  **集中过期:** 像您说的, 大量 Key 设置了相同的 TTL, 在同一时间集体失效, 导致所有请求瞬间打到数据库, 造成“缓存雪崩”.
    3.  **缓存重建失败:** 比如你提到的, 缓存失效后, 所有请求都去加载数据, 造成“缓存击穿”.

    **导致的后果及解决方案:**

    4.  **缓存击穿 (Breakdown):** 一个 Key 非常热, 它失效的瞬间, 大量并发请求打进来.
          * **解决方案:** **互斥锁/分布式锁** (只让一个请求去加载数据, 其他请求等待), **逻辑过期** (不设置物理 TTL, 而是在 value 中存一个过期时间, 由一个后台线程异步更新). (你的回答是正确的)
    5.  **缓存穿透 (Penetration):** **这可能是面试官想听到的**. 指的是大量请求访问一个 **数据库和缓存中都不存在** 的 Key. 这样所有的请求都会绕过缓存, 直接打到数据库.
          * **解决方案:** **缓存空值** (查询数据库为空后, 在缓存中也存一个空值, 但 TTL 设置短一些), 或者使用 **布隆过滤器 (Bloom Filter)** 在访问缓存前就拦截掉这些不存在的 Key.
    6.  **资源瓶颈:** 单个热点 Key 会把所有请求都路由到缓存集群的某一个节点上, 可能导致该节点的 **网络带宽或 CPU 被打满**.
          * **解决方案:** **多级缓存** (在业务服务器上用本地缓存如 Guava Cache/Caffeine 做一级缓存), 或者将 **热点 Key 复制多份** (如 `hotkey:1`, `hotkey:2`), 随机访问其中一个副本, 分摊压力.

-----

### 5 & 6. 缓存和数据库的一致性

  * **你的回答分析:** "延迟双删" 是一个比较古老且有缺陷的方案, 你能意识到它的延迟时间不好确定, 这很好. 提到分布式队列是正确的方向, 但说"异步变同步"有点模糊. 把数据库和缓存操作加分布式锁, 是为了保证原子性, 但这会让性能急剧下降, 违背了用缓存的初衷, 所以面试官才会追问.

  * **面试官的意图:** 考察你对主流数据一致性方案的了解, 以及对各种方案优缺点的权衡.

  * **更优的回答:**
    “保证缓存和数据库的强一致性非常困难且影响性能. 在绝大多数互联网场景下, 我们追求的是 **最终一致性**. 目前业界最推荐和可靠的方案是 **基于 Binlog 的异步更新**.”

    **方案流程:**

    1.  **数据库操作:** 应用程序正常地对 MySQL 进行增删改.
    2.  **Binlog 订阅:** 我们引入一个中间件, 如 **Canal**, 它会伪装成一个 MySQL 的从库, 去订阅主库的 `binlog` (二进制日志).
    3.  **投递到消息队列:** Canal 解析 `binlog`, 捕获到数据的具体变更后, 将这些变更信息作为一条消息投递到 **MQ** (如 RabbitMQ, Kafka).
    4.  **异步消费与更新缓存:** 有一个专门的 **消费者服务** 来订阅这个 MQ. 当它收到消息后, 再去执行 **更新或删除缓存** 的操作.

    **优点:**

      * **业务解耦:** 应用程序完全不需要关心缓存的维护, 职责单一.
      * **高可靠:** MQ 保证了消息的可靠投递, 即使消费者服务宕机, 重启后也能继续消费, 不会丢失缓存更新事件.
      * **高性能:** 核心业务逻辑的执行速度不受缓存操作的影响.

    “对于您问的是否要把它们绑定在一起, 使用 Canal 这种方式就避免了业务代码的绑定, 而是通过监听数据源的变更日志来驱动缓存更新, 是一种更优雅的解耦方式.”

-----

### 7. 非主键索引的查询流程

  * **你的回答分析:** 你自己已经发现了说反了, 这是面试紧张时常有的口误, 不用太灰心.
  * **面试官的意图:** 考察对 InnoDB 索引结构的底层理解.
  * **正确流程:**
    1.  查询首先通过 **二级索引 (非主键索引)** 的 B+ 树, 查找到包含查询值的叶子节点.
    2.  在二级索引的叶子节点中, 存储的不是完整的数据行, 而是 **索引列的值** 和对应行的 **主键值**.
    3.  拿到主键值后, 数据库会再根据这个主键值, 去 **聚簇索引 (主键索引)** 的 B+ 树中进行一次查询.
    4.  在聚簇索引的叶子节点中, 存储了完整的行数据. 最终在这里找到数据并返回.
    <!-- end list -->
      * 这个 **“先查二级索引, 再查主键索引”** 的过程, 就叫做 **回表 (Key Lookup)**.

-----

### 7.1 问题在 Go 中的问法和回答
面试官可能会这样问:
"如果我有一个任务, 需要并发地执行三个独立的子任务, 并且要等这三个子任务全部完成后才能继续执行主流程. 在 Go 里面, 你会怎么实现?"
你的回答:
“在 Go 中, 解决这个问题最地道, 最常用的工具是 sync 包中的 WaitGroup. 它的设计初衷就是为了等待一组 Goroutine 完成.”
第一部分: 如何实现 (How)
“我会这样来实现:
1. 首先, 初始化一个 `sync.WaitGroup`, 我们叫它 `wg`.
2. 在启动 Goroutine 之前, 调用 `wg.Add(3)`, 将等待的计数器设置为 3.
3. 然后, 启动三个 Goroutine 去分别执行这三个子任务.
4. 在每个 Goroutine 的业务逻辑执行完毕后, 调用 `wg.Done()` 来通知 `WaitGroup` 该任务已完成 (计数器减一). 为了确保任务无论如何都能调用 `Done`, 通常会使用 `defer wg.Done()`.
5. 在主 Goroutine 中, 调用 `wg.Wait()`. 主 Goroutine 会在这里**阻塞**, 直到 `WaitGroup` 的计数器减到 0.
6. 一旦三个子任务都调用了 `Done()`, 计数器归零, `wg.Wait()` 就会返回, 主 Goroutine 继续执行后续流程.”
**代码示例:**
```go
package main
import (
    "fmt"
    "sync"
    "time"
)
func worker(id int, wg *sync.WaitGroup) {
    // defer 确保在函数退出时, 一定会调用 Done()
    defer wg.Done() 
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second) // 模拟耗时操作
    fmt.Printf("Worker %d done\n", id)
}
func main() {
    var wg sync.WaitGroup
    // 启动3个 worker goroutine
    for i := 1; i <= 3; i++ {
        wg.Add(1) // 每次启动前, 计数器加一
        go worker(i, &wg)
    }
    fmt.Println("Main: Waiting for workers to finish...")
    // Wait 会阻塞, 直到 wg 的计数器归零
    wg.Wait()
    fmt.Println("Main: All workers have finished. Proceeding.")
}
```
“除了 `WaitGroup`, 也可以用 Channel 来实现, 比如创建一个 channel, 每个任务完成后向 channel 发送一个信号, 主 Goroutine 接收三次信号即可. 但对于这种纯粹的‘等待完成’场景, `WaitGroup` 的意图更清晰, 也更高效.”
### 问题 8 (Go 版本): 你觉得它的通知是及时的吗？`wg.Wait()` 底层是怎么被唤醒的？
你对 Java 中 `unpark()` 的回答感觉错了, 这种直觉是对的. 它和锁 (Monitor Lock) 的获取/释放关系不大, 而是更底层的线程调度原语. 在 Go 中, 这个问题的答案则完全围绕着 **Go 的运行时调度器 (runtime scheduler)**.
你的回答:
“是的, WaitGroup 的通知非常及时, 因为它是由 Go 语言自己的运行时调度器直接管理的, 效率极高.”
底层唤醒原理:
“您之前 Java 面试中提到的 unpark 会释放锁的说法确实不准确. 在 Go 中, wg.Wait() 的唤醒机制也和我们常规理解的 Mutex 锁不同, 它不涉及锁的竞争, 而是一个 Goroutine 状态的转换和调度过程:
1. **阻塞 (Parking):**
    - 当主 Goroutine 调用 `wg.Wait()` 时, 它会检查 `WaitGroup` 内部的计数器.
    - 如果计数器不为 0, Go 的运行时调度器会介入. 它会将主 Goroutine 的状态从 `_Grunning` (运行中) 切换为 **`_Gwaiting` (等待中)**.
    - 这个 `_Gwaiting` 状态的 Goroutine 会被从它的逻辑处理器 (P) 的可运行队列中移除, 然后被"停放 (park)"起来, 等待被唤醒. 它所占用的内核线程 (M) 会被释放, 去执行其他可运行的 Goroutine.
2. **唤醒 (Unparking):**
    - 当某个 worker Goroutine 调用 `wg.Done()` 时, 它会原子地将 `WaitGroup` 的计数器减一.
    - 如果 `Done()` 调用后, 发现计数器 **恰好变成了 0**, 那么这个 Goroutine 就有责任去唤醒所有正在等待这个 `WaitGroup` 的 Goroutine (是的, 可以有多个 Goroutine 同时 `Wait` 在同一个 `WaitGroup` 上).
    - "唤醒" 这个动作, 就是找到那个被"停放"的主 Goroutine, 并将其状态从 `_Gwaiting` 修改回 **`_Grunnable` (可运行)**.
    - 随后, 这个 `_Grunnable` 的主 Goroutine 会被放回到某个 P 的 **可运行队列** 中, 等待调度器下一次分配 M 给它执行.
**与 Java `unpark` 的对比和总结:**
- 你在面试中对 `unpark` 的理解偏差在于, 你把它和 `synchronized` 这样的监视器锁联系起来了. 实际上, Java 的 `LockSupport.park/unpark` 和 Go 的 Goroutine 调度一样, 都是一种更底层的机制.
- **Go 的优势在于:** 这个"停放"和"唤醒"的过程, 绝大部分时间都发生在 **用户态**, 由 Go 的运行时自己管理, 切换成本非常低. 它不像 Java 的线程那样, 每次阻塞和唤醒都必然涉及一次昂贵的内核态和用户态的切换.
- **结论:** `WaitGroup` 的通知之所以及时, 是因为它绕过了操作系统的线程调度, 直接在 Go 的运行时层面, 通过高效的 **状态机切换** 将等待的 Goroutine 重新放入执行队列. 这个过程几乎就是几次内存读写和指针操作, 因此效率极高.
-----
### 9, 10, 11. 事务隔离级别与幻读
  * **你的回答分析:** 这一系列问题你的回答都 **非常出色**, 几乎是满分答案.
      * 能准确说出四种隔离级别.
      * 能正确指出 `Repeatable Read` 级别可以避免大部分幻读, 而 `Serializable` 能完全解决.
      * 能准确说出 `RR` 级别解决幻读依赖 **MVCC** 和 **临键锁 (Next-Key Lock)**.
      * 能点出在 `RR` 级别下, **快照读和当前读混用** 时可能出现幻读, 这是一个非常深入的理解.
  * **面试官的意图:** 考察你对事务隔离性, MVCC, 锁机制等数据库核心理论的掌握程度. 你的回答展示了你不仅知道结论, 还了解底层原理.

-----

### 12\. 算法题

  * **12.1 任务编排:**

      * **题目理解:** `[i, j]` 表示任务 `i` 依赖任务 `j`, 意味着 `j` 必须在 `i` 之前完成. 这是一个典型的 **拓扑排序 (Topological Sort)** 问题. 目标是给出一个可行的任务执行序列. 示例 `[0,1,2]` 且 `0`依赖`1`, `1`依赖`2` 的意思是, 执行顺序必须是 `2 -> 1 -> 0`.
      * **解法:** 可以使用 **Kahn 算法 (基于入度)** 或 **基于 DFS** 的算法来解决. Kahn 算法更直观:
        1.  构建一个有向图, 并统计每个节点的 **入度 (in-degree)**.
        2.  将所有入度为 0 的节点放入一个队列.
        3.  当队列不为空时, 出队一个节点, 将其加入结果列表, 并将所有它指向的节点的入度减一.
        4.  如果某个邻接点的入度减为 0, 则将其入队.
        5.  循环结束, 如果结果列表中的节点数等于总节点数, 则排序成功.

  * **12.3 时钟问题:**

      * **题目理解:** 从 12 点出发, 走 `N` 步 (这里缺少 `N`, 这是关键), 每步可以顺时针或逆时针, 最终回到 12 点. 问有多少种走法.
      * **思路:** 这是 **动态规划** 或 **组合数学** 问题. 假设时钟有 `M` 个点 (这里是 12).
          * 设顺时针走了 `s` 步, 逆时针走了 `n` 步. 总步数 `s + n = N`.
          * 要回到原点, 净位移必须是 `M` 的整数倍. 即 `(s - n) % M == 0`.
          * 我们有 `s - n = s - (N - s) = 2s - N`. 所以问题转化为求解 `(2s - N) % M == 0`, 其中 `0 <= s <= N`.
          * 对于每一个满足条件的 `s`, 这 `N` 步中有 `s` 步是顺时针, `n` 步是逆时针, 这就是一个组合问题, 走法有 `C(N, s)` 种 (N 步中选 s 步顺时针).
          * 将所有满足条件的 `s` 对应的组合数 `C(N, s)` 相加就是总走法.

-----

### 13\. SQL 事务题

  * **你的回答分析:** 你的直觉是对的, 但分析过程把快照读和当前读搞混了. 最终结果 3 是对的.
  * **面试官的意图:** 考察在 `REPEATABLE READ` 级别下, `UPDATE` 语句如何加锁以及它属于什么读.
  * **正确分析流程:**
    1.  T1 `begin;`
    2.  T2 `begin;`
    3.  T1 `select a from t where id =2;` -\> **快照读**, 读取 Read View, 看到 `a=1`.
    4.  T2 `select a from t where id =2;` -\> **快照读**, 读取自己的 Read View, 看到 `a=1`.
    5.  T1 `update t set a = a+1;` -\> 这是一次 **当前读**, 它需要去读数据库中最新的值并加锁.
          * 它读到 `a` 的最新值是 `1`, 执行 `1+1=2`, 更新数据.
          * 同时, 它在 `id=2` 这一行上加了一个 **排他锁 (X-Lock)**.
    6.  T2 `update t set a = a+1;` -\> 它也想在 `id=2` 上加排他锁, 但发现 T1 已经持有锁, 所以 T2 **阻塞**.
    7.  T1 `commit;` -\> T1 释放了排他锁, 此时数据库中 `a` 的值正式变为 `2`.
    8.  T2 被唤醒, 成功获取到排他锁. 它执行 **当前读**, 读到 `a` 的最新值是 **2**.
    9.  T2 执行 `2+1=3`, 更新数据.
    10. T2 `commit;`
    <!-- end list -->
      * **最终 a 的值是 3.**

-----

### 14, 15, 16. 设计模式 (工厂模式)

  * **你的回答分析:** 你的回答是正确的. 知道三种角色, 知道举支付的例子, 知道区分简单工厂和工厂方法, 并且能准确说出 OCP 开闭原则是工厂方法的核心优点, 这已经非常好了. 紧张没写出完整代码很正常.
  * **面试官的意图:** 考察你对基本设计模式的理解和其背后所体现的设计原则.
  * **工厂方法的其他优点 (Q16):**
      * **解耦:** 将对象的 **创建** 和 **使用** 完全解耦. 客户端代码只依赖于抽象的工厂和抽象的产品接口, 完全不知道具体的产品是怎么被创建出来的.
      * **单一职责:** 每个具体的工厂只负责创建一种具体的产品, 职责非常清晰.
      * **更好的封装:** 工厂方法可以将复杂的创建逻辑封装起来, 客户端无需关心.

这个面试复盘非常有价值, 你在很多问题上都有不错的理解, 尤其是在数据库理论层面. 主要是在一些需要结合底层原理进行场景分析的问题上有些紧张和模糊. 把这次复盘的内容消化吸收, 下次面试一定会表现得更自信, 更出色\!